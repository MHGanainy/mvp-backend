Directory structure:
└── mvp-backend/
    ├── README.md
    ├── package.json
    ├── tsconfig.json
    ├── prisma/
    │   ├── schema.prisma
    │   └── migrations/
    │       ├── migration_lock.toml
    │       ├── 20250708140016_init/
    │       │   └── migration.sql
    │       ├── 20250708144233_add_specialty/
    │       │   └── migration.sql
    │       ├── 20250708150007_add_curriculum/
    │       │   └── migration.sql
    │       ├── 20250708160421_add_instructor/
    │       │   └── migration.sql
    │       ├── 20250708214917_add_student/
    │       │   └── migration.sql
    │       ├── 20250708230514_add_marking_domain/
    │       │   └── migration.sql
    │       ├── 20250708231354_add_exam/
    │       │   └── migration.sql
    │       ├── 20250708232445_add_course/
    │       │   └── migration.sql
    │       ├── 20250708233701_add_course_case/
    │       │   └── migration.sql
    │       ├── 20250708235709_add_simulation_system/
    │       │   └── migration.sql
    │       └── 20250709125700_complete_random_workflow/
    │           └── migration.sql
    └── src/
        ├── server.ts
        ├── entities/
        │   ├── auth/
        │   │   ├── auth.routes.ts
        │   │   ├── auth.schema.ts
        │   │   └── auth.service.ts
        │   ├── case-tab/
        │   │   ├── case-tab.routes.ts
        │   │   ├── case-tab.schema.ts
        │   │   └── case-tab.service.ts
        │   ├── course/
        │   │   ├── course.routes.ts
        │   │   ├── course.schema.ts
        │   │   └── course.service.ts
        │   ├── course-case/
        │   │   ├── course-case.routes.ts
        │   │   ├── course-case.schema.ts
        │   │   └── course-case.service.ts
        │   ├── curriculum/
        │   │   ├── curriculum.routes.ts
        │   │   ├── curriculum.schema.ts
        │   │   └── curriculum.service.ts
        │   ├── exam/
        │   │   ├── exam.routes.ts
        │   │   ├── exam.schema.ts
        │   │   └── exam.service.ts
        │   ├── instructor/
        │   │   ├── instructor.routes.ts
        │   │   ├── instructor.schema.ts
        │   │   └── instructor.service.ts
        │   ├── marking-domain/
        │   │   ├── marking-domain.routes.ts
        │   │   ├── marking-domain.schema.ts
        │   │   └── marking-domain.service.ts
        │   ├── simulation/
        │   │   ├── simulation.routes.ts
        │   │   ├── simulation.schema.ts
        │   │   └── simulation.service.ts
        │   ├── simulation-attempt/
        │   │   ├── simulation-attempt.routes.ts
        │   │   ├── simulation-attempt.schema.ts
        │   │   └── simulation-attempt.service.ts
        │   ├── specialty/
        │   │   ├── specialty.routes.ts
        │   │   ├── specialty.schema.ts
        │   │   └── specialty.service.ts
        │   ├── student/
        │   │   ├── student.routes.ts
        │   │   ├── student.schema.ts
        │   │   └── student.service.ts
        │   └── subscription/
        │       ├── subscription.routes.ts
        │       ├── subscription.schema.ts
        │       └── subscription.service.ts
        ├── middleware/
        │   └── auth.middleware.ts
        └── shared/
            ├── junction-tables.schema.ts
            └── types.ts

================================================
File: README.md
================================================
MVP-BACKEND


# 1. Link to your Railway project (if not already linked)
railway link

# 2. Set your database connection
railway variables --set DATABASE_URL="postgresql://postgres:IBdHmFwKDoDzMYEyVyhuYBwgdaWayUiJ@caboose.proxy.rlwy.net:55655/railway"

# 3. Set environment
railway variables --set NODE_ENV="production"

# 4. Deploy your app
railway up



# Run migrations on Railway
railway run npx prisma migrate deploy

# Or if that doesn't work, try:
railway run npx prisma db push


# Check your variables are set
railway variables

# Check deployment logs
railway logs

Reset Database:
Local: Stop prisma dev and restart
Production:
railway run npx prisma migrate reset
railway run npx prisma migrate deploy


View Database:
Local: npx prisma studio
Production: railway run npx prisma studio


npx prisma migrate dev --name add-curriculum





================================================
File: package.json
================================================
{
  "name": "mvp-backend",
  "version": "1.0.0",
  "description": "MVP-BACKEND",
  "main": "index.js",
  "scripts": {
    "dev": "nodemon --exec ts-node src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "postinstall": "prisma generate",
    "db:migrate": "npx prisma migrate deploy",
    "db:generate": "npx prisma generate"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/MHGanainy/mvp-backend.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/MHGanainy/mvp-backend/issues"
  },
  "homepage": "https://github.com/MHGanainy/mvp-backend#readme",
  "dependencies": {
    "@fastify/cors": "^11.0.1",
    "@fastify/helmet": "^13.0.1",
    "@fastify/jwt": "^9.1.0",
    "@fastify/rate-limit": "^10.3.0",
    "@fastify/swagger": "^9.5.1",
    "@fastify/swagger-ui": "^5.2.3",
    "@prisma/client": "^6.11.1",
    "bcryptjs": "^3.0.2",
    "fastify": "^5.4.0",
    "fastify-type-provider-zod": "^5.0.2",
    "pino-pretty": "^13.0.0",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/node": "^24.0.10",
    "nodemon": "^3.1.10",
    "prisma": "^6.11.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.8.3"
  }
}



================================================
File: tsconfig.json
================================================
{
    "compilerOptions": {
      "target": "ES2020",
      "module": "commonjs",
      "lib": ["ES2020"],
      "outDir": "./dist",
      "rootDir": "./src",
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules", "dist"]
  }


================================================
File: prisma/schema.prisma
================================================
// schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 Int       @id @default(autoincrement())
  email              String    @unique
  name               String?
  passwordHash       String?   @map("password_hash")
  emailVerified      Boolean   @default(false) @map("email_verified")
  verificationToken  String?   @unique @map("verification_token")
  resetToken         String?   @unique @map("reset_token")
  resetTokenExpiry   DateTime? @map("reset_token_expiry")
  createdAt          DateTime  @default(now()) @map("created_at")
  updatedAt          DateTime  @updatedAt @map("updated_at")
  
  // Relationships (one-to-one)
  instructor Instructor?
  student    Student?
  
  @@map("users")
}

model Instructor {
  id        String   @id @default(uuid())
  userId    Int      @unique @map("user_id")
  firstName String   @map("first_name")
  lastName  String   @map("last_name")
  bio       String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  // Relationships
  user    User     @relation(fields: [userId], references: [id])
  exams   Exam[]   // One instructor can create many exams
  courses Course[] // One instructor can create many courses
  
  @@map("instructors")
}

model Student {
  id               String              @id @default(uuid())
  userId           Int                 @unique @map("user_id")
  firstName        String              @map("first_name")
  lastName         String              @map("last_name")
  dateOfBirth      DateTime            @map("date_of_birth") @db.Date
  creditBalance    Int                 @default(0) @map("credit_balance")
  createdAt        DateTime            @default(now()) @map("created_at")
  updatedAt        DateTime            @updatedAt @map("updated_at")
  
  // Relationships
  user               User                @relation(fields: [userId], references: [id])
  simulationAttempts SimulationAttempt[] // One student has many attempts
  subscriptions      Subscription[]      // One student has many subscriptions
  payments           Payment[]           // One student has many payments
  creditTransactions CreditTransaction[] // One student has many credit transactions
  
  @@map("students")
}

model Exam {
  id           String   @id @default(uuid())
  instructorId String   @map("instructor_id")
  title        String
  slug         String   @unique
  description  String?
  isActive     Boolean  @default(true) @map("is_active")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  
  // Relationships
  instructor        Instructor        @relation(fields: [instructorId], references: [id])
  courses           Course[]          // One exam can have many courses
  examSpecialties   ExamSpecialty[]   // Many-to-many with Specialty
  examCurriculums   ExamCurriculum[]  // Many-to-many with Curriculum
  examMarkingDomains ExamMarkingDomain[] // Many-to-many with MarkingDomain
  
  @@map("exams")
}

model Course {
  id              String      @id @default(uuid())
  examId          String      @map("exam_id")
  instructorId    String      @map("instructor_id")
  title           String
  description     String?
  style           CourseStyle @default(RANDOM)
  price3Months    Decimal     @map("price_3_months") @db.Decimal(10,2)
  price6Months    Decimal     @map("price_6_months") @db.Decimal(10,2)
  price12Months   Decimal     @map("price_12_months") @db.Decimal(10,2)
  credits3Months  Int         @map("credits_3_months")
  credits6Months  Int         @map("credits_6_months")
  credits12Months Int         @map("credits_12_months")
  isPublished     Boolean     @default(false) @map("is_published")
  createdAt       DateTime    @default(now()) @map("created_at")
  updatedAt       DateTime    @updatedAt @map("updated_at")
  
  // Relationships
  exam          Exam           @relation(fields: [examId], references: [id])
  instructor    Instructor     @relation(fields: [instructorId], references: [id])
  courseCases   CourseCase[]   // One course has many cases
  subscriptions Subscription[] // One course has many subscriptions
  
  @@map("courses")
}

model CourseCase {
  id           String        @id @default(uuid())
  courseId     String        @map("course_id")
  title        String
  diagnosis    String
  patientName  String        @map("patient_name")
  patientAge   Int           @map("patient_age")
  patientGender PatientGender @map("patient_gender")
  description  String
  isFree       Boolean       @default(false) @map("is_free")
  displayOrder Int           @map("display_order")
  createdAt    DateTime      @default(now()) @map("created_at")
  updatedAt    DateTime      @updatedAt @map("updated_at")
  
  // Relationships
  course          Course          @relation(fields: [courseId], references: [id])
  simulation      Simulation?     // One CourseCase has one optional Simulation
  caseTabs        CaseTab[]       // One CourseCase has many case tabs
  caseSpecialties CaseSpecialty[] // Many-to-many with Specialty
  caseCurriculums CaseCurriculum[] // Many-to-many with Curriculum
  
  @@map("course_cases")
}

// NEW: CaseTab Model for the 4 content tabs
model CaseTab {
  id           String      @id @default(uuid())
  courseCaseId String      @map("course_case_id")
  tabType      CaseTabType @map("tab_type")
  content      String      @db.Text
  createdAt    DateTime    @default(now()) @map("created_at")
  updatedAt    DateTime    @updatedAt @map("updated_at")
  
  // Relationships
  courseCase CourseCase @relation(fields: [courseCaseId], references: [id], onDelete: Cascade)
  
  // Ensure each case has only one tab of each type
  @@unique([courseCaseId, tabType])
  @@map("case_tabs")
}

model Simulation {
  id                  String   @id @default(uuid())
  courseCaseId        String   @unique @map("course_case_id")
  casePrompt          String   @map("case_prompt") @db.Text
  openingLine         String   @map("opening_line")
  timeLimitMinutes    Int      @map("time_limit_minutes")
  voiceModel          VoiceModel @map("voice_model")
  warningTimeMinutes  Int?     @map("warning_time_minutes")
  creditCost          Int      @default(1) @map("credit_cost")
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")
  
  // Relationships
  courseCase         CourseCase         @relation(fields: [courseCaseId], references: [id])
  simulationAttempts SimulationAttempt[] // One simulation can have many attempts
  
  @@map("simulations")
}

model SimulationAttempt {
  id              String    @id @default(uuid())
  studentId       String    @map("student_id")
  simulationId    String    @map("simulation_id")
  startedAt       DateTime  @map("started_at")
  endedAt         DateTime? @map("ended_at")
  durationSeconds Int?      @map("duration_seconds")
  isCompleted     Boolean   @default(false) @map("is_completed")
  score           Decimal?  @db.Decimal(5,2)
  aiFeedback      Json?     @map("ai_feedback")
  transcript      Json?
  createdAt       DateTime  @default(now()) @map("created_at")
  
  // Relationships
  student    Student    @relation(fields: [studentId], references: [id])
  simulation Simulation @relation(fields: [simulationId], references: [id])
  
  @@map("simulation_attempts")
}

// NEW: Payment Model for Stripe integration
model Payment {
  id                   String        @id @default(uuid())
  studentId            String        @map("student_id")
  stripePaymentId      String        @unique @map("stripe_payment_id")
  amount               Decimal       @db.Decimal(10,2)
  currency             String        @default("USD")
  paymentType          PaymentType   @map("payment_type")
  paymentStatus        PaymentStatus @map("payment_status")
  courseId             String?       @map("course_id") // For subscription payments
  subscriptionDuration Int?          @map("subscription_duration") // 3, 6, or 12 months
  creditsAmount        Int?          @map("credits_amount") // For credit purchases
  createdAt            DateTime      @default(now()) @map("created_at")
  
  // Relationships
  student      Student       @relation(fields: [studentId], references: [id])
  subscription Subscription? // One payment can create one subscription
  
  @@map("payments")
}

// NEW: Subscription Model for course access
model Subscription {
  id             String   @id @default(uuid())
  studentId      String   @map("student_id")
  courseId       String   @map("course_id")
  paymentId      String   @unique @map("payment_id")
  durationMonths Int      @map("duration_months") // 3, 6, or 12
  startDate      DateTime @map("start_date") @db.Date
  endDate        DateTime @map("end_date") @db.Date
  isActive       Boolean  @map("is_active") // Computed from dates
  createdAt      DateTime @default(now()) @map("created_at")
  
  // Relationships
  student   Student   @relation(fields: [studentId], references: [id])
  course    Course    @relation(fields: [courseId], references: [id])
  payment   Payment   @relation(fields: [paymentId], references: [id])
  
  @@map("subscriptions")
}

// NEW: CreditTransaction Model for tracking credit usage
model CreditTransaction {
  id              String                    @id @default(uuid())
  studentId       String                    @map("student_id")
  transactionType CreditTransactionType     @map("transaction_type")
  amount          Int                       // Credits added/deducted
  balanceAfter    Int                       @map("balance_after")
  sourceType      CreditTransactionSource   @map("source_type")
  sourceId        String?                   @map("source_id") // Reference to source record
  description     String?                   // Optional description
  expiresAt       DateTime?                 @map("expires_at") // Only for complimentary credits
  createdAt       DateTime                  @default(now()) @map("created_at")
  
  // Relationships
  student Student @relation(fields: [studentId], references: [id])
  
  @@map("credit_transactions")
}

model Specialty {
  id        String   @id @default(uuid())
  name      String   @unique
  createdAt DateTime @default(now()) @map("created_at")

  // Relationships
  examSpecialties ExamSpecialty[] // Many-to-many with Exam
  caseSpecialties CaseSpecialty[] // Many-to-many with CourseCase

  @@map("specialties")
}

model Curriculum {
  id        String   @id @default(uuid())
  name      String   @unique
  createdAt DateTime @default(now()) @map("created_at")

  // Relationships
  examCurriculums ExamCurriculum[] // Many-to-many with Exam
  caseCurriculums CaseCurriculum[] // Many-to-many with CourseCase

  @@map("curriculums")
}

model MarkingDomain {
  id        String   @id @default(uuid())
  name      String   @unique
  createdAt DateTime @default(now()) @map("created_at")

  // Relationships
  examMarkingDomains ExamMarkingDomain[] // Many-to-many with Exam

  @@map("marking_domains")
}

// Junction Tables for Many-to-Many Relationships

model ExamSpecialty {
  examId      String   @map("exam_id")
  specialtyId String   @map("specialty_id")
  createdAt   DateTime @default(now()) @map("created_at")
  
  // Relationships
  exam      Exam      @relation(fields: [examId], references: [id], onDelete: Cascade)
  specialty Specialty @relation(fields: [specialtyId], references: [id], onDelete: Cascade)
  
  @@id([examId, specialtyId])
  @@map("exam_specialties")
}

model ExamCurriculum {
  examId         String     @map("exam_id")
  curriculumId   String     @map("curriculum_id")
  createdAt      DateTime   @default(now()) @map("created_at")
  
  // Relationships
  exam       Exam       @relation(fields: [examId], references: [id], onDelete: Cascade)
  curriculum Curriculum @relation(fields: [curriculumId], references: [id], onDelete: Cascade)
  
  @@id([examId, curriculumId])
  @@map("exam_curriculums")
}

model ExamMarkingDomain {
  examId          String        @map("exam_id")
  markingDomainId String        @map("marking_domain_id")
  createdAt       DateTime      @default(now()) @map("created_at")
  
  // Relationships
  exam          Exam          @relation(fields: [examId], references: [id], onDelete: Cascade)
  markingDomain MarkingDomain @relation(fields: [markingDomainId], references: [id], onDelete: Cascade)
  
  @@id([examId, markingDomainId])
  @@map("exam_marking_domains")
}

model CaseSpecialty {
  courseCaseId String    @map("course_case_id")
  specialtyId  String    @map("specialty_id")
  createdAt    DateTime  @default(now()) @map("created_at")
  
  // Relationships
  courseCase CourseCase @relation(fields: [courseCaseId], references: [id], onDelete: Cascade)
  specialty  Specialty  @relation(fields: [specialtyId], references: [id], onDelete: Cascade)
  
  @@id([courseCaseId, specialtyId])
  @@map("case_specialties")
}

model CaseCurriculum {
  courseCaseId String     @map("course_case_id")
  curriculumId String     @map("curriculum_id")
  createdAt    DateTime   @default(now()) @map("created_at")
  
  // Relationships
  courseCase CourseCase @relation(fields: [courseCaseId], references: [id], onDelete: Cascade)
  curriculum Curriculum @relation(fields: [curriculumId], references: [id], onDelete: Cascade)
  
  @@id([courseCaseId, curriculumId])
  @@map("case_curriculums")
}

// Enums
enum CourseStyle {
  RANDOM
  STRUCTURED
}

enum PatientGender {
  MALE
  FEMALE
  OTHER
}

enum VoiceModel {
  VOICE_1
  VOICE_2
}

enum CaseTabType {
  DOCTORS_NOTE
  PATIENT_SCRIPT
  MARKING_CRITERIA
  MEDICAL_NOTES
}

enum PaymentType {
  SUBSCRIPTION
  CREDITS
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
}

enum CreditTransactionType {
  CREDIT  // Adding credits
  DEBIT   // Deducting credits
}

enum CreditTransactionSource {
  SUBSCRIPTION  // Credits from subscription
  PURCHASE     // Credits from direct purchase
  SIMULATION   // Credits used for simulation
  MANUAL       // Manual adjustment
}


================================================
File: prisma/migrations/migration_lock.toml
================================================
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"



================================================
File: prisma/migrations/20250708140016_init/migration.sql
================================================
-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Post" (
    "id" SERIAL NOT NULL,
    "title" TEXT NOT NULL,
    "content" TEXT,
    "published" BOOLEAN NOT NULL DEFAULT false,
    "authorId" INTEGER NOT NULL,

    CONSTRAINT "Post_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- AddForeignKey
ALTER TABLE "Post" ADD CONSTRAINT "Post_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;



================================================
File: prisma/migrations/20250708144233_add_specialty/migration.sql
================================================
-- CreateTable
CREATE TABLE "specialties" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "specialties_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "specialties_name_key" ON "specialties"("name");



================================================
File: prisma/migrations/20250708150007_add_curriculum/migration.sql
================================================
-- CreateTable
CREATE TABLE "curriculums" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "curriculums_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "curriculums_name_key" ON "curriculums"("name");



================================================
File: prisma/migrations/20250708160421_add_instructor/migration.sql
================================================
/*
  Warnings:

  - You are about to drop the `Post` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `User` table. If the table is not empty, all the data it contains will be lost.

*/
-- DropForeignKey
ALTER TABLE "Post" DROP CONSTRAINT "Post_authorId_fkey";

-- DropTable
DROP TABLE "Post";

-- DropTable
DROP TABLE "User";

-- CreateTable
CREATE TABLE "users" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "instructors" (
    "id" TEXT NOT NULL,
    "user_id" INTEGER NOT NULL,
    "first_name" TEXT NOT NULL,
    "last_name" TEXT NOT NULL,
    "bio" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "instructors_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "users"("email");

-- CreateIndex
CREATE UNIQUE INDEX "instructors_user_id_key" ON "instructors"("user_id");

-- AddForeignKey
ALTER TABLE "instructors" ADD CONSTRAINT "instructors_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;



================================================
File: prisma/migrations/20250708214917_add_student/migration.sql
================================================
-- CreateTable
CREATE TABLE "students" (
    "id" TEXT NOT NULL,
    "user_id" INTEGER NOT NULL,
    "first_name" TEXT NOT NULL,
    "last_name" TEXT NOT NULL,
    "date_of_birth" DATE NOT NULL,
    "credit_balance" INTEGER NOT NULL DEFAULT 0,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "students_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "students_user_id_key" ON "students"("user_id");

-- AddForeignKey
ALTER TABLE "students" ADD CONSTRAINT "students_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;



================================================
File: prisma/migrations/20250708230514_add_marking_domain/migration.sql
================================================
-- CreateTable
CREATE TABLE "marking_domains" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "marking_domains_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "marking_domains_name_key" ON "marking_domains"("name");



================================================
File: prisma/migrations/20250708231354_add_exam/migration.sql
================================================
-- CreateTable
CREATE TABLE "exams" (
    "id" TEXT NOT NULL,
    "instructor_id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "slug" TEXT NOT NULL,
    "description" TEXT,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "exams_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "exams_slug_key" ON "exams"("slug");

-- AddForeignKey
ALTER TABLE "exams" ADD CONSTRAINT "exams_instructor_id_fkey" FOREIGN KEY ("instructor_id") REFERENCES "instructors"("id") ON DELETE RESTRICT ON UPDATE CASCADE;



================================================
File: prisma/migrations/20250708232445_add_course/migration.sql
================================================
-- CreateEnum
CREATE TYPE "CourseStyle" AS ENUM ('RANDOM', 'STRUCTURED');

-- CreateTable
CREATE TABLE "courses" (
    "id" TEXT NOT NULL,
    "exam_id" TEXT NOT NULL,
    "instructor_id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "style" "CourseStyle" NOT NULL DEFAULT 'RANDOM',
    "price_3_months" DECIMAL(10,2) NOT NULL,
    "price_6_months" DECIMAL(10,2) NOT NULL,
    "price_12_months" DECIMAL(10,2) NOT NULL,
    "credits_3_months" INTEGER NOT NULL,
    "credits_6_months" INTEGER NOT NULL,
    "credits_12_months" INTEGER NOT NULL,
    "is_published" BOOLEAN NOT NULL DEFAULT false,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "courses_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "courses" ADD CONSTRAINT "courses_exam_id_fkey" FOREIGN KEY ("exam_id") REFERENCES "exams"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "courses" ADD CONSTRAINT "courses_instructor_id_fkey" FOREIGN KEY ("instructor_id") REFERENCES "instructors"("id") ON DELETE RESTRICT ON UPDATE CASCADE;



================================================
File: prisma/migrations/20250708233701_add_course_case/migration.sql
================================================
-- CreateEnum
CREATE TYPE "PatientGender" AS ENUM ('MALE', 'FEMALE', 'OTHER');

-- CreateTable
CREATE TABLE "course_cases" (
    "id" TEXT NOT NULL,
    "course_id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "diagnosis" TEXT NOT NULL,
    "patient_name" TEXT NOT NULL,
    "patient_age" INTEGER NOT NULL,
    "patient_gender" "PatientGender" NOT NULL,
    "description" TEXT NOT NULL,
    "is_free" BOOLEAN NOT NULL DEFAULT false,
    "display_order" INTEGER NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "course_cases_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "course_cases" ADD CONSTRAINT "course_cases_course_id_fkey" FOREIGN KEY ("course_id") REFERENCES "courses"("id") ON DELETE RESTRICT ON UPDATE CASCADE;



================================================
File: prisma/migrations/20250708235709_add_simulation_system/migration.sql
================================================
-- CreateEnum
CREATE TYPE "VoiceModel" AS ENUM ('VOICE_1', 'VOICE_2');

-- CreateTable
CREATE TABLE "simulations" (
    "id" TEXT NOT NULL,
    "course_case_id" TEXT NOT NULL,
    "case_prompt" TEXT NOT NULL,
    "opening_line" TEXT NOT NULL,
    "time_limit_minutes" INTEGER NOT NULL,
    "voice_model" "VoiceModel" NOT NULL,
    "warning_time_minutes" INTEGER,
    "credit_cost" INTEGER NOT NULL DEFAULT 1,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "simulations_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "simulation_attempts" (
    "id" TEXT NOT NULL,
    "student_id" TEXT NOT NULL,
    "simulation_id" TEXT NOT NULL,
    "started_at" TIMESTAMP(3) NOT NULL,
    "ended_at" TIMESTAMP(3),
    "duration_seconds" INTEGER,
    "is_completed" BOOLEAN NOT NULL DEFAULT false,
    "score" DECIMAL(5,2),
    "ai_feedback" JSONB,
    "transcript" JSONB,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "simulation_attempts_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "simulations_course_case_id_key" ON "simulations"("course_case_id");

-- AddForeignKey
ALTER TABLE "simulations" ADD CONSTRAINT "simulations_course_case_id_fkey" FOREIGN KEY ("course_case_id") REFERENCES "course_cases"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "simulation_attempts" ADD CONSTRAINT "simulation_attempts_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "students"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "simulation_attempts" ADD CONSTRAINT "simulation_attempts_simulation_id_fkey" FOREIGN KEY ("simulation_id") REFERENCES "simulations"("id") ON DELETE RESTRICT ON UPDATE CASCADE;



================================================
File: prisma/migrations/20250709125700_complete_random_workflow/migration.sql
================================================
-- CreateEnum
CREATE TYPE "CaseTabType" AS ENUM ('DOCTORS_NOTE', 'PATIENT_SCRIPT', 'MARKING_CRITERIA', 'MEDICAL_NOTES');

-- CreateEnum
CREATE TYPE "PaymentType" AS ENUM ('SUBSCRIPTION', 'CREDITS');

-- CreateEnum
CREATE TYPE "PaymentStatus" AS ENUM ('PENDING', 'COMPLETED', 'FAILED');

-- CreateEnum
CREATE TYPE "CreditTransactionType" AS ENUM ('CREDIT', 'DEBIT');

-- CreateEnum
CREATE TYPE "CreditTransactionSource" AS ENUM ('SUBSCRIPTION', 'PURCHASE', 'SIMULATION', 'MANUAL');

-- CreateTable
CREATE TABLE "case_tabs" (
    "id" TEXT NOT NULL,
    "course_case_id" TEXT NOT NULL,
    "tab_type" "CaseTabType" NOT NULL,
    "content" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "case_tabs_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "payments" (
    "id" TEXT NOT NULL,
    "student_id" TEXT NOT NULL,
    "stripe_payment_id" TEXT NOT NULL,
    "amount" DECIMAL(10,2) NOT NULL,
    "currency" TEXT NOT NULL DEFAULT 'USD',
    "payment_type" "PaymentType" NOT NULL,
    "payment_status" "PaymentStatus" NOT NULL,
    "course_id" TEXT,
    "subscription_duration" INTEGER,
    "credits_amount" INTEGER,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "payments_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "subscriptions" (
    "id" TEXT NOT NULL,
    "student_id" TEXT NOT NULL,
    "course_id" TEXT NOT NULL,
    "payment_id" TEXT NOT NULL,
    "duration_months" INTEGER NOT NULL,
    "start_date" DATE NOT NULL,
    "end_date" DATE NOT NULL,
    "is_active" BOOLEAN NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "subscriptions_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "credit_transactions" (
    "id" TEXT NOT NULL,
    "student_id" TEXT NOT NULL,
    "transaction_type" "CreditTransactionType" NOT NULL,
    "amount" INTEGER NOT NULL,
    "balance_after" INTEGER NOT NULL,
    "source_type" "CreditTransactionSource" NOT NULL,
    "source_id" TEXT,
    "description" TEXT,
    "expires_at" TIMESTAMP(3),
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "credit_transactions_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "exam_specialties" (
    "exam_id" TEXT NOT NULL,
    "specialty_id" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "exam_specialties_pkey" PRIMARY KEY ("exam_id","specialty_id")
);

-- CreateTable
CREATE TABLE "exam_curriculums" (
    "exam_id" TEXT NOT NULL,
    "curriculum_id" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "exam_curriculums_pkey" PRIMARY KEY ("exam_id","curriculum_id")
);

-- CreateTable
CREATE TABLE "exam_marking_domains" (
    "exam_id" TEXT NOT NULL,
    "marking_domain_id" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "exam_marking_domains_pkey" PRIMARY KEY ("exam_id","marking_domain_id")
);

-- CreateTable
CREATE TABLE "case_specialties" (
    "course_case_id" TEXT NOT NULL,
    "specialty_id" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "case_specialties_pkey" PRIMARY KEY ("course_case_id","specialty_id")
);

-- CreateTable
CREATE TABLE "case_curriculums" (
    "course_case_id" TEXT NOT NULL,
    "curriculum_id" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "case_curriculums_pkey" PRIMARY KEY ("course_case_id","curriculum_id")
);

-- CreateIndex
CREATE UNIQUE INDEX "case_tabs_course_case_id_tab_type_key" ON "case_tabs"("course_case_id", "tab_type");

-- CreateIndex
CREATE UNIQUE INDEX "payments_stripe_payment_id_key" ON "payments"("stripe_payment_id");

-- CreateIndex
CREATE UNIQUE INDEX "subscriptions_payment_id_key" ON "subscriptions"("payment_id");

-- AddForeignKey
ALTER TABLE "case_tabs" ADD CONSTRAINT "case_tabs_course_case_id_fkey" FOREIGN KEY ("course_case_id") REFERENCES "course_cases"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "payments" ADD CONSTRAINT "payments_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "students"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "subscriptions" ADD CONSTRAINT "subscriptions_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "students"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "subscriptions" ADD CONSTRAINT "subscriptions_course_id_fkey" FOREIGN KEY ("course_id") REFERENCES "courses"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "subscriptions" ADD CONSTRAINT "subscriptions_payment_id_fkey" FOREIGN KEY ("payment_id") REFERENCES "payments"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "credit_transactions" ADD CONSTRAINT "credit_transactions_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "students"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "exam_specialties" ADD CONSTRAINT "exam_specialties_exam_id_fkey" FOREIGN KEY ("exam_id") REFERENCES "exams"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "exam_specialties" ADD CONSTRAINT "exam_specialties_specialty_id_fkey" FOREIGN KEY ("specialty_id") REFERENCES "specialties"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "exam_curriculums" ADD CONSTRAINT "exam_curriculums_exam_id_fkey" FOREIGN KEY ("exam_id") REFERENCES "exams"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "exam_curriculums" ADD CONSTRAINT "exam_curriculums_curriculum_id_fkey" FOREIGN KEY ("curriculum_id") REFERENCES "curriculums"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "exam_marking_domains" ADD CONSTRAINT "exam_marking_domains_exam_id_fkey" FOREIGN KEY ("exam_id") REFERENCES "exams"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "exam_marking_domains" ADD CONSTRAINT "exam_marking_domains_marking_domain_id_fkey" FOREIGN KEY ("marking_domain_id") REFERENCES "marking_domains"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "case_specialties" ADD CONSTRAINT "case_specialties_course_case_id_fkey" FOREIGN KEY ("course_case_id") REFERENCES "course_cases"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "case_specialties" ADD CONSTRAINT "case_specialties_specialty_id_fkey" FOREIGN KEY ("specialty_id") REFERENCES "specialties"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "case_curriculums" ADD CONSTRAINT "case_curriculums_course_case_id_fkey" FOREIGN KEY ("course_case_id") REFERENCES "course_cases"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "case_curriculums" ADD CONSTRAINT "case_curriculums_curriculum_id_fkey" FOREIGN KEY ("curriculum_id") REFERENCES "curriculums"("id") ON DELETE CASCADE ON UPDATE CASCADE;



================================================
File: src/server.ts
================================================
import Fastify from 'fastify'
import { PrismaClient } from '@prisma/client'
import fastifyJwt from '@fastify/jwt'
import fastifyCors from '@fastify/cors'
import './shared/types'

// Add all imports
import authRoutes from './entities/auth/auth.routes'
import subscriptionRoutes from './entities/subscription/subscription.routes'
import specialtyRoutes from './entities/specialty/specialty.routes'
import curriculumRoutes from './entities/curriculum/curriculum.routes'
import markingDomainRoutes from './entities/marking-domain/marking-domain.routes'
import instructorRoutes from './entities/instructor/instructor.routes'
import studentRoutes from './entities/student/student.routes'
import examRoutes from './entities/exam/exam.routes'
import courseRoutes from './entities/course/course.routes'
import courseCaseRoutes from './entities/course-case/course-case.routes'
import caseTabRoutes from './entities/case-tab/case-tab.routes'  
import simulationRoutes from './entities/simulation/simulation.routes'
import simulationAttemptRoutes from './entities/simulation-attempt/simulation-attempt.routes'

const fastify = Fastify({ logger: true })
const prisma = new PrismaClient()

// Register prisma on fastify instance
fastify.decorate('prisma', prisma)

// Register JWT plugin
const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-this-in-production'
fastify.register(fastifyJwt, {
  secret: JWT_SECRET,
  sign: {
    expiresIn: '1h'
  }
})

// Register CORS plugin - Allow ALL origins
fastify.register(fastifyCors, {
  origin: true, // This allows ALL origins
  credentials: true, // Allow cookies/credentials
  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'] // Allowed methods
})

// Health check
fastify.get('/health', async () => {
  return { status: 'OK', timestamp: new Date().toISOString() }
})

// Clean User routes
fastify.get('/users', async () => {
  const users = await prisma.user.findMany({
    include: { 
      instructor: true,
      student: true
    }
  })
  return users
})

fastify.post('/users', async (request) => {
  const { email, name } = request.body as { email: string; name?: string }
  
  const user = await prisma.user.create({
    data: { email, name }
  })
  return user
})

fastify.get('/users/:id', async (request) => {
  const { id } = request.params as { id: string }
  
  const user = await prisma.user.findUnique({
    where: { id: parseInt(id) },
    include: { 
      instructor: true,
      student: true
    }
  })
  
  if (!user) {
    throw new Error('User not found')
  }
  
  return user
})

// Start server
const start = async () => {
    try {
      // Register auth routes FIRST (no prefix needed)
      await fastify.register(authRoutes)
      
      // Register subscription routes (also at root level for easier access)
      await fastify.register(subscriptionRoutes, { prefix: '/api' })
      
      // Register all other route sets
      await fastify.register(specialtyRoutes, { prefix: '/api' })
      await fastify.register(curriculumRoutes, { prefix: '/api' })
      await fastify.register(markingDomainRoutes, { prefix: '/api' })
      await fastify.register(instructorRoutes, { prefix: '/api' })
      await fastify.register(studentRoutes, { prefix: '/api' })
      await fastify.register(examRoutes, { prefix: '/api' })
      await fastify.register(courseRoutes, { prefix: '/api' })
      await fastify.register(courseCaseRoutes, { prefix: '/api' })
      await fastify.register(caseTabRoutes, { prefix: '/api' })  
      await fastify.register(simulationRoutes, { prefix: '/api' })
      await fastify.register(simulationAttemptRoutes, { prefix: '/api' })
      
      const port = Number(process.env.PORT) || 3000
      const host = process.env.NODE_ENV === 'production' ? '0.0.0.0' : 'localhost'
      
      await fastify.listen({ port, host })
      console.log(`🚀 Server running on ${host}:${port}`)
      console.log(`🔐 JWT authentication enabled`)
      console.log(`🌐 CORS enabled for ALL origins`)
    } catch (err) {
      fastify.log.error(err)
      process.exit(1)
    }
  }
  
  start()


================================================
File: src/entities/auth/auth.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { AuthService } from './auth.service'
import { loginSchema, refreshTokenSchema } from './auth.schema'

export default async function authRoutes(fastify: FastifyInstance) {
  const authService = new AuthService(fastify.prisma, fastify)

  // POST /auth/login - Login endpoint
  fastify.post('/auth/login', async (request, reply) => {
    try {
      const data = loginSchema.parse(request.body)
      const result = await authService.login(data)
      reply.send(result)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Invalid credentials' || 
            error.message === 'User is not a student' || 
            error.message === 'User is not an instructor') {
          reply.status(401).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid login data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /auth/refresh - Refresh token endpoint
  fastify.post('/auth/refresh', async (request, reply) => {
    try {
      const data = refreshTokenSchema.parse(request.body)
      const result = await authService.refreshToken(data.refreshToken)
      reply.send(result)
    } catch (error) {
      if (error instanceof Error && error.message === 'Invalid refresh token') {
        reply.status(401).send({ error: 'Invalid refresh token' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /auth/me - Get current user (requires authentication)
  fastify.get('/auth/me', {
    preHandler: async (request, reply) => {
      try {
        await request.jwtVerify()
      } catch (err) {
        reply.status(401).send({ error: 'Unauthorized' })
      }
    }
  }, async (request, reply) => {
    try {
      const userId = (request.user as any).userId
      
      const user = await fastify.prisma.user.findUnique({
        where: { id: userId },
        include: {
          student: true,
          instructor: true
        }
      })

      if (!user) {
        reply.status(404).send({ error: 'User not found' })
        return
      }

      const userType = user.student ? 'student' : 'instructor'
      const profile = user.student ? {
        id: user.student.id,
        firstName: user.student.firstName,
        lastName: user.student.lastName,
        creditBalance: user.student.creditBalance
      } : {
        id: user.instructor!.id,
        firstName: user.instructor!.firstName,
        lastName: user.instructor!.lastName,
        bio: user.instructor!.bio
      }

      reply.send({
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          userType,
          profile
        }
      })
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch user information' })
    }
  })

  // POST /auth/logout - Logout endpoint (optional, mainly for client-side token removal)
  fastify.post('/auth/logout', {
    preHandler: async (request, reply) => {
      try {
        await request.jwtVerify()
      } catch (err) {
        reply.status(401).send({ error: 'Unauthorized' })
      }
    }
  }, async (request, reply) => {
    // In a stateless JWT system, logout is handled client-side
    // You could implement token blacklisting here if needed
    reply.send({ message: 'Logged out successfully' })
  })
}


================================================
File: src/entities/auth/auth.schema.ts
================================================
import { z } from 'zod'

// Login Schema
export const loginSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
  userType: z.enum(['student', 'instructor'])
})

// Token Refresh Schema
export const refreshTokenSchema = z.object({
  refreshToken: z.string()
})

// JWT Payload Schema
export const jwtPayloadSchema = z.object({
  userId: z.number(),
  userType: z.enum(['student', 'instructor']),
  email: z.string().email(),
  studentId: z.string().uuid().optional(),
  instructorId: z.string().uuid().optional()
})

// Auth Response Schema
export const authResponseSchema = z.object({
  accessToken: z.string(),
  refreshToken: z.string(),
  expiresIn: z.number(),
  userType: z.string(),
  user: z.object({
    id: z.number(),
    email: z.string(),
    name: z.string().nullable(),
    profile: z.union([
      z.object({
        id: z.string(),
        firstName: z.string(),
        lastName: z.string(),
        creditBalance: z.number()
      }),
      z.object({
        id: z.string(),
        firstName: z.string(),
        lastName: z.string(),
        bio: z.string().nullable()
      })
    ])
  })
})

// Type exports
export type LoginInput = z.infer<typeof loginSchema>
export type RefreshTokenInput = z.infer<typeof refreshTokenSchema>
export type JWTPayload = z.infer<typeof jwtPayloadSchema>
export type AuthResponse = z.infer<typeof authResponseSchema>


================================================
File: src/entities/auth/auth.service.ts
================================================
import { PrismaClient } from '@prisma/client'
import * as bcrypt from 'bcryptjs'
import { FastifyInstance } from 'fastify'
import { LoginInput, JWTPayload } from './auth.schema'

export class AuthService {
  private fastify: FastifyInstance
  
  constructor(private prisma: PrismaClient, fastify: FastifyInstance) {
    this.fastify = fastify
  }

  async login(data: LoginInput) {
    // Find user by email
    const user = await this.prisma.user.findUnique({
      where: { email: data.email },
      include: {
        student: true,
        instructor: true
      }
    })

    if (!user) {
      throw new Error('Invalid credentials')
    }

    // Check if user has the correct type
    if (data.userType === 'student' && !user.student) {
      throw new Error('User is not a student')
    }
    if (data.userType === 'instructor' && !user.instructor) {
      throw new Error('User is not an instructor')
    }

    // For now, we'll use a temporary password check (you'll need to add password field to DB)
    // In production, you'd store hashed passwords in the database
    const isValidPassword = await this.validatePassword(data.password, user.id)
    
    if (!isValidPassword) {
      throw new Error('Invalid credentials')
    }

    // Generate tokens
    const payload: JWTPayload = {
      userId: user.id,
      userType: data.userType,
      email: user.email,
      studentId: user.student?.id,
      instructorId: user.instructor?.id
    }

    const accessToken = await this.generateAccessToken(payload)
    const refreshToken = await this.generateRefreshToken(payload)

    // Get profile based on user type
    const profile = data.userType === 'student' ? {
      id: user.student!.id,
      firstName: user.student!.firstName,
      lastName: user.student!.lastName,
      creditBalance: user.student!.creditBalance
    } : {
      id: user.instructor!.id,
      firstName: user.instructor!.firstName,
      lastName: user.instructor!.lastName,
      bio: user.instructor!.bio
    }

    return {
      accessToken,
      refreshToken,
      expiresIn: 3600, // 1 hour
      userType: data.userType,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        profile
      }
    }
  }

  async refreshToken(refreshToken: string) {
    try {
      // Verify refresh token
      const decoded = await this.fastify.jwt.verify(refreshToken) as JWTPayload
      
      // Check if user still exists
      const user = await this.prisma.user.findUnique({
        where: { id: decoded.userId },
        include: {
          student: true,
          instructor: true
        }
      })

      if (!user) {
        throw new Error('User not found')
      }

      // Generate new access token
      const newAccessToken = await this.generateAccessToken(decoded)
      
      return {
        accessToken: newAccessToken,
        expiresIn: 3600
      }
    } catch (error) {
      throw new Error('Invalid refresh token')
    }
  }

  async verifyToken(token: string): Promise<JWTPayload> {
    try {
      const decoded = await this.fastify.jwt.verify(token) as JWTPayload
      return decoded
    } catch (error) {
      throw new Error('Invalid token')
    }
  }

  private async generateAccessToken(payload: JWTPayload): Promise<string> {
    return this.fastify.jwt.sign(payload, {
      expiresIn: '1h'
    })
  }

  private async generateRefreshToken(payload: JWTPayload): Promise<string> {
    return this.fastify.jwt.sign(payload, {
      expiresIn: '7d'
    })
  }

  // Temporary password validation - in production, passwords would be stored in DB
  private async validatePassword(password: string, userId: number): Promise<boolean> {
    // For demo purposes, we'll accept any password that's at least 6 characters
    // In production, you'd compare against a hashed password stored in the database
    return password.length >= 6
  }

  // Helper method to hash passwords (for registration)
  async hashPassword(password: string): Promise<string> {
    const saltRounds = 10
    return bcrypt.hash(password, saltRounds)
  }

  // Helper method to compare passwords
  async comparePassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash)
  }
}


================================================
File: src/entities/case-tab/case-tab.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { CaseTabService } from './case-tab.service'
import { 
  createCaseTabSchema, 
  updateCaseTabSchema, 
  caseTabParamsSchema,
  caseTabCourseCaseParamsSchema,
  caseTabTypeParamsSchema,
  courseParamsSchema,
  bulkUpdateCaseTabSchema,
  createAllTabsSchema
} from './case-tab.schema'

export default async function caseTabRoutes(fastify: FastifyInstance) {
  const caseTabService = new CaseTabService(fastify.prisma)

  // GET /case-tabs - Get all case tabs
  fastify.get('/case-tabs', async (request, reply) => {
    try {
      const caseTabs = await caseTabService.findAll()
      reply.send(caseTabs)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch case tabs' })
    }
  })

  // GET /case-tabs/course-case/:courseCaseId - Get all tabs for a course case
  fastify.get('/case-tabs/course-case/:courseCaseId', async (request, reply) => {
    try {
      const { courseCaseId } = caseTabCourseCaseParamsSchema.parse(request.params)
      const caseTabs = await caseTabService.findByCourseCase(courseCaseId)
      reply.send(caseTabs)
    } catch (error) {
      if (error instanceof Error && error.message === 'Course case not found') {
        reply.status(404).send({ error: 'Course case not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /case-tabs/course-case/:courseCaseId/:tabType - Get specific tab for a course case
  fastify.get('/case-tabs/course-case/:courseCaseId/:tabType', async (request, reply) => {
    try {
      const { courseCaseId, tabType } = caseTabTypeParamsSchema.parse(request.params)
      const caseTab = await caseTabService.findByTabType(courseCaseId, tabType)
      reply.send(caseTab)
    } catch (error) {
      if (error instanceof Error && error.message.includes('tab not found')) {
        reply.status(404).send({ error: error.message })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /case-tabs/course-case/:courseCaseId/stats - Get tab completion stats for a course case
  fastify.get('/case-tabs/course-case/:courseCaseId/stats', async (request, reply) => {
    try {
      const { courseCaseId } = caseTabCourseCaseParamsSchema.parse(request.params)
      const stats = await caseTabService.getCaseTabStats(courseCaseId)
      reply.send(stats)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /case-tabs/course/:courseId/overview - Get tabs overview for entire course
  fastify.get('/case-tabs/course/:courseId/overview', async (request, reply) => {
    try {
      const { courseId } = courseParamsSchema.parse(request.params)
      const overview = await caseTabService.getCourseTabsOverview(courseId)
      reply.send(overview)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /case-tabs/:id - Get case tab by ID
  fastify.get('/case-tabs/:id', async (request, reply) => {
    try {
      const { id } = caseTabParamsSchema.parse(request.params)
      const caseTab = await caseTabService.findById(id)
      reply.send(caseTab)
    } catch (error) {
      if (error instanceof Error && error.message === 'Case tab not found') {
        reply.status(404).send({ error: 'Case tab not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /case-tabs - Create new case tab
  fastify.post('/case-tabs', async (request, reply) => {
    try {
      const data = createCaseTabSchema.parse(request.body)
      const caseTab = await caseTabService.create(data)
      reply.status(201).send(caseTab)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message.includes('already has a') && error.message.includes('tab')) {
          reply.status(400).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /case-tabs/create-all - Create all 4 tabs for a course case
  fastify.post('/case-tabs/create-all', async (request, reply) => {
    try {
      const { courseCaseId } = createAllTabsSchema.parse(request.body)
      const tabs = await caseTabService.createAllTabsForCase(courseCaseId)
      reply.status(201).send({
        message: 'All tabs created successfully',
        tabs,
        totalCreated: tabs.length
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message === 'Some tabs already exist for this case') {
          reply.status(400).send({ error: 'Some tabs already exist for this case' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PUT /case-tabs/:id - Update case tab
  fastify.put('/case-tabs/:id', async (request, reply) => {
    try {
      const { id } = caseTabParamsSchema.parse(request.params)
      const data = updateCaseTabSchema.parse(request.body)
      const caseTab = await caseTabService.update(id, data)
      reply.send(caseTab)
    } catch (error) {
      if (error instanceof Error && error.message === 'Case tab not found') {
        reply.status(404).send({ error: 'Case tab not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // PUT /case-tabs/course-case/:courseCaseId/bulk-update - Update multiple tabs at once
  fastify.put('/case-tabs/course-case/:courseCaseId/bulk-update', async (request, reply) => {
    try {
      const { courseCaseId } = caseTabCourseCaseParamsSchema.parse(request.params)
      const { tabUpdates } = bulkUpdateCaseTabSchema.parse(request.body)
      
      const updatedTabs = await caseTabService.bulkUpdateTabContent(courseCaseId, tabUpdates)
      reply.send({
        message: 'Tabs updated successfully',
        updatedTabs,
        totalUpdated: updatedTabs.length
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // DELETE /case-tabs/:id - Delete case tab
  fastify.delete('/case-tabs/:id', async (request, reply) => {
    try {
      const { id } = caseTabParamsSchema.parse(request.params)
      await caseTabService.delete(id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'Case tab not found') {
        reply.status(404).send({ error: 'Case tab not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // Helper endpoint to get tab types (useful for frontend)
  fastify.get('/case-tabs/types', async (request, reply) => {
    reply.send({
      tabTypes: ['DOCTORS_NOTE', 'PATIENT_SCRIPT', 'MARKING_CRITERIA', 'MEDICAL_NOTES'],
      descriptions: {
        DOCTORS_NOTE: "Doctor's clinical notes and observations",
        PATIENT_SCRIPT: "Patient dialogue and responses script",
        MARKING_CRITERIA: "Assessment criteria and scoring rubric",
        MEDICAL_NOTES: "Key medical points and references"
      }
    })
  })
}


================================================
File: src/entities/case-tab/case-tab.schema.ts
================================================
import { z } from 'zod'

// CaseTabType enum
export const CaseTabTypeEnum = z.enum(['DOCTORS_NOTE', 'PATIENT_SCRIPT', 'MARKING_CRITERIA', 'MEDICAL_NOTES'])

// Create CaseTab Schema
export const createCaseTabSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  tabType: CaseTabTypeEnum,
  content: z.string()
    .max(10000, 'Content must be less than 10,000 characters')
    .default('')
})

// Update CaseTab Schema
export const updateCaseTabSchema = z.object({
  content: z.string()
    .max(10000, 'Content must be less than 10,000 characters')
    .optional()
})

// URL Params Schemas
export const caseTabParamsSchema = z.object({
  id: z.string().uuid('Invalid case tab ID')
})

export const caseTabCourseCaseParamsSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID')
})

export const caseTabTypeParamsSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  tabType: CaseTabTypeEnum
})

export const courseParamsSchema = z.object({
  courseId: z.string().uuid('Invalid course ID')
})

// Bulk update schema
export const bulkUpdateCaseTabSchema = z.object({
  tabUpdates: z.array(z.object({
    tabType: CaseTabTypeEnum,
    content: z.string()
      .max(10000, 'Content must be less than 10,000 characters')
  })).min(1, 'At least one tab update is required').max(4, 'Cannot update more than 4 tabs')
})

// Create all tabs schema
export const createAllTabsSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID')
})

// Response Schema
export const caseTabResponseSchema = z.object({
  id: z.string(),
  courseCaseId: z.string(),
  tabType: CaseTabTypeEnum,
  content: z.string(),
  createdAt: z.date(),
  updatedAt: z.date(),
  courseCase: z.object({
    id: z.string(),
    title: z.string(),
    diagnosis: z.string(),
    patientName: z.string(),
    course: z.object({
      id: z.string(),
      title: z.string(),
      exam: z.object({
        id: z.string(),
        title: z.string(),
        slug: z.string()
      })
    })
  })
})

// Stats response schemas
export const caseTabStatsResponseSchema = z.object({
  courseCaseId: z.string(),
  totalTabs: z.number(),
  completedTabs: z.number(),
  emptyTabs: z.number(),
  tabDetails: z.array(z.object({
    tabType: CaseTabTypeEnum,
    hasContent: z.boolean(),
    contentLength: z.number(),
    lastUpdated: z.date()
  }))
})

export const courseTabsOverviewResponseSchema = z.object({
  courseId: z.string(),
  totalCases: z.number(),
  casesWithAllTabs: z.number(),
  casesWithCompletedContent: z.number(),
  averageCompletion: z.number(),
  caseDetails: z.array(z.object({
    caseId: z.string(),
    caseTitle: z.string(),
    totalTabs: z.number(),
    completedTabs: z.number(),
    completionPercentage: z.number()
  }))
})

// Type exports
export type CreateCaseTabInput = z.infer<typeof createCaseTabSchema>
export type UpdateCaseTabInput = z.infer<typeof updateCaseTabSchema>
export type CaseTabParams = z.infer<typeof caseTabParamsSchema>
export type CaseTabCourseCaseParams = z.infer<typeof caseTabCourseCaseParamsSchema>
export type CaseTabTypeParams = z.infer<typeof caseTabTypeParamsSchema>
export type CourseParams = z.infer<typeof courseParamsSchema>
export type BulkUpdateCaseTabInput = z.infer<typeof bulkUpdateCaseTabSchema>
export type CreateAllTabsInput = z.infer<typeof createAllTabsSchema>
export type CaseTabResponse = z.infer<typeof caseTabResponseSchema>
export type CaseTabStatsResponse = z.infer<typeof caseTabStatsResponseSchema>
export type CourseTabsOverviewResponse = z.infer<typeof courseTabsOverviewResponseSchema>
export type CaseTabType = z.infer<typeof CaseTabTypeEnum>


================================================
File: src/entities/case-tab/case-tab.service.ts
================================================
import { PrismaClient } from '@prisma/client'
import { CreateCaseTabInput, UpdateCaseTabInput, CaseTabType } from './case-tab.schema'

export class CaseTabService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateCaseTabInput) {
    // Verify the course case exists
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id: data.courseCaseId },
      include: {
        course: {
          include: { exam: true }
        }
      }
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    // Check if this case already has a tab of this type
    const existingTab = await this.prisma.caseTab.findUnique({
      where: {
        courseCaseId_tabType: {
          courseCaseId: data.courseCaseId,
          tabType: data.tabType
        }
      }
    })

    if (existingTab) {
      throw new Error(`Case already has a ${data.tabType} tab`)
    }

    return await this.prisma.caseTab.create({
      data: {
        courseCaseId: data.courseCaseId,
        tabType: data.tabType,
        content: data.content
      },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  async findAll() {
    return await this.prisma.caseTab.findMany({
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: [
        { courseCase: { title: 'asc' } },
        { tabType: 'asc' }
      ]
    })
  }

  async findById(id: string) {
    const caseTab = await this.prisma.caseTab.findUnique({
      where: { id },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!caseTab) {
      throw new Error('Case tab not found')
    }

    return caseTab
  }

  async findByCourseCase(courseCaseId: string) {
    // Verify course case exists
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id: courseCaseId }
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    return await this.prisma.caseTab.findMany({
      where: { courseCaseId },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: { tabType: 'asc' }
    })
  }

  async findByTabType(courseCaseId: string, tabType: CaseTabType) {
    const caseTab = await this.prisma.caseTab.findUnique({
      where: {
        courseCaseId_tabType: {
          courseCaseId,
          tabType
        }
      },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!caseTab) {
      throw new Error(`${tabType} tab not found for this case`)
    }

    return caseTab
  }

  async update(id: string, data: UpdateCaseTabInput) {
    // Check if case tab exists
    await this.findById(id)

    return await this.prisma.caseTab.update({
      where: { id },
      data,
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  async delete(id: string) {
    // Check if case tab exists
    await this.findById(id)

    return await this.prisma.caseTab.delete({
      where: { id }
    })
  }

  // BUSINESS LOGIC METHODS

  async createAllTabsForCase(courseCaseId: string) {
    // Verify course case exists
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id: courseCaseId }
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    // Check if any tabs already exist
    const existingTabs = await this.prisma.caseTab.findMany({
      where: { courseCaseId }
    })

    if (existingTabs.length > 0) {
      throw new Error('Some tabs already exist for this case')
    }

    // Create all 4 tabs with empty content
    const tabTypes: CaseTabType[] = ['DOCTORS_NOTE', 'PATIENT_SCRIPT', 'MARKING_CRITERIA', 'MEDICAL_NOTES']
    
    const tabs = await Promise.all(
      tabTypes.map((tabType: CaseTabType) => 
        this.prisma.caseTab.create({
          data: {
            courseCaseId,
            tabType,
            content: '' // Start with empty content
          },
          include: {
            courseCase: {
              include: {
                course: {
                  include: {
                    exam: {
                      select: {
                        id: true,
                        title: true,
                        slug: true
                      }
                    }
                  }
                }
              }
            }
          }
        })
      )
    )

    return tabs
  }

  async getCaseTabStats(courseCaseId: string) {
    const tabs = await this.prisma.caseTab.findMany({
      where: { courseCaseId },
      select: {
        tabType: true,
        content: true,
        updatedAt: true
      }
    })

    return {
      courseCaseId,
      totalTabs: tabs.length,
      completedTabs: tabs.filter((tab: { content: string }) => tab.content && tab.content.trim().length > 0).length,
      emptyTabs: tabs.filter((tab: { content: string }) => !tab.content || tab.content.trim().length === 0).length,
      tabDetails: tabs.map((tab: { tabType: any; content: string; updatedAt: Date }) => ({
        tabType: tab.tabType,
        hasContent: !!(tab.content && tab.content.trim().length > 0),
        contentLength: tab.content?.length || 0,
        lastUpdated: tab.updatedAt
      }))
    }
  }

  async getCourseTabsOverview(courseId: string) {
    // Get all cases for this course
    const courseCases = await this.prisma.courseCase.findMany({
      where: { courseId },
      include: {
        caseTabs: {
          select: {
            tabType: true,
            content: true
          }
        }
      }
    })

    const overview = courseCases.map((courseCase: { 
      id: string; 
      title: string; 
      caseTabs: Array<{ tabType: any; content: string }> 
    }) => ({
      caseId: courseCase.id,
      caseTitle: courseCase.title,
      totalTabs: courseCase.caseTabs.length,
      completedTabs: courseCase.caseTabs.filter((tab: { content: string }) => tab.content && tab.content.trim().length > 0).length,
      completionPercentage: courseCase.caseTabs.length > 0 
        ? Math.round((courseCase.caseTabs.filter((tab: { content: string }) => tab.content && tab.content.trim().length > 0).length / 4) * 100)
        : 0
    }))

    return {
      courseId,
      totalCases: courseCases.length,
      casesWithAllTabs: overview.filter((item: { totalTabs: number }) => item.totalTabs === 4).length,
      casesWithCompletedContent: overview.filter((item: { completedTabs: number }) => item.completedTabs === 4).length,
      averageCompletion: overview.length > 0 
        ? Math.round(overview.reduce((sum: number, item: { completionPercentage: number }) => sum + item.completionPercentage, 0) / overview.length)
        : 0,
      caseDetails: overview
    }
  }

  async bulkUpdateTabContent(courseCaseId: string, tabUpdates: { tabType: CaseTabType; content: string }[]) {
    // Verify course case exists
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id: courseCaseId }
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    // Update all tabs in a transaction
    const updatedTabs = await this.prisma.$transaction(
      tabUpdates.map((update: { tabType: CaseTabType; content: string }) => 
        this.prisma.caseTab.upsert({
          where: {
            courseCaseId_tabType: {
              courseCaseId,
              tabType: update.tabType
            }
          },
          update: {
            content: update.content
          },
          create: {
            courseCaseId,
            tabType: update.tabType,
            content: update.content
          },
          include: {
            courseCase: {
              include: {
                course: {
                  include: {
                    exam: {
                      select: {
                        id: true,
                        title: true,
                        slug: true
                      }
                    }
                  }
                }
              }
            }
          }
        })
      )
    )

    return updatedTabs
  }
}


================================================
File: src/entities/course/course.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { z } from 'zod'
import { CourseService } from './course.service'
import { 
  createCourseSchema, 
  updateCourseSchema, 
  courseParamsSchema,
  courseExamParamsSchema,
  courseInstructorParamsSchema,
  CourseStyleEnum
} from './course.schema'

// Business operation schemas
const pricingUpdateSchema = z.object({
  price3Months: z.number().positive().max(99999.99).transform(val => Number(val.toFixed(2))).optional(),
  price6Months: z.number().positive().max(99999.99).transform(val => Number(val.toFixed(2))).optional(),
  price12Months: z.number().positive().max(99999.99).transform(val => Number(val.toFixed(2))).optional()
})

const creditsUpdateSchema = z.object({
  credits3Months: z.number().int().min(0).max(1000).optional(),
  credits6Months: z.number().int().min(0).max(1000).optional(),
  credits12Months: z.number().int().min(0).max(1000).optional()
})

const styleParamsSchema = z.object({
  style: CourseStyleEnum
})

export default async function courseRoutes(fastify: FastifyInstance) {
  const courseService = new CourseService(fastify.prisma)

  // GET /courses - Get all courses
  fastify.get('/courses', async (request, reply) => {
    try {
      const courses = await courseService.findAll()
      reply.send(courses)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch courses' })
    }
  })

  // GET /courses/published - Get only published courses (public endpoint)
  fastify.get('/courses/published', async (request, reply) => {
    try {
      const courses = await courseService.findPublished()
      reply.send(courses)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch published courses' })
    }
  })

  // GET /courses/style/:style - Get courses by style (RANDOM/STRUCTURED)
  fastify.get('/courses/style/:style', async (request, reply) => {
    try {
      const { style } = styleParamsSchema.parse(request.params)
      const courses = await courseService.findByStyle(style)
      reply.send(courses)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid course style' })
    }
  })

  // GET /courses/exam/:examId - Get courses by exam
  fastify.get('/courses/exam/:examId', async (request, reply) => {
    try {
      const { examId } = courseExamParamsSchema.parse(request.params)
      const courses = await courseService.findByExam(examId)
      reply.send(courses)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /courses/instructor/:instructorId - Get courses by instructor
  fastify.get('/courses/instructor/:instructorId', async (request, reply) => {
    try {
      const { instructorId } = courseInstructorParamsSchema.parse(request.params)
      const courses = await courseService.findByInstructor(instructorId)
      reply.send(courses)
    } catch (error) {
      if (error instanceof Error && error.message === 'Instructor not found') {
        reply.status(404).send({ error: 'Instructor not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /courses/:id - Get course by ID
  fastify.get('/courses/:id', async (request, reply) => {
    try {
      const { id } = courseParamsSchema.parse(request.params)
      const course = await courseService.findById(id)
      reply.send(course)
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /courses/:id/pricing - Get pricing information for a course
  fastify.get('/courses/:id/pricing', async (request, reply) => {
    try {
      const { id } = courseParamsSchema.parse(request.params)
      const pricingInfo = await courseService.getPricingInfo(id)
      reply.send(pricingInfo)
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /courses - Create new course
  fastify.post('/courses', async (request, reply) => {
    try {
      const data = createCourseSchema.parse(request.body)
      const course = await courseService.create(data)
      reply.status(201).send(course)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Instructor not found') {
          reply.status(404).send({ error: 'Instructor not found' })
        } else if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message === 'Instructor can only create courses for their own exams') {
          reply.status(403).send({ error: 'Instructor can only create courses for their own exams' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PUT /courses/:id - Update course
  fastify.put('/courses/:id', async (request, reply) => {
    try {
      const { id } = courseParamsSchema.parse(request.params)
      const data = updateCourseSchema.parse(request.body)
      const course = await courseService.update(id, data)
      reply.send(course)
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // PATCH /courses/:id/toggle - Toggle course published status
  fastify.patch('/courses/:id/toggle', async (request, reply) => {
    try {
      const { id } = courseParamsSchema.parse(request.params)
      const course = await courseService.togglePublished(id)
      reply.send({
        message: `Course ${course.isPublished ? 'published' : 'unpublished'} successfully`,
        course
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // PATCH /courses/:id/pricing - Update course pricing
  fastify.patch('/courses/:id/pricing', async (request, reply) => {
    try {
      const { id } = courseParamsSchema.parse(request.params)
      const pricing = pricingUpdateSchema.parse(request.body)
      const course = await courseService.updatePricing(id, pricing)
      reply.send({
        message: 'Course pricing updated successfully',
        course
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid pricing data' })
      }
    }
  })

  // PATCH /courses/:id/credits - Update course credit allocation
  fastify.patch('/courses/:id/credits', async (request, reply) => {
    try {
      const { id } = courseParamsSchema.parse(request.params)
      const credits = creditsUpdateSchema.parse(request.body)
      const course = await courseService.updateCredits(id, credits)
      reply.send({
        message: 'Course credit allocation updated successfully',
        course
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid credits data' })
      }
    }
  })

  // DELETE /courses/:id - Delete course
  fastify.delete('/courses/:id', async (request, reply) => {
    try {
      const { id } = courseParamsSchema.parse(request.params)
      await courseService.delete(id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })
}


================================================
File: src/entities/course/course.schema.ts
================================================
import { z } from 'zod'

// CourseStyle enum
export const CourseStyleEnum = z.enum(['RANDOM', 'STRUCTURED'])

// Create Course Schema (includes business validation)
export const createCourseSchema = z.object({
  examId: z.string().uuid('Invalid exam ID'),
  instructorId: z.string().uuid('Invalid instructor ID'),
  title: z.string()
    .min(1, 'Title is required')
    .max(200, 'Title must be less than 200 characters')
    .trim(),
  description: z.string()
    .max(1000, 'Description must be less than 1000 characters')
    .optional(),
  style: CourseStyleEnum.default('RANDOM'),
  
  // Pricing validation (business rules)
  price3Months: z.number()
    .positive('3-month price must be positive')
    .max(99999.99, 'Price too high')
    .transform(val => Number(val.toFixed(2))),
  price6Months: z.number()
    .positive('6-month price must be positive') 
    .max(99999.99, 'Price too high')
    .transform(val => Number(val.toFixed(2))),
  price12Months: z.number()
    .positive('12-month price must be positive')
    .max(99999.99, 'Price too high')
    .transform(val => Number(val.toFixed(2))),
    
  // Credit allocation validation
  credits3Months: z.number()
    .int('Credits must be whole numbers')
    .min(0, 'Credits cannot be negative')
    .max(1000, 'Credits too high'),
  credits6Months: z.number()
    .int('Credits must be whole numbers')
    .min(0, 'Credits cannot be negative')
    .max(1000, 'Credits too high'),
  credits12Months: z.number()
    .int('Credits must be whole numbers')
    .min(0, 'Credits cannot be negative')
    .max(1000, 'Credits too high'),
    
  isPublished: z.boolean().default(false).optional()
}).refine((data) => {
  // Business rule: 6-month should be cheaper per month than 3-month
  const monthly3 = data.price3Months / 3
  const monthly6 = data.price6Months / 6
  return monthly6 <= monthly3
}, {
  message: '6-month plan should offer better value than 3-month plan',
  path: ['price6Months']
}).refine((data) => {
  // Business rule: 12-month should be cheapest per month
  const monthly6 = data.price6Months / 6
  const monthly12 = data.price12Months / 12
  return monthly12 <= monthly6
}, {
  message: '12-month plan should offer best value',
  path: ['price12Months']
}).refine((data) => {
  // Business rule: Longer subscriptions should have more credits
  return data.credits6Months >= data.credits3Months && 
         data.credits12Months >= data.credits6Months
}, {
  message: 'Longer subscriptions should include more credits',
  path: ['credits12Months']
})

// Update Course Schema
export const updateCourseSchema = z.object({
  title: z.string()
    .min(1, 'Title is required')
    .max(200, 'Title must be less than 200 characters')
    .trim()
    .optional(),
  description: z.string()
    .max(1000, 'Description must be less than 1000 characters')
    .optional(),
  price3Months: z.number()
    .positive('3-month price must be positive')
    .max(99999.99, 'Price too high')
    .transform(val => Number(val.toFixed(2)))
    .optional(),
  price6Months: z.number()
    .positive('6-month price must be positive')
    .max(99999.99, 'Price too high')
    .transform(val => Number(val.toFixed(2)))
    .optional(),
  price12Months: z.number()
    .positive('12-month price must be positive')
    .max(99999.99, 'Price too high')
    .transform(val => Number(val.toFixed(2)))
    .optional(),
  credits3Months: z.number()
    .int('Credits must be whole numbers')
    .min(0, 'Credits cannot be negative')
    .max(1000, 'Credits too high')
    .optional(),
  credits6Months: z.number()
    .int('Credits must be whole numbers')
    .min(0, 'Credits cannot be negative')
    .max(1000, 'Credits too high')
    .optional(),
  credits12Months: z.number()
    .int('Credits must be whole numbers')
    .min(0, 'Credits cannot be negative')
    .max(1000, 'Credits too high')
    .optional(),
  isPublished: z.boolean().optional()
})

// URL Params Schemas
export const courseParamsSchema = z.object({
  id: z.string().uuid('Invalid course ID')
})

export const courseExamParamsSchema = z.object({
  examId: z.string().uuid('Invalid exam ID')
})

export const courseInstructorParamsSchema = z.object({
  instructorId: z.string().uuid('Invalid instructor ID')
})

// Response Schema
export const courseResponseSchema = z.object({
  id: z.string(),
  examId: z.string(),
  instructorId: z.string(),
  title: z.string(),
  description: z.string().nullable(),
  style: CourseStyleEnum,
  price3Months: z.number(),
  price6Months: z.number(),
  price12Months: z.number(),
  credits3Months: z.number(),
  credits6Months: z.number(),
  credits12Months: z.number(),
  isPublished: z.boolean(),
  createdAt: z.date(),
  updatedAt: z.date(),
  exam: z.object({
    id: z.string(),
    title: z.string(),
    slug: z.string(),
    isActive: z.boolean()
  }),
  instructor: z.object({
    id: z.string(),
    firstName: z.string(),
    lastName: z.string(),
    bio: z.string().nullable()
  })
})

// Type exports
export type CreateCourseInput = z.infer<typeof createCourseSchema>
export type UpdateCourseInput = z.infer<typeof updateCourseSchema>
export type CourseParams = z.infer<typeof courseParamsSchema>
export type CourseExamParams = z.infer<typeof courseExamParamsSchema>
export type CourseInstructorParams = z.infer<typeof courseInstructorParamsSchema>
export type CourseResponse = z.infer<typeof courseResponseSchema>
export type CourseStyle = z.infer<typeof CourseStyleEnum>


================================================
File: src/entities/course/course.service.ts
================================================
import { PrismaClient } from '@prisma/client'
import { CreateCourseInput, UpdateCourseInput, CourseStyle } from './course.schema'

export class CourseService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateCourseInput) {
    // Verify the instructor exists
    const instructor = await this.prisma.instructor.findUnique({
      where: { id: data.instructorId }
    })

    if (!instructor) {
      throw new Error('Instructor not found')
    }

    // Verify the exam exists and belongs to the instructor
    const exam = await this.prisma.exam.findUnique({
      where: { id: data.examId }
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    if (exam.instructorId !== data.instructorId) {
      throw new Error('Instructor can only create courses for their own exams')
    }

    return await this.prisma.course.create({
      data: {
        examId: data.examId,
        instructorId: data.instructorId,
        title: data.title,
        description: data.description,
        style: data.style,
        price3Months: data.price3Months,
        price6Months: data.price6Months,
        price12Months: data.price12Months,
        credits3Months: data.credits3Months,
        credits6Months: data.credits6Months,
        credits12Months: data.credits12Months,
        isPublished: data.isPublished ?? false
      },
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })
  }

  async findAll() {
    return await this.prisma.course.findMany({
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async findPublished() {
    return await this.prisma.course.findMany({
      where: { 
        isPublished: true,
        exam: { isActive: true } // Only show courses for active exams
      },
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      },
      orderBy: {
        title: 'asc'
      }
    })
  }

  async findByStyle(style: CourseStyle) {
    return await this.prisma.course.findMany({
      where: { 
        style,
        isPublished: true,
        exam: { isActive: true }
      },
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      },
      orderBy: {
        title: 'asc'
      }
    })
  }

  async findById(id: string) {
    const course = await this.prisma.course.findUnique({
      where: { id },
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })

    if (!course) {
      throw new Error('Course not found')
    }

    return course
  }

  async findByExam(examId: string) {
    // Verify exam exists
    const exam = await this.prisma.exam.findUnique({
      where: { id: examId }
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    return await this.prisma.course.findMany({
      where: { examId },
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async findByInstructor(instructorId: string) {
    // Verify instructor exists
    const instructor = await this.prisma.instructor.findUnique({
      where: { id: instructorId }
    })

    if (!instructor) {
      throw new Error('Instructor not found')
    }

    return await this.prisma.course.findMany({
      where: { instructorId },
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async update(id: string, data: UpdateCourseInput) {
    // Check if course exists
    const course = await this.findById(id)

    return await this.prisma.course.update({
      where: { id },
      data,
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })
  }

  async delete(id: string) {
    // Check if course exists
    await this.findById(id)

    return await this.prisma.course.delete({
      where: { id }
    })
  }

  async togglePublished(id: string) {
    const course = await this.findById(id)
    
    return await this.prisma.course.update({
      where: { id },
      data: { isPublished: !course.isPublished },
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })
  }

  // BUSINESS LOGIC METHODS

  async updatePricing(id: string, pricing: {
    price3Months?: number
    price6Months?: number
    price12Months?: number
  }) {
    const course = await this.findById(id)
    
    return await this.prisma.course.update({
      where: { id },
      data: pricing,
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })
  }

  async updateCredits(id: string, credits: {
    credits3Months?: number
    credits6Months?: number
    credits12Months?: number
  }) {
    const course = await this.findById(id)
    
    return await this.prisma.course.update({
      where: { id },
      data: credits,
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })
  }

  async getPricingInfo(id: string) {
    const course = await this.findById(id)
    
    return {
      courseId: course.id,
      title: course.title,
      pricing: {
        threeMonths: {
          price: course.price3Months,
          credits: course.credits3Months,
          pricePerMonth: Number((Number(course.price3Months) / 3).toFixed(2))
        },
        sixMonths: {
          price: course.price6Months,
          credits: course.credits6Months,
          pricePerMonth: Number((Number(course.price6Months) / 6).toFixed(2))
        },
        twelveMonths: {
          price: course.price12Months,
          credits: course.credits12Months,
          pricePerMonth: Number((Number(course.price12Months) / 12).toFixed(2))
        }
      }
    }
  }
}


================================================
File: src/entities/course-case/course-case.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { z } from 'zod'
import { CourseCaseService } from './course-case.service'
import { 
  createCourseCaseSchema, 
  updateCourseCaseSchema, 
  courseCaseParamsSchema,
  courseCaseCourseParamsSchema,
  reorderCourseCaseSchema,
  PatientGenderEnum
} from './course-case.schema'

import {
  assignSpecialtiesSchema,
  assignCurriculumsSchema,
  filterCasesSchema,
  bulkAssignFiltersSchema,
  removeSpecialtySchema,
  removeCurriculumSchema,
  courseCaseParamsSchema as junctionCourseCaseParamsSchema,
  courseParamsSchema,
  specialtyRemoveParamsSchema,
  curriculumRemoveParamsSchema,
  filterQuerySchema
} from '../../shared/junction-tables.schema'

// Additional schemas for query parameters
const genderParamsSchema = z.object({
  courseId: z.string().uuid('Invalid course ID'),
  gender: PatientGenderEnum
})

export default async function courseCaseRoutes(fastify: FastifyInstance) {
  const courseCaseService = new CourseCaseService(fastify.prisma)

  // GET /course-cases - Get all course cases
  fastify.get('/course-cases', async (request, reply) => {
    try {
      const courseCases = await courseCaseService.findAll()
      reply.send(courseCases)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch course cases' })
    }
  })

  // GET /course-cases/course/:courseId - Get cases by course
  fastify.get('/course-cases/course/:courseId', async (request, reply) => {
    try {
      const { courseId } = courseCaseCourseParamsSchema.parse(request.params)
      const courseCases = await courseCaseService.findByCourse(courseId)
      reply.send(courseCases)
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /course-cases/course/:courseId/free - Get free cases by course
  fastify.get('/course-cases/course/:courseId/free', async (request, reply) => {
    try {
      const { courseId } = courseCaseCourseParamsSchema.parse(request.params)
      const courseCases = await courseCaseService.findFreeCases(courseId)
      reply.send(courseCases)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /course-cases/course/:courseId/paid - Get paid cases by course
  fastify.get('/course-cases/course/:courseId/paid', async (request, reply) => {
    try {
      const { courseId } = courseCaseCourseParamsSchema.parse(request.params)
      const courseCases = await courseCaseService.findPaidCases(courseId)
      reply.send(courseCases)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /course-cases/course/:courseId/gender/:gender - Get cases by patient gender
  fastify.get('/course-cases/course/:courseId/gender/:gender', async (request, reply) => {
    try {
      const { courseId, gender } = genderParamsSchema.parse(request.params)
      const courseCases = await courseCaseService.findByGender(courseId, gender)
      reply.send(courseCases)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /course-cases/course/:courseId/stats - Get course case statistics
  fastify.get('/course-cases/course/:courseId/stats', async (request, reply) => {
    try {
      const { courseId } = courseCaseCourseParamsSchema.parse(request.params)
      const stats = await courseCaseService.getCaseStats(courseId)
      reply.send(stats)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /course-cases/course/:courseId/age-range - Get age range statistics
  fastify.get('/course-cases/course/:courseId/age-range', async (request, reply) => {
    try {
      const { courseId } = courseCaseCourseParamsSchema.parse(request.params)
      const ageRange = await courseCaseService.getAgeRange(courseId)
      reply.send(ageRange)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /course-cases/:id - Get course case by ID
  fastify.get('/course-cases/:id', async (request, reply) => {
    try {
      const { id } = courseCaseParamsSchema.parse(request.params)
      const courseCase = await courseCaseService.findById(id)
      reply.send(courseCase)
    } catch (error) {
      if (error instanceof Error && error.message === 'Course case not found') {
        reply.status(404).send({ error: 'Course case not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /course-cases - Create new course case
  fastify.post('/course-cases', async (request, reply) => {
    try {
      const data = createCourseCaseSchema.parse(request.body)
      const courseCase = await courseCaseService.create(data)
      reply.status(201).send(courseCase)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course not found') {
          reply.status(404).send({ error: 'Course not found' })
        } else if (error.message === 'Cases can only be added to RANDOM style courses') {
          reply.status(400).send({ error: 'Cases can only be added to RANDOM style courses' })
        } else if (error.message.includes('Display order') && error.message.includes('already taken')) {
          reply.status(400).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PUT /course-cases/:id - Update course case
  fastify.put('/course-cases/:id', async (request, reply) => {
    try {
      const { id } = courseCaseParamsSchema.parse(request.params)
      const data = updateCourseCaseSchema.parse(request.body)
      const courseCase = await courseCaseService.update(id, data)
      reply.send(courseCase)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message.includes('Display order') && error.message.includes('already taken')) {
          reply.status(400).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PATCH /course-cases/:id/toggle-free - Toggle case free status
  fastify.patch('/course-cases/:id/toggle-free', async (request, reply) => {
    try {
      const { id } = courseCaseParamsSchema.parse(request.params)
      const courseCase = await courseCaseService.toggleFree(id)
      reply.send({
        message: `Case ${courseCase.isFree ? 'marked as free' : 'marked as paid'} successfully`,
        courseCase
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Course case not found') {
        reply.status(404).send({ error: 'Course case not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // PATCH /course-cases/:id/reorder - Reorder course case
  fastify.patch('/course-cases/:id/reorder', async (request, reply) => {
    try {
      const { id } = courseCaseParamsSchema.parse(request.params)
      const { newOrder } = reorderCourseCaseSchema.parse(request.body)
      const courseCase = await courseCaseService.reorder(id, newOrder)
      reply.send({
        message: `Case reordered to position ${newOrder} successfully`,
        courseCase
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message.includes('Display order') && error.message.includes('already taken')) {
          reply.status(400).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // DELETE /course-cases/:id - Delete course case
  fastify.delete('/course-cases/:id', async (request, reply) => {
    try {
      const { id } = courseCaseParamsSchema.parse(request.params)
      await courseCaseService.delete(id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'Course case not found') {
        reply.status(404).send({ error: 'Course case not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

    // GET /course-cases/course/:courseId/filtered - Get filtered cases
    fastify.get('/course-cases/course/:courseId/filtered', async (request, reply) => {
      try {
        const { courseId } = courseParamsSchema.parse(request.params)
        const filters = filterQuerySchema.parse(request.query)
        
        const courseCases = await courseCaseService.findByFilters(courseId, {
          specialtyIds: filters.specialtyIds,
          curriculumIds: filters.curriculumIds,
          isFree: filters.isFree,
          patientGender: filters.patientGender
        })
        
        reply.send(courseCases)
      } catch (error) {
        reply.status(400).send({ error: 'Invalid filter parameters' })
      }
    })
  
    // GET /course-cases/:courseCaseId/specialties - Get case specialties
    fastify.get('/course-cases/:courseCaseId/specialties', async (request, reply) => {
      try {
        const { courseCaseId } = junctionCourseCaseParamsSchema.parse(request.params)
        const specialties = await courseCaseService.getCaseSpecialties(courseCaseId)
        reply.send(specialties)
      } catch (error) {
        if (error instanceof Error && error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      }
    })
  
    // GET /course-cases/:courseCaseId/curriculums - Get case curriculum items
    fastify.get('/course-cases/:courseCaseId/curriculums', async (request, reply) => {
      try {
        const { courseCaseId } = junctionCourseCaseParamsSchema.parse(request.params)
        const curriculums = await courseCaseService.getCaseCurriculums(courseCaseId)
        reply.send(curriculums)
      } catch (error) {
        if (error instanceof Error && error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      }
    })
  
    // POST /course-cases/assign-specialties - Assign specialties to case
    fastify.post('/course-cases/assign-specialties', async (request, reply) => {
      try {
        const { courseCaseId, specialtyIds } = assignSpecialtiesSchema.parse(request.body)
        const result = await courseCaseService.assignSpecialties(courseCaseId, specialtyIds)
        reply.send({
          message: 'Specialties assigned successfully',
          assignments: result,
          courseCaseId,
          specialtiesCount: specialtyIds.length
        })
      } catch (error) {
        if (error instanceof Error) {
          if (error.message === 'Course case not found') {
            reply.status(404).send({ error: 'Course case not found' })
          } else if (error.message === 'One or more specialties not found') {
            reply.status(404).send({ error: 'One or more specialties not found' })
          } else {
            reply.status(400).send({ error: 'Invalid data' })
          }
        } else {
          reply.status(500).send({ error: 'Internal server error' })
        }
      }
    })
  
    // POST /course-cases/assign-curriculums - Assign curriculum items to case
    fastify.post('/course-cases/assign-curriculums', async (request, reply) => {
      try {
        const { courseCaseId, curriculumIds } = assignCurriculumsSchema.parse(request.body)
        const result = await courseCaseService.assignCurriculums(courseCaseId, curriculumIds)
        reply.send({
          message: 'Curriculum items assigned successfully',
          assignments: result,
          courseCaseId,
          curriculumsCount: curriculumIds.length
        })
      } catch (error) {
        if (error instanceof Error) {
          if (error.message === 'Course case not found') {
            reply.status(404).send({ error: 'Course case not found' })
          } else if (error.message === 'One or more curriculum items not found') {
            reply.status(404).send({ error: 'One or more curriculum items not found' })
          } else {
            reply.status(400).send({ error: 'Invalid data' })
          }
        } else {
          reply.status(500).send({ error: 'Internal server error' })
        }
      }
    })
  
    // POST /course-cases/bulk-assign-filters - Bulk assign filters to multiple cases
    fastify.post('/course-cases/bulk-assign-filters', async (request, reply) => {
      try {
        const { assignments } = bulkAssignFiltersSchema.parse(request.body)
        const result = await courseCaseService.bulkAssignFilters(assignments)
        reply.send({
          message: 'Bulk assignment completed successfully',
          result,
          processedCases: assignments.length
        })
      } catch (error) {
        if (error instanceof Error) {
          reply.status(400).send({ error: error.message })
        } else {
          reply.status(500).send({ error: 'Internal server error' })
        }
      }
    })
  
    // DELETE /course-cases/:courseCaseId/specialties/:specialtyId - Remove specialty
    fastify.delete('/course-cases/:courseCaseId/specialties/:specialtyId', async (request, reply) => {
      try {
        const { courseCaseId, specialtyId } = specialtyRemoveParamsSchema.parse(request.params)
        const result = await courseCaseService.removeSpecialty(courseCaseId, specialtyId)
        reply.send(result)
      } catch (error) {
        if (error instanceof Error) {
          if (error.message === 'Course case not found') {
            reply.status(404).send({ error: 'Course case not found' })
          } else if (error.message === 'Specialty assignment not found') {
            reply.status(404).send({ error: 'Specialty assignment not found' })
          } else {
            reply.status(400).send({ error: 'Invalid request' })
          }
        } else {
          reply.status(500).send({ error: 'Internal server error' })
        }
      }
    })
  
    // DELETE /course-cases/:courseCaseId/curriculums/:curriculumId - Remove curriculum
    fastify.delete('/course-cases/:courseCaseId/curriculums/:curriculumId', async (request, reply) => {
      try {
        const { courseCaseId, curriculumId } = curriculumRemoveParamsSchema.parse(request.params)
        const result = await courseCaseService.removeCurriculum(courseCaseId, curriculumId)
        reply.send(result)
      } catch (error) {
        if (error instanceof Error) {
          if (error.message === 'Course case not found') {
            reply.status(404).send({ error: 'Course case not found' })
          } else if (error.message === 'Curriculum assignment not found') {
            reply.status(404).send({ error: 'Curriculum assignment not found' })
          } else {
            reply.status(400).send({ error: 'Invalid request' })
          }
        } else {
          reply.status(500).send({ error: 'Internal server error' })
        }
      }
    })
  
    // GET /course-cases/course/:courseId/filtering-stats - Get filtering statistics
    fastify.get('/course-cases/course/:courseId/filtering-stats', async (request, reply) => {
      try {
        const { courseId } = courseParamsSchema.parse(request.params)
        const stats = await courseCaseService.getFilteringStats(courseId)
        reply.send(stats)
      } catch (error) {
        reply.status(400).send({ error: 'Invalid request' })
      }
    })
  
    // Helper endpoint for available filters
    fastify.get('/course-cases/course/:courseId/available-filters', async (request, reply) => {
      try {
        const { courseId } = courseParamsSchema.parse(request.params)
        
        // Get all specialties and curriculums used in this course
        const courseCases = await courseCaseService.findByCourse(courseId)
        
        const uniqueSpecialties = new Set()
        const uniqueCurriculums = new Set()
        const availableGenders = new Set()
        
        courseCases.forEach((courseCase: any) => {
          // Add patient gender
          availableGenders.add(courseCase.patientGender)
          
          // Add specialties
          if (courseCase.caseSpecialties) {
            courseCase.caseSpecialties.forEach((cs: any) => {
              uniqueSpecialties.add(JSON.stringify({
                id: cs.specialty.id,
                name: cs.specialty.name
              }))
            })
          }
          
          // Add curriculums
          if (courseCase.caseCurriculums) {
            courseCase.caseCurriculums.forEach((cc: any) => {
              uniqueCurriculums.add(JSON.stringify({
                id: cc.curriculum.id,
                name: cc.curriculum.name
              }))
            })
          }
        })
        
        reply.send({
          courseId,
          availableFilters: {
            specialties: Array.from(uniqueSpecialties).map((s: any) => JSON.parse(s)),
            curriculums: Array.from(uniqueCurriculums).map((c: any) => JSON.parse(c)),
            genders: Array.from(availableGenders),
            freeOptions: [true, false]
          }
        })
      } catch (error) {
        reply.status(400).send({ error: 'Invalid request' })
      }
    })
}


================================================
File: src/entities/course-case/course-case.schema.ts
================================================
import { z } from 'zod'

// PatientGender enum
export const PatientGenderEnum = z.enum(['MALE', 'FEMALE', 'OTHER'])

// Create CourseCase Schema
export const createCourseCaseSchema = z.object({
  courseId: z.string().uuid('Invalid course ID'),
  title: z.string()
    .min(1, 'Title is required')
    .max(200, 'Title must be less than 200 characters')
    .trim(),
  diagnosis: z.string()
    .min(1, 'Diagnosis is required')
    .max(200, 'Diagnosis must be less than 200 characters')
    .trim(),
  patientName: z.string()
    .min(1, 'Patient name is required')
    .max(100, 'Patient name must be less than 100 characters')
    .trim(),
  patientAge: z.number()
    .int('Age must be a whole number')
    .min(0, 'Age cannot be negative')
    .max(150, 'Age must be realistic'),
  patientGender: PatientGenderEnum,
  description: z.string()
    .min(1, 'Description is required')
    .max(2000, 'Description must be less than 2000 characters')
    .trim(),
  isFree: z.boolean().default(false).optional(),
  displayOrder: z.number()
    .int('Display order must be a whole number')
    .min(1, 'Display order must be positive')
    .optional() // Will be auto-assigned if not provided
})

// Update CourseCase Schema
export const updateCourseCaseSchema = z.object({
  title: z.string()
    .min(1, 'Title is required')
    .max(200, 'Title must be less than 200 characters')
    .trim()
    .optional(),
  diagnosis: z.string()
    .min(1, 'Diagnosis is required')
    .max(200, 'Diagnosis must be less than 200 characters')
    .trim()
    .optional(),
  patientName: z.string()
    .min(1, 'Patient name is required')
    .max(100, 'Patient name must be less than 100 characters')
    .trim()
    .optional(),
  patientAge: z.number()
    .int('Age must be a whole number')
    .min(0, 'Age cannot be negative')
    .max(150, 'Age must be realistic')
    .optional(),
  patientGender: PatientGenderEnum.optional(),
  description: z.string()
    .min(1, 'Description is required')
    .max(2000, 'Description must be less than 2000 characters')
    .trim()
    .optional(),
  isFree: z.boolean().optional(),
  displayOrder: z.number()
    .int('Display order must be a whole number')
    .min(1, 'Display order must be positive')
    .optional()
})

// URL Params Schemas
export const courseCaseParamsSchema = z.object({
  id: z.string().uuid('Invalid course case ID')
})

export const courseCaseCourseParamsSchema = z.object({
  courseId: z.string().uuid('Invalid course ID')
})

// Reorder Schema
export const reorderCourseCaseSchema = z.object({
  newOrder: z.number()
    .int('Display order must be a whole number')
    .min(1, 'Display order must be positive')
})

// Response Schema
export const courseCaseResponseSchema = z.object({
  id: z.string(),
  courseId: z.string(),
  title: z.string(),
  diagnosis: z.string(),
  patientName: z.string(),
  patientAge: z.number(),
  patientGender: PatientGenderEnum,
  description: z.string(),
  isFree: z.boolean(),
  displayOrder: z.number(),
  createdAt: z.date(),
  updatedAt: z.date(),
  course: z.object({
    id: z.string(),
    title: z.string(),
    style: z.string(),
    isPublished: z.boolean(),
    exam: z.object({
      id: z.string(),
      title: z.string(),
      slug: z.string()
    })
  })
})

// Type exports
export type CreateCourseCaseInput = z.infer<typeof createCourseCaseSchema>
export type UpdateCourseCaseInput = z.infer<typeof updateCourseCaseSchema>
export type CourseCaseParams = z.infer<typeof courseCaseParamsSchema>
export type CourseCaseCourseParams = z.infer<typeof courseCaseCourseParamsSchema>
export type ReorderCourseCaseInput = z.infer<typeof reorderCourseCaseSchema>
export type CourseCaseResponse = z.infer<typeof courseCaseResponseSchema>
export type PatientGender = z.infer<typeof PatientGenderEnum>


================================================
File: src/entities/course-case/course-case.service.ts
================================================
// course-case.service.ts
import { PrismaClient, PatientGender } from '@prisma/client'
import { CreateCourseCaseInput, UpdateCourseCaseInput } from './course-case.schema'
import { any } from 'zod'

// Filter input interface
interface FilterInput {
  specialtyIds?: string[]
  curriculumIds?: string[]
  isFree?: boolean
  patientGender?: PatientGender
}

// Bulk assignment interface
interface BulkAssignmentInput {
  courseCaseId: string
  specialtyIds?: string[]
  curriculumIds?: string[]
}

export class CourseCaseService {
  constructor(private prisma: PrismaClient) {}

  // ===== BASIC CRUD OPERATIONS =====

  async create(data: CreateCourseCaseInput) {
    // Verify course exists and get course data
    const course = await this.prisma.course.findUnique({
      where: { id: data.courseId }
    })

    if (!course) {
      throw new Error('Course not found')
    }

    // Check if course style allows adding cases
    if (course.style !== 'RANDOM') {
      throw new Error('Cases can only be added to RANDOM style courses')
    }

    // Check if display order is already taken
    if (data.displayOrder) {
      const existingCase = await this.prisma.courseCase.findFirst({
        where: {
          courseId: data.courseId,
          displayOrder: data.displayOrder
        }
      })

      if (existingCase) {
        throw new Error(`Display order ${data.displayOrder} is already taken for this course`)
      }
    } else {
      // Auto-assign next display order
      const maxOrder = await this.prisma.courseCase.aggregate({
        where: { courseId: data.courseId },
        _max: { displayOrder: true }
      })
      data.displayOrder = (maxOrder._max.displayOrder || 0) + 1
    }

    return await this.prisma.courseCase.create({
      data: {
        courseId: data.courseId,
        title: data.title,
        diagnosis: data.diagnosis,
        patientName: data.patientName,
        patientAge: data.patientAge,
        patientGender: data.patientGender,
        description: data.description,
        isFree: data.isFree ?? false,
        displayOrder: data.displayOrder
      },
      include: {
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        }
      }
    })
  }

  async findAll() {
    return await this.prisma.courseCase.findMany({
      include: {
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        }
      },
      orderBy: [
        { courseId: 'asc' },
        { displayOrder: 'asc' }
      ]
    })
  }

  async findById(id: string) {
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id },
      include: {
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        },
        simulation: true,
        caseTabs: true,
        caseSpecialties: {
          include: {
            specialty: true
          }
        },
        caseCurriculums: {
          include: {
            curriculum: true
          }
        }
      }
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    return courseCase
  }

  async findByCourse(courseId: string) {
    // Verify course exists
    const course = await this.prisma.course.findUnique({
      where: { id: courseId }
    })

    if (!course) {
      throw new Error('Course not found')
    }

    return await this.prisma.courseCase.findMany({
      where: { courseId },
      include: {
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        },
        simulation: {
          select: {
            id: true,
            timeLimitMinutes: true,
            creditCost: true
          }
        },
        caseSpecialties: {
          include: {
            specialty: true
          }
        },
        caseCurriculums: {
          include: {
            curriculum: true
          }
        }
      },
      orderBy: {
        displayOrder: 'asc'
      }
    })
  }

  async findFreeCases(courseId: string) {
    return await this.prisma.courseCase.findMany({
      where: {
        courseId,
        isFree: true
      },
      include: {
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        }
      },
      orderBy: {
        displayOrder: 'asc'
      }
    })
  }

  async findPaidCases(courseId: string) {
    return await this.prisma.courseCase.findMany({
      where: {
        courseId,
        isFree: false
      },
      include: {
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        }
      },
      orderBy: {
        displayOrder: 'asc'
      }
    })
  }

  async findByGender(courseId: string, gender: PatientGender) {
    return await this.prisma.courseCase.findMany({
      where: {
        courseId,
        patientGender: gender
      },
      include: {
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        }
      },
      orderBy: {
        displayOrder: 'asc'
      }
    })
  }

  async update(id: string, data: UpdateCourseCaseInput) {
    // Check if course case exists
    const existingCase = await this.findById(id)

    // If updating display order, check it's not taken by another case
    if (data.displayOrder && data.displayOrder !== existingCase.displayOrder) {
      const conflictingCase = await this.prisma.courseCase.findFirst({
        where: {
          courseId: existingCase.courseId,
          displayOrder: data.displayOrder,
          id: { not: id }
        }
      })

      if (conflictingCase) {
        throw new Error(`Display order ${data.displayOrder} is already taken for this course`)
      }
    }

    return await this.prisma.courseCase.update({
      where: { id },
      data,
      include: {
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        }
      }
    })
  }

  async delete(id: string) {
    // Check if course case exists
    await this.findById(id)

    return await this.prisma.courseCase.delete({
      where: { id }
    })
  }

  async toggleFree(id: string) {
    const courseCase = await this.findById(id)
    
    return await this.prisma.courseCase.update({
      where: { id },
      data: { isFree: !courseCase.isFree },
      include: {
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        }
      }
    })
  }

  async reorder(id: string, newOrder: number) {
    const courseCase = await this.findById(id)

    // Check if new order is taken by another case
    const conflictingCase = await this.prisma.courseCase.findFirst({
      where: {
        courseId: courseCase.courseId,
        displayOrder: newOrder,
        id: { not: id }
      }
    })

    if (conflictingCase) {
      throw new Error(`Display order ${newOrder} is already taken for this course`)
    }

    return await this.prisma.courseCase.update({
      where: { id },
      data: { displayOrder: newOrder },
      include: {
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        }
      }
    })
  }

  // ===== STATISTICS & ANALYTICS =====

  async getCaseStats(courseId: string) {
    const totalCases = await this.prisma.courseCase.count({
      where: { courseId }
    })

    const freeCases = await this.prisma.courseCase.count({
      where: { courseId, isFree: true }
    })

    const paidCases = await this.prisma.courseCase.count({
      where: { courseId, isFree: false }
    })

    const genderDistribution = await this.prisma.courseCase.groupBy({
      by: ['patientGender'],
      where: { courseId },
      _count: {
        patientGender: true
      }
    })

    const casesWithSimulations = await this.prisma.courseCase.count({
      where: {
        courseId,
        simulation: {
          isNot: null
        }
      }
    })

    return {
      courseId,
      totalCases,
      freeCases,
      paidCases,
      casesWithSimulations,
      genderDistribution: genderDistribution.map((item: { patientGender: PatientGender; _count: { patientGender: number } }) => ({
        gender: item.patientGender,
        count: item._count.patientGender
      }))
    }
  }

  async getAgeRange(courseId: string) {
    const ageStats = await this.prisma.courseCase.aggregate({
      where: { courseId },
      _min: { patientAge: true },
      _max: { patientAge: true },
      _avg: { patientAge: true }
    })

    return {
      courseId,
      minAge: ageStats._min.patientAge,
      maxAge: ageStats._max.patientAge,
      avgAge: ageStats._avg.patientAge ? Math.round(ageStats._avg.patientAge * 10) / 10 : null
    }
  }

  // ===== JUNCTION TABLE OPERATIONS (User Stories #4, #42, #43) =====

  // Filter cases by specialties, curriculums, gender, and free status (User Story #4)
  async findByFilters(courseId: string, filters: FilterInput) {
    // Verify course exists
    const course = await this.prisma.course.findUnique({
      where: { id: courseId }
    })

    if (!course) {
      throw new Error('Course not found')
    }

    // Build the filter conditions
    const whereConditions: any = {
      courseId: courseId
    }

    // Add gender filter
    if (filters.patientGender) {
      whereConditions.patientGender = filters.patientGender
    }

    // Add free status filter
    if (filters.isFree !== undefined) {
      whereConditions.isFree = filters.isFree
    }

    // Add specialty filter (cases that have ALL specified specialties)
    if (filters.specialtyIds && filters.specialtyIds.length > 0) {
      whereConditions.caseSpecialties = {
        some: {
          specialtyId: { in: filters.specialtyIds }
        }
      }
    }

    // Add curriculum filter (cases that have ALL specified curriculums)
    if (filters.curriculumIds && filters.curriculumIds.length > 0) {
      whereConditions.caseCurriculums = {
        some: {
          curriculumId: { in: filters.curriculumIds }
        }
      }
    }

    const cases = await this.prisma.courseCase.findMany({
      where: whereConditions,
      include: {
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        },
        caseSpecialties: {
          include: {
            specialty: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },
        caseCurriculums: {
          include: {
            curriculum: {
              select: {
                id: true,
                name: true
              }
            }
          }
        }
      },
      orderBy: {
        displayOrder: 'asc'
      }
    })

    // Transform the response to include specialties and curriculums directly
    return cases.map((caseItem: any) => ({
      id: caseItem.id,
      courseId: caseItem.courseId,
      title: caseItem.title,
      diagnosis: caseItem.diagnosis,
      patientName: caseItem.patientName,
      patientAge: caseItem.patientAge,
      patientGender: caseItem.patientGender,
      description: caseItem.description,
      isFree: caseItem.isFree,
      displayOrder: caseItem.displayOrder,
      createdAt: caseItem.createdAt,
      updatedAt: caseItem.updatedAt,
      specialties: caseItem.caseSpecialties.map((cs: any) => cs.specialty),
      curriculums: caseItem.caseCurriculums.map((cc: any) => cc.curriculum),
      course: caseItem.course
    }))
  }

  // Assign specialties to a course case (User Story #42)
  async assignSpecialties(courseCaseId: string, specialtyIds: string[]) {
    // Verify course case exists
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id: courseCaseId }
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    // Verify all specialties exist
    const specialties = await this.prisma.specialty.findMany({
      where: { id: { in: specialtyIds } }
    })

    if (specialties.length !== specialtyIds.length) {
      throw new Error('One or more specialties not found')
    }

    // Remove existing assignments
    await this.prisma.caseSpecialty.deleteMany({
      where: { courseCaseId }
    })

    // Create new assignments
    const assignments = await this.prisma.caseSpecialty.createMany({
      data: specialtyIds.map((specialtyId: string) => ({
        courseCaseId,
        specialtyId
      }))
    })

    return assignments
  }

  // Assign curriculum items to a course case (User Story #43)
  async assignCurriculums(courseCaseId: string, curriculumIds: string[]) {
    // Verify course case exists
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id: courseCaseId }
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    // Verify all curriculum items exist
    const curriculums = await this.prisma.curriculum.findMany({
      where: { id: { in: curriculumIds } }
    })

    if (curriculums.length !== curriculumIds.length) {
      throw new Error('One or more curriculum items not found')
    }

    // Remove existing assignments
    await this.prisma.caseCurriculum.deleteMany({
      where: { courseCaseId }
    })

    // Create new assignments
    const assignments = await this.prisma.caseCurriculum.createMany({
      data: curriculumIds.map((curriculumId: string) => ({
        courseCaseId,
        curriculumId
      }))
    })

    return assignments
  }

  // Bulk assign filters to multiple course cases
  async bulkAssignFilters(assignments: BulkAssignmentInput[]) {
    const results = []

    for (const assignment of assignments) {
      const operations = []

      if (assignment.specialtyIds && assignment.specialtyIds.length > 0) {
        operations.push(
          this.assignSpecialties(assignment.courseCaseId, assignment.specialtyIds)
        )
      }

      if (assignment.curriculumIds && assignment.curriculumIds.length > 0) {
        operations.push(
          this.assignCurriculums(assignment.courseCaseId, assignment.curriculumIds)
        )
      }

      if (operations.length > 0) {
        await Promise.all(operations)
        results.push({
          courseCaseId: assignment.courseCaseId,
          specialtiesAssigned: assignment.specialtyIds?.length || 0,
          curriculumsAssigned: assignment.curriculumIds?.length || 0
        })
      }
    }

    return results
  }

  // ===== RETRIEVAL OPERATIONS =====

  // Get specialties assigned to a course case
  async getCaseSpecialties(courseCaseId: string) {
    // Verify course case exists
    await this.findById(courseCaseId)

    const caseSpecialties = await this.prisma.caseSpecialty.findMany({
      where: { courseCaseId },
      include: {
        specialty: true
      }
    })

    return caseSpecialties.map((cs:any) => cs.specialty)
  }

  // Get curriculum items assigned to a course case
  async getCaseCurriculums(courseCaseId: string) {
    // Verify course case exists
    await this.findById(courseCaseId)

    const caseCurriculums = await this.prisma.caseCurriculum.findMany({
      where: { courseCaseId },
      include: {
        curriculum: true
      }
    })

    return caseCurriculums.map((cc: any) => cc.curriculum)
  }

  // ===== REMOVAL OPERATIONS =====

  // Remove specialty from course case
  async removeSpecialty(courseCaseId: string, specialtyId: string) {
    // Verify course case exists
    await this.findById(courseCaseId)

    const deleted = await this.prisma.caseSpecialty.deleteMany({
      where: { courseCaseId, specialtyId }
    })

    if (deleted.count === 0) {
      throw new Error('Specialty assignment not found')
    }

    return { message: 'Specialty removed successfully' }
  }

  // Remove curriculum from course case
  async removeCurriculum(courseCaseId: string, curriculumId: string) {
    // Verify course case exists
    await this.findById(courseCaseId)

    const deleted = await this.prisma.caseCurriculum.deleteMany({
      where: { courseCaseId, curriculumId }
    })

    if (deleted.count === 0) {
      throw new Error('Curriculum assignment not found')
    }

    return { message: 'Curriculum removed successfully' }
  }

  // ===== FILTERING STATISTICS =====

  // Get filtering statistics for a course
  async getFilteringStats(courseId: string) {
    const totalCases = await this.prisma.courseCase.count({
      where: { courseId }
    })

    // Get specialty distribution
    const specialtyDistribution = await this.prisma.caseSpecialty.groupBy({
      by: ['specialtyId'],
      where: {
        courseCase: { courseId }
      },
      _count: {
        specialtyId: true
      }
    })

    // Get curriculum distribution
    const curriculumDistribution = await this.prisma.caseCurriculum.groupBy({
      by: ['curriculumId'],
      where: {
        courseCase: { courseId }
      },
      _count: {
        curriculumId: true
      }
    })

    // Enrich with specialty and curriculum details
    const enrichedSpecialtyDistribution = await Promise.all(
      specialtyDistribution.map(async (item: { specialtyId: string; _count: { specialtyId: number } }) => {
        const specialty = await this.prisma.specialty.findUnique({
          where: { id: item.specialtyId }
        })
        return {
          specialtyId: item.specialtyId,
          count: item._count.specialtyId,
          specialty: {
            id: specialty?.id || '',
            name: specialty?.name || ''
          }
        }
      })
    )

    const enrichedCurriculumDistribution = await Promise.all(
      curriculumDistribution.map(async (item: { curriculumId: string; _count: { curriculumId: number } }) => {
        const curriculum = await this.prisma.curriculum.findUnique({
          where: { id: item.curriculumId }
        })
        return {
          curriculumId: item.curriculumId,
          count: item._count.curriculumId,
          curriculum: {
            id: curriculum?.id || '',
            name: curriculum?.name || ''
          }
        }
      })
    )

    return {
      courseId,
      totalCases,
      specialtyDistribution: enrichedSpecialtyDistribution,
      curriculumDistribution: enrichedCurriculumDistribution
    }
  }
}


================================================
File: src/entities/curriculum/curriculum.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { CurriculumService } from './curriculum.service'
import { 
  createCurriculumSchema, 
  updateCurriculumSchema, 
  curriculumParamsSchema 
} from './curriculum.schema'

export default async function curriculumRoutes(fastify: FastifyInstance) {
  const curriculumService = new CurriculumService(fastify.prisma)

  // GET /curriculums - Get all curriculums
  fastify.get('/curriculums', async (request, reply) => {
    try {
      const curriculums = await curriculumService.findAll()
      reply.send(curriculums)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch curriculums' })
    }
  })

  // GET /curriculums/:id - Get curriculum by ID
  fastify.get('/curriculums/:id', async (request, reply) => {
    try {
      const { id } = curriculumParamsSchema.parse(request.params)
      const curriculum = await curriculumService.findById(id)
      reply.send(curriculum)
    } catch (error) {
      if (error instanceof Error && error.message === 'Curriculum not found') {
        reply.status(404).send({ error: 'Curriculum not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /curriculums - Create new curriculum
  fastify.post('/curriculums', async (request, reply) => {
    try {
      const data = createCurriculumSchema.parse(request.body)
      const curriculum = await curriculumService.create(data)
      reply.status(201).send(curriculum)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid data or curriculum already exists' })
    }
  })

  // PUT /curriculums/:id - Update curriculum
  fastify.put('/curriculums/:id', async (request, reply) => {
    try {
      const { id } = curriculumParamsSchema.parse(request.params)
      const data = updateCurriculumSchema.parse(request.body)
      const curriculum = await curriculumService.update(id, data)
      reply.send(curriculum)
    } catch (error) {
      if (error instanceof Error && error.message === 'Curriculum not found') {
        reply.status(404).send({ error: 'Curriculum not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // DELETE /curriculums/:id - Delete curriculum
  fastify.delete('/curriculums/:id', async (request, reply) => {
    try {
      const { id } = curriculumParamsSchema.parse(request.params)
      await curriculumService.delete(id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'Curriculum not found') {
        reply.status(404).send({ error: 'Curriculum not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })
}


================================================
File: src/entities/curriculum/curriculum.schema.ts
================================================
import { z } from 'zod'

// Create Curriculum Schema
export const createCurriculumSchema = z.object({
  name: z.string()
    .min(1, 'Name is required')
    .max(100, 'Name must be less than 100 characters')
    .trim()
})

// Update Curriculum Schema
export const updateCurriculumSchema = z.object({
  name: z.string()
    .min(1, 'Name is required')
    .max(100, 'Name must be less than 100 characters')
    .trim()
    .optional()
})

// URL Params Schema
export const curriculumParamsSchema = z.object({
  id: z.string().uuid('Invalid curriculum ID')
})

// Response Schema (what we send back)
export const curriculumResponseSchema = z.object({
  id: z.string(),
  name: z.string(),
  createdAt: z.date()
})

// Type exports for TypeScript
export type CreateCurriculumInput = z.infer<typeof createCurriculumSchema>
export type UpdateCurriculumInput = z.infer<typeof updateCurriculumSchema>
export type CurriculumParams = z.infer<typeof curriculumParamsSchema>
export type CurriculumResponse = z.infer<typeof curriculumResponseSchema>


================================================
File: src/entities/curriculum/curriculum.service.ts
================================================
import { PrismaClient } from '@prisma/client'
import { CreateCurriculumInput, UpdateCurriculumInput } from './curriculum.schema'

export class CurriculumService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateCurriculumInput) {
    return await this.prisma.curriculum.create({
      data: {
        name: data.name
      }
    })
  }

  async findAll() {
    return await this.prisma.curriculum.findMany({
      orderBy: {
        name: 'asc'
      }
    })
  }

  async findById(id: string) {
    const curriculum = await this.prisma.curriculum.findUnique({
      where: { id }
    })

    if (!curriculum) {
      throw new Error('Curriculum not found')
    }

    return curriculum
  }

  async update(id: string, data: UpdateCurriculumInput) {
    // Check if exists first
    await this.findById(id)

    return await this.prisma.curriculum.update({
      where: { id },
      data
    })
  }

  async delete(id: string) {
    // Check if exists first
    await this.findById(id)

    return await this.prisma.curriculum.delete({
      where: { id }
    })
  }
}


================================================
File: src/entities/exam/exam.routes.ts
================================================
// exam.routes.ts
import { FastifyInstance } from 'fastify'
import { ExamService } from './exam.service'
import { 
  createExamSchema, 
  updateExamSchema, 
  examParamsSchema,
  examInstructorParamsSchema
} from './exam.schema'
import {
  assignExamSpecialtiesSchema,
  assignExamCurriculumsSchema,
  assignExamMarkingDomainsSchema,
  bulkConfigureExamSchema,
  examRemoveSpecialtyParamsSchema,
  examRemoveCurriculumParamsSchema,
  examRemoveMarkingDomainParamsSchema
} from '../../shared/junction-tables.schema'
import { z } from 'zod'

// Additional schema for examId parameter routes
const examIdParamsSchema = z.object({
  examId: z.string().uuid('Invalid exam ID')
})

// Note: Using type assertions for request.params to resolve TypeScript 'unknown' type issues
// This is safe because Fastify will populate params according to route definitions

export default async function examRoutes(fastify: FastifyInstance) {
  const examService = new ExamService(fastify.prisma)

  // ===== BASIC EXAM CRUD OPERATIONS =====

  // GET /exams - Get all exams
  fastify.get('/exams', async (request, reply) => {
    try {
      const exams = await examService.findAll()
      reply.send(exams)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch exams' })
    }
  })

  // GET /exams/active - Get only active exams
  fastify.get('/exams/active', async (request, reply) => {
    try {
      const exams = await examService.findActive()
      reply.send(exams)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch active exams' })
    }
  })

  // GET /exams/instructor/:instructorId - Get exams by instructor
  fastify.get('/exams/instructor/:instructorId', async (request, reply) => {
    try {
      const { instructorId } = examInstructorParamsSchema.parse(request.params)
      const exams = await examService.findByInstructor(instructorId)
      reply.send(exams)
    } catch (error) {
      if (error instanceof Error && error.message === 'Instructor not found') {
        reply.status(404).send({ error: 'Instructor not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /exams/slug/:slug - Get exam by slug (SEO-friendly URLs)
  fastify.get('/exams/slug/:slug', async (request, reply) => {
    try {
      const { slug } = request.params as { slug: string }
      const exam = await examService.findBySlug(slug)
      reply.send(exam)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /exams/:id - Get exam by ID
  fastify.get('/exams/:id', async (request, reply) => {
    try {
      const { id } = examParamsSchema.parse(request.params)
      const exam = await examService.findById(id)
      reply.send(exam)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /exams - Create new exam
  fastify.post('/exams', async (request, reply) => {
    try {
      const data = createExamSchema.parse(request.body)
      const exam = await examService.create(data)
      reply.status(201).send(exam)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Instructor not found') {
          reply.status(404).send({ error: 'Instructor not found' })
        } else if (error.message === 'Exam with this slug already exists') {
          reply.status(400).send({ error: 'Exam with this slug already exists' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PUT /exams/:id - Update exam
  fastify.put('/exams/:id', async (request, reply) => {
    try {
      const { id } = examParamsSchema.parse(request.params)
      const data = updateExamSchema.parse(request.body)
      const exam = await examService.update(id, data)
      reply.send(exam)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message === 'Exam with this slug already exists') {
          reply.status(400).send({ error: 'Exam with this slug already exists' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PATCH /exams/:id/toggle - Toggle exam active status
  fastify.patch('/exams/:id/toggle', async (request, reply) => {
    try {
      const { id } = examParamsSchema.parse(request.params)
      const exam = await examService.toggleActive(id)
      reply.send({
        message: `Exam ${exam.isActive ? 'activated' : 'deactivated'} successfully`,
        exam
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // DELETE /exams/:id - Delete exam
  fastify.delete('/exams/:id', async (request, reply) => {
    try {
      const { id } = examParamsSchema.parse(request.params)
      await examService.delete(id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // ===== EXAM CONFIGURATION & JUNCTION TABLE OPERATIONS =====

  // GET /exams/:examId/configuration - Get complete exam configuration
  fastify.get('/exams/:examId/configuration', async (request, reply) => {
    try {
      // Alternative approach using dedicated schema validation
      const { examId } = examIdParamsSchema.parse(request.params)
      const configuration = await examService.getExamConfiguration(examId)
      reply.send(configuration)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /exams/:examId/specialties - Get exam specialties
  fastify.get('/exams/:examId/specialties', async (request, reply) => {
    try {
      const { examId } = examIdParamsSchema.parse(request.params)
      const specialties = await examService.getExamSpecialties(examId)
      reply.send(specialties)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /exams/:examId/curriculums - Get exam curriculum items
  fastify.get('/exams/:examId/curriculums', async (request, reply) => {
    try {
      const { examId } = examIdParamsSchema.parse(request.params)
      const curriculums = await examService.getExamCurriculums(examId)
      reply.send(curriculums)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /exams/:examId/marking-domains - Get exam marking domains
  fastify.get('/exams/:examId/marking-domains', async (request, reply) => {
    try {
      const { examId } = examIdParamsSchema.parse(request.params)
      const markingDomains = await examService.getExamMarkingDomains(examId)
      reply.send(markingDomains)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /exams/:examId/usage-stats - Get exam usage statistics
  fastify.get('/exams/:examId/usage-stats', async (request, reply) => {
    try {
      const { examId } = examIdParamsSchema.parse(request.params)
      const stats = await examService.getExamUsageStats(examId)
      reply.send(stats)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // ===== ASSIGNMENT OPERATIONS =====

  // POST /exams/assign-specialties - Assign specialties to exam
  fastify.post('/exams/assign-specialties', async (request, reply) => {
    try {
      const { examId, specialtyIds } = assignExamSpecialtiesSchema.parse(request.body)
      const result = await examService.assignSpecialties(examId, specialtyIds)
      reply.send({
        message: 'Specialties assigned to exam successfully',
        assignments: result,
        examId,
        specialtiesCount: specialtyIds.length
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message === 'One or more specialties not found') {
          reply.status(404).send({ error: 'One or more specialties not found' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /exams/assign-curriculums - Assign curriculum items to exam
  fastify.post('/exams/assign-curriculums', async (request, reply) => {
    try {
      const { examId, curriculumIds } = assignExamCurriculumsSchema.parse(request.body)
      const result = await examService.assignCurriculums(examId, curriculumIds)
      reply.send({
        message: 'Curriculum items assigned to exam successfully',
        assignments: result,
        examId,
        curriculumsCount: curriculumIds.length
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message === 'One or more curriculum items not found') {
          reply.status(404).send({ error: 'One or more curriculum items not found' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /exams/assign-marking-domains - Assign marking domains to exam
  fastify.post('/exams/assign-marking-domains', async (request, reply) => {
    try {
      const { examId, markingDomainIds } = assignExamMarkingDomainsSchema.parse(request.body)
      const result = await examService.assignMarkingDomains(examId, markingDomainIds)
      reply.send({
        message: 'Marking domains assigned to exam successfully',
        assignments: result,
        examId,
        markingDomainsCount: markingDomainIds.length
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message === 'One or more marking domains not found') {
          reply.status(404).send({ error: 'One or more marking domains not found' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /exams/bulk-configure - Configure exam with all assignments at once
  fastify.post('/exams/bulk-configure', async (request, reply) => {
    try {
      const { examId, ...configuration } = bulkConfigureExamSchema.parse(request.body)
      const result = await examService.bulkConfigureExam(examId, configuration)
      reply.send(result)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message.includes('not found')) {
          reply.status(404).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // ===== REMOVAL OPERATIONS =====

  // DELETE /exams/:examId/specialties/:specialtyId - Remove specialty from exam
  fastify.delete('/exams/:examId/specialties/:specialtyId', async (request, reply) => {
    try {
      const { examId, specialtyId } = examRemoveSpecialtyParamsSchema.parse(request.params)
      const result = await examService.removeSpecialty(examId, specialtyId)
      reply.send(result)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message === 'Specialty assignment not found') {
          reply.status(404).send({ error: 'Specialty assignment not found' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // DELETE /exams/:examId/curriculums/:curriculumId - Remove curriculum from exam
  fastify.delete('/exams/:examId/curriculums/:curriculumId', async (request, reply) => {
    try {
      const { examId, curriculumId } = examRemoveCurriculumParamsSchema.parse(request.params)
      const result = await examService.removeCurriculum(examId, curriculumId)
      reply.send(result)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message === 'Curriculum assignment not found') {
          reply.status(404).send({ error: 'Curriculum assignment not found' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // DELETE /exams/:examId/marking-domains/:markingDomainId - Remove marking domain from exam
  fastify.delete('/exams/:examId/marking-domains/:markingDomainId', async (request, reply) => {
    try {
      const { examId, markingDomainId } = examRemoveMarkingDomainParamsSchema.parse(request.params)
      const result = await examService.removeMarkingDomain(examId, markingDomainId)
      reply.send(result)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message === 'Marking domain assignment not found') {
          reply.status(404).send({ error: 'Marking domain assignment not found' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // ===== ADDITIONAL UTILITY ROUTES =====

  // GET /exams/:examId/with-configuration - Get exam with all configuration details
  fastify.get('/exams/:examId/with-configuration', async (request, reply) => {
    try {
      const { examId } = examIdParamsSchema.parse(request.params)
      const examWithConfig = await examService.getExamWithConfiguration(examId)
      reply.send(examWithConfig)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /exams/:examId/clear-configuration - Clear all exam configurations
  fastify.post('/exams/:examId/clear-configuration', async (request, reply) => {
    try {
      const { examId } = examIdParamsSchema.parse(request.params)
      const result = await examService.clearExamConfiguration(examId)
      reply.send(result)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /exams/:examId/is-configured - Check if exam is fully configured
  fastify.get('/exams/:examId/is-configured', async (request, reply) => {
    try {
      const { examId } = examIdParamsSchema.parse(request.params)
      const isConfigured = await examService.isExamFullyConfigured(examId)
      reply.send({ 
        examId, 
        isFullyConfigured: isConfigured 
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })
}


================================================
File: src/entities/exam/exam.schema.ts
================================================
import { z } from 'zod'

// Helper function to generate slug from title
const generateSlug = (title: string): string => {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
}

// Create Exam Schema
export const createExamSchema = z.object({
  instructorId: z.string().uuid('Invalid instructor ID'),
  title: z.string()
    .min(1, 'Title is required')
    .max(200, 'Title must be less than 200 characters')
    .trim(),
  slug: z.string()
    .min(1, 'Slug is required')
    .max(200, 'Slug must be less than 200 characters')
    .regex(/^[a-z0-9-]+$/, 'Slug must contain only lowercase letters, numbers, and hyphens')
    .optional(),
  description: z.string()
    .max(1000, 'Description must be less than 1000 characters')
    .optional(),
  isActive: z.boolean().default(true).optional()
}).transform((data) => ({
  ...data,
  // Auto-generate slug from title if not provided
  slug: data.slug || generateSlug(data.title)
}))

// Update Exam Schema
export const updateExamSchema = z.object({
  title: z.string()
    .min(1, 'Title is required')
    .max(200, 'Title must be less than 200 characters')
    .trim()
    .optional(),
  slug: z.string()
    .min(1, 'Slug is required')
    .max(200, 'Slug must be less than 200 characters')
    .regex(/^[a-z0-9-]+$/, 'Slug must contain only lowercase letters, numbers, and hyphens')
    .optional(),
  description: z.string()
    .max(1000, 'Description must be less than 1000 characters')
    .optional(),
  isActive: z.boolean().optional()
})

// URL Params Schema
export const examParamsSchema = z.object({
  id: z.string().uuid('Invalid exam ID')
})

// Instructor Params Schema (for instructor-specific queries)
export const examInstructorParamsSchema = z.object({
  instructorId: z.string().uuid('Invalid instructor ID')
})

// Response Schema
export const examResponseSchema = z.object({
  id: z.string(),
  instructorId: z.string(),
  title: z.string(),
  slug: z.string(),
  description: z.string().nullable(),
  isActive: z.boolean(),
  createdAt: z.date(),
  updatedAt: z.date(),
  instructor: z.object({
    id: z.string(),
    firstName: z.string(),
    lastName: z.string(),
    bio: z.string().nullable()
  })
})

// Type exports
export type CreateExamInput = z.infer<typeof createExamSchema>
export type UpdateExamInput = z.infer<typeof updateExamSchema>
export type ExamParams = z.infer<typeof examParamsSchema>
export type ExamInstructorParams = z.infer<typeof examInstructorParamsSchema>
export type ExamResponse = z.infer<typeof examResponseSchema>


================================================
File: src/entities/exam/exam.service.ts
================================================
// exam.service.ts
import { PrismaClient } from '@prisma/client'
import { CreateExamInput, UpdateExamInput } from './exam.schema'

export class ExamService {
  constructor(private prisma: PrismaClient) {}

  // ===== BASIC EXAM CRUD OPERATIONS =====

  async create(data: CreateExamInput) {
    // First, verify the instructor exists
    const instructor = await this.prisma.instructor.findUnique({
      where: { id: data.instructorId }
    })

    if (!instructor) {
      throw new Error('Instructor not found')
    }

    // Check if slug already exists
    const existingExam = await this.prisma.exam.findUnique({
      where: { slug: data.slug }
    })

    if (existingExam) {
      throw new Error('Exam with this slug already exists')
    }

    return await this.prisma.exam.create({
      data: {
        instructorId: data.instructorId,
        title: data.title,
        slug: data.slug,
        description: data.description,
        isActive: data.isActive ?? true
      },
      include: {
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })
  }

  async findAll() {
    return await this.prisma.exam.findMany({
      include: {
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async findActive() {
    return await this.prisma.exam.findMany({
      where: { isActive: true },
      include: {
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      },
      orderBy: {
        title: 'asc'
      }
    })
  }

  async findById(id: string) {
    const exam = await this.prisma.exam.findUnique({
      where: { id },
      include: {
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    return exam
  }

  async findBySlug(slug: string) {
    const exam = await this.prisma.exam.findUnique({
      where: { slug },
      include: {
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    return exam
  }

  async findByInstructor(instructorId: string) {
    // Verify instructor exists
    const instructor = await this.prisma.instructor.findUnique({
      where: { id: instructorId }
    })

    if (!instructor) {
      throw new Error('Instructor not found')
    }

    return await this.prisma.exam.findMany({
      where: { instructorId },
      include: {
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async update(id: string, data: UpdateExamInput) {
    // Check if exam exists
    await this.findById(id)

    // If updating slug, check it's unique
    if (data.slug) {
      const existingExam = await this.prisma.exam.findUnique({
        where: { slug: data.slug }
      })

      if (existingExam && existingExam.id !== id) {
        throw new Error('Exam with this slug already exists')
      }
    }

    return await this.prisma.exam.update({
      where: { id },
      data,
      include: {
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })
  }

  async delete(id: string) {
    // Check if exam exists
    await this.findById(id)

    return await this.prisma.exam.delete({
      where: { id }
    })
  }

  async toggleActive(id: string) {
    const exam = await this.findById(id)
    
    return await this.prisma.exam.update({
      where: { id },
      data: { isActive: !exam.isActive },
      include: {
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })
  }

  // ===== JUNCTION TABLE OPERATIONS =====

  // Assign specialties to an exam (User Story #36)
  async assignSpecialties(examId: string, specialtyIds: string[]) {
    // Verify exam exists
    await this.findById(examId)

    // Verify all specialties exist
    const specialties = await this.prisma.specialty.findMany({
      where: { id: { in: specialtyIds } }
    })

    if (specialties.length !== specialtyIds.length) {
      throw new Error('One or more specialties not found')
    }

    // Remove existing assignments to prevent duplicates
    await this.prisma.examSpecialty.deleteMany({
      where: { examId }
    })

    // Create new assignments
    const assignments = await this.prisma.examSpecialty.createMany({
      data: specialtyIds.map(specialtyId => ({
        examId,
        specialtyId
      }))
    })

    return assignments
  }

  // Assign curriculum items to an exam (User Story #37)
  async assignCurriculums(examId: string, curriculumIds: string[]) {
    // Verify exam exists
    await this.findById(examId)

    // Verify all curriculum items exist
    const curriculums = await this.prisma.curriculum.findMany({
      where: { id: { in: curriculumIds } }
    })

    if (curriculums.length !== curriculumIds.length) {
      throw new Error('One or more curriculum items not found')
    }

    // Remove existing assignments to prevent duplicates
    await this.prisma.examCurriculum.deleteMany({
      where: { examId }
    })

    // Create new assignments
    const assignments = await this.prisma.examCurriculum.createMany({
      data: curriculumIds.map(curriculumId => ({
        examId,
        curriculumId
      }))
    })

    return assignments
  }

  // Assign marking domains to an exam (User Story #38)
  async assignMarkingDomains(examId: string, markingDomainIds: string[]) {
    // Verify exam exists
    await this.findById(examId)

    // Verify all marking domains exist
    const markingDomains = await this.prisma.markingDomain.findMany({
      where: { id: { in: markingDomainIds } }
    })

    if (markingDomains.length !== markingDomainIds.length) {
      throw new Error('One or more marking domains not found')
    }

    // Remove existing assignments to prevent duplicates
    await this.prisma.examMarkingDomain.deleteMany({
      where: { examId }
    })

    // Create new assignments
    const assignments = await this.prisma.examMarkingDomain.createMany({
      data: markingDomainIds.map(markingDomainId => ({
        examId,
        markingDomainId
      }))
    })

    return assignments
  }

  // ===== RETRIEVAL OPERATIONS =====

  // Get specialties assigned to an exam
  async getExamSpecialties(examId: string) {
    // Verify exam exists
    await this.findById(examId)

    const examSpecialties = await this.prisma.examSpecialty.findMany({
      where: { examId },
      include: {
        specialty: true
      },
      orderBy: {
        specialty: {
          name: 'asc'
        }
      }
    })

    return examSpecialties.map(es => es.specialty)
  }

  // Get curriculum items assigned to an exam
  async getExamCurriculums(examId: string) {
    // Verify exam exists
    await this.findById(examId)

    const examCurriculums = await this.prisma.examCurriculum.findMany({
      where: { examId },
      include: {
        curriculum: true
      },
      orderBy: {
        curriculum: {
          name: 'asc'
        }
      }
    })

    return examCurriculums.map(ec => ec.curriculum)
  }

  // Get marking domains assigned to an exam
  async getExamMarkingDomains(examId: string) {
    // Verify exam exists
    await this.findById(examId)

    const examMarkingDomains = await this.prisma.examMarkingDomain.findMany({
      where: { examId },
      include: {
        markingDomain: true
      },
      orderBy: {
        markingDomain: {
          name: 'asc'
        }
      }
    })

    return examMarkingDomains.map(emd => emd.markingDomain)
  }

  // ===== REMOVAL OPERATIONS =====

  // Remove specialty from exam
  async removeSpecialty(examId: string, specialtyId: string) {
    // Verify exam exists
    await this.findById(examId)

    const deleted = await this.prisma.examSpecialty.deleteMany({
      where: { examId, specialtyId }
    })

    if (deleted.count === 0) {
      throw new Error('Specialty assignment not found')
    }

    return { message: 'Specialty removed successfully' }
  }

  // Remove curriculum from exam
  async removeCurriculum(examId: string, curriculumId: string) {
    // Verify exam exists
    await this.findById(examId)

    const deleted = await this.prisma.examCurriculum.deleteMany({
      where: { examId, curriculumId }
    })

    if (deleted.count === 0) {
      throw new Error('Curriculum assignment not found')
    }

    return { message: 'Curriculum removed successfully' }
  }

  // Remove marking domain from exam
  async removeMarkingDomain(examId: string, markingDomainId: string) {
    // Verify exam exists
    await this.findById(examId)

    const deleted = await this.prisma.examMarkingDomain.deleteMany({
      where: { examId, markingDomainId }
    })

    if (deleted.count === 0) {
      throw new Error('Marking domain assignment not found')
    }

    return { message: 'Marking domain removed successfully' }
  }

  // ===== CONFIGURATION & STATISTICS =====

  // Get exam configuration summary
  async getExamConfiguration(examId: string) {
    const exam = await this.findById(examId)
    
    const specialties = await this.getExamSpecialties(examId)
    const curriculums = await this.getExamCurriculums(examId)
    const markingDomains = await this.getExamMarkingDomains(examId)

    return {
      exam: {
        id: exam.id,
        title: exam.title,
        slug: exam.slug,
        description: exam.description,
        isActive: exam.isActive
      },
      configuration: {
        specialties: specialties,
        curriculums: curriculums,
        markingDomains: markingDomains
      },
      summary: {
        specialtiesCount: specialties.length,
        curriculumsCount: curriculums.length,
        markingDomainsCount: markingDomains.length,
        isFullyConfigured: specialties.length > 0 && curriculums.length > 0 && markingDomains.length > 0
      }
    }
  }

  // Bulk configure exam (assign all at once)
  async bulkConfigureExam(examId: string, configuration: {
    specialtyIds?: string[]
    curriculumIds?: string[]
    markingDomainIds?: string[]
  }) {
    // Verify exam exists
    await this.findById(examId)

    const operations = []

    if (configuration.specialtyIds && configuration.specialtyIds.length > 0) {
      operations.push(
        this.assignSpecialties(examId, configuration.specialtyIds)
      )
    }

    if (configuration.curriculumIds && configuration.curriculumIds.length > 0) {
      operations.push(
        this.assignCurriculums(examId, configuration.curriculumIds)
      )
    }

    if (configuration.markingDomainIds && configuration.markingDomainIds.length > 0) {
      operations.push(
        this.assignMarkingDomains(examId, configuration.markingDomainIds)
      )
    }

    if (operations.length > 0) {
      await Promise.all(operations)
    }

    return {
      message: 'Exam configuration completed successfully',
      examId,
      configured: {
        specialties: configuration.specialtyIds?.length || 0,
        curriculums: configuration.curriculumIds?.length || 0,
        markingDomains: configuration.markingDomainIds?.length || 0
      }
    }
  }

  // Get exam statistics (how many courses/cases use this exam configuration)
  async getExamUsageStats(examId: string) {
    const exam = await this.findById(examId)

    // Get usage counts
    const coursesCount = await this.prisma.course.count({
      where: { examId }
    })

    const casesCount = await this.prisma.courseCase.count({
      where: { course: { examId } }
    })

    const simulationsCount = await this.prisma.simulation.count({
      where: { courseCase: { course: { examId } } }
    })

    // Get configuration counts by querying junction tables directly
    const specialtiesCount = await this.prisma.examSpecialty.count({
      where: { examId }
    })

    const curriculumsCount = await this.prisma.examCurriculum.count({
      where: { examId }
    })

    const markingDomainsCount = await this.prisma.examMarkingDomain.count({
      where: { examId }
    })

    return {
      examId,
      examTitle: exam.title,
      usage: {
        coursesCount,
        casesCount,
        simulationsCount
      },
      configuration: {
        specialtiesCount,
        curriculumsCount,
        markingDomainsCount
      }
    }
  }

  // ===== ADDITIONAL UTILITY METHODS =====

  // Check if exam is fully configured
  async isExamFullyConfigured(examId: string): Promise<boolean> {
    const specialtiesCount = await this.prisma.examSpecialty.count({
      where: { examId }
    })

    const curriculumsCount = await this.prisma.examCurriculum.count({
      where: { examId }
    })

    const markingDomainsCount = await this.prisma.examMarkingDomain.count({
      where: { examId }
    })

    return specialtiesCount > 0 && curriculumsCount > 0 && markingDomainsCount > 0
  }

  // Get exam with all configuration details (including junction data)
  async getExamWithConfiguration(examId: string) {
    const exam = await this.prisma.exam.findUnique({
      where: { id: examId },
      include: {
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        },
        examSpecialties: {
          include: {
            specialty: true
          },
          orderBy: {
            specialty: {
              name: 'asc'
            }
          }
        },
        examCurriculums: {
          include: {
            curriculum: true
          },
          orderBy: {
            curriculum: {
              name: 'asc'
            }
          }
        },
        examMarkingDomains: {
          include: {
            markingDomain: true
          },
          orderBy: {
            markingDomain: {
              name: 'asc'
            }
          }
        }
      }
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    return {
      ...exam,
      specialties: exam.examSpecialties.map(es => es.specialty),
      curriculums: exam.examCurriculums.map(ec => ec.curriculum),
      markingDomains: exam.examMarkingDomains.map(emd => emd.markingDomain)
    }
  }

  // Clear all exam configurations
  async clearExamConfiguration(examId: string) {
    // Verify exam exists
    await this.findById(examId)

    await Promise.all([
      this.prisma.examSpecialty.deleteMany({ where: { examId } }),
      this.prisma.examCurriculum.deleteMany({ where: { examId } }),
      this.prisma.examMarkingDomain.deleteMany({ where: { examId } })
    ])

    return { message: 'Exam configuration cleared successfully' }
  }
}


================================================
File: src/entities/instructor/instructor.routes.ts
================================================
import { z } from 'zod'
import { FastifyInstance } from 'fastify'
import { InstructorService } from './instructor.service'
import { 
  createInstructorSchema, 
  updateInstructorSchema 
} from './instructor.schema'

// Updated params schema for userId (integer)
const instructorUserParamsSchema = z.object({
  userId: z.string().transform(val => parseInt(val)).refine(val => !isNaN(val), 'Invalid user ID')
})

export default async function instructorRoutes(fastify: FastifyInstance) {
  const instructorService = new InstructorService(fastify.prisma)

  // GET /instructors - Get all instructors
  fastify.get('/instructors', async (request, reply) => {
    try {
      const instructors = await instructorService.findAll()
      reply.send(instructors)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch instructors' })
    }
  })

  // GET /instructors/:userId - Get instructor by User ID
  fastify.get('/instructors/:userId', async (request, reply) => {
    try {
      const { userId } = instructorUserParamsSchema.parse(request.params)
      const instructor = await instructorService.findByUserId(userId)
      reply.send(instructor)
    } catch (error) {
      if (error instanceof Error && error.message === 'Instructor not found') {
        reply.status(404).send({ error: 'Instructor not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /instructors - Create new instructor (creates User + Instructor)
  fastify.post('/instructors', async (request, reply) => {
    try {
      const data = createInstructorSchema.parse(request.body)
      const instructor = await instructorService.create(data)
      reply.status(201).send(instructor)
    } catch (error) {
      if (error instanceof Error && error.message.includes('Unique constraint failed')) {
        reply.status(400).send({ error: 'Email already exists' })
      } else {
        reply.status(400).send({ error: 'Invalid data' })
      }
    }
  })

  // PUT /instructors/:userId - Update instructor by User ID
  fastify.put('/instructors/:userId', async (request, reply) => {
    try {
      const { userId } = instructorUserParamsSchema.parse(request.params)
      const data = updateInstructorSchema.parse(request.body)
      
      // Get instructor by userId first to get the UUID for update
      const existingInstructor = await instructorService.findByUserId(userId)
      const instructor = await instructorService.update(existingInstructor.id, data)
      reply.send(instructor)
    } catch (error) {
      if (error instanceof Error && error.message === 'Instructor not found') {
        reply.status(404).send({ error: 'Instructor not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // DELETE /instructors/:userId - Delete instructor by User ID
  fastify.delete('/instructors/:userId', async (request, reply) => {
    try {
      const { userId } = instructorUserParamsSchema.parse(request.params)
      
      // Get instructor by userId first to get the UUID for deletion
      const existingInstructor = await instructorService.findByUserId(userId)
      await instructorService.delete(existingInstructor.id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'Instructor not found') {
        reply.status(404).send({ error: 'Instructor not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })
}


================================================
File: src/entities/instructor/instructor.schema.ts
================================================
import { z } from 'zod'

// Create Instructor Schema (includes User data)
export const createInstructorSchema = z.object({
  // User fields
  email: z.string().email('Invalid email format'),
  name: z.string().optional(),
  
  // Instructor fields
  firstName: z.string()
    .min(1, 'First name is required')
    .max(50, 'First name must be less than 50 characters')
    .trim(),
  lastName: z.string()
    .min(1, 'Last name is required')
    .max(50, 'Last name must be less than 50 characters')
    .trim(),
  bio: z.string()
    .max(500, 'Bio must be less than 500 characters')
    .optional()
})

// Update Instructor Schema
export const updateInstructorSchema = z.object({
  firstName: z.string()
    .min(1, 'First name is required')
    .max(50, 'First name must be less than 50 characters')
    .trim()
    .optional(),
  lastName: z.string()
    .min(1, 'Last name is required')
    .max(50, 'Last name must be less than 50 characters')
    .trim()
    .optional(),
  bio: z.string()
    .max(500, 'Bio must be less than 500 characters')
    .optional()
})

// URL Params Schema
export const instructorParamsSchema = z.object({
  id: z.string().uuid('Invalid instructor ID')
})

// Response Schema
export const instructorResponseSchema = z.object({
  id: z.string(),
  userId: z.number(),
  firstName: z.string(),
  lastName: z.string(),
  bio: z.string().nullable(),
  createdAt: z.date(),
  updatedAt: z.date(),
  user: z.object({
    id: z.number(),
    email: z.string(),
    name: z.string().nullable()
  })
})

// Type exports
export type CreateInstructorInput = z.infer<typeof createInstructorSchema>
export type UpdateInstructorInput = z.infer<typeof updateInstructorSchema>
export type InstructorParams = z.infer<typeof instructorParamsSchema>
export type InstructorResponse = z.infer<typeof instructorResponseSchema>


================================================
File: src/entities/instructor/instructor.service.ts
================================================
import { PrismaClient, Prisma } from '@prisma/client'
import { CreateInstructorInput, UpdateInstructorInput } from './instructor.schema'

export class InstructorService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateInstructorInput) {
    // Create User and Instructor in a transaction
    return await this.prisma.$transaction(async (tx: Prisma.TransactionClient) => {
      // First, create the User
      const user = await tx.user.create({
        data: {
          email: data.email,
          name: data.name
        }
      })

      // Then, create the Instructor linked to the User
      const instructor = await tx.instructor.create({
        data: {
          userId: user.id,
          firstName: data.firstName,
          lastName: data.lastName,
          bio: data.bio
        },
        include: {
          user: true
        }
      })

      return instructor
    })
  }

  async findAll() {
    return await this.prisma.instructor.findMany({
      include: {
        user: true
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async findById(id: string) {
    const instructor = await this.prisma.instructor.findUnique({
      where: { id },
      include: {
        user: true
      }
    })

    if (!instructor) {
      throw new Error('Instructor not found')
    }

    return instructor
  }

  async findByUserId(userId: number) {
    const instructor = await this.prisma.instructor.findUnique({
      where: { userId },
      include: {
        user: true
      }
    })

    if (!instructor) {
      throw new Error('Instructor not found')
    }

    return instructor
  }

  async update(id: string, data: UpdateInstructorInput) {
    // Check if exists first
    await this.findById(id)

    return await this.prisma.instructor.update({
      where: { id },
      data,
      include: {
        user: true
      }
    })
  }

  async delete(id: string) {
    // Check if exists first
    const instructor = await this.findById(id)

    // Delete in transaction (Instructor first, then User)
    return await this.prisma.$transaction(async (tx: Prisma.TransactionClient) => {
      await tx.instructor.delete({
        where: { id }
      })

      await tx.user.delete({
        where: { id: instructor.userId }
      })
    })
  }
}


================================================
File: src/entities/marking-domain/marking-domain.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { MarkingDomainService } from './marking-domain.service'
import { 
  createMarkingDomainSchema, 
  updateMarkingDomainSchema, 
  markingDomainParamsSchema 
} from './marking-domain.schema'

export default async function markingDomainRoutes(fastify: FastifyInstance) {
  const markingDomainService = new MarkingDomainService(fastify.prisma)

  // GET /marking-domains - Get all marking domains
  fastify.get('/marking-domains', async (request, reply) => {
    try {
      const markingDomains = await markingDomainService.findAll()
      reply.send(markingDomains)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch marking domains' })
    }
  })

  // GET /marking-domains/:id - Get marking domain by ID
  fastify.get('/marking-domains/:id', async (request, reply) => {
    try {
      const { id } = markingDomainParamsSchema.parse(request.params)
      const markingDomain = await markingDomainService.findById(id)
      reply.send(markingDomain)
    } catch (error) {
      if (error instanceof Error && error.message === 'MarkingDomain not found') {
        reply.status(404).send({ error: 'MarkingDomain not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /marking-domains - Create new marking domain
  fastify.post('/marking-domains', async (request, reply) => {
    try {
      const data = createMarkingDomainSchema.parse(request.body)
      const markingDomain = await markingDomainService.create(data)
      reply.status(201).send(markingDomain)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid data or marking domain already exists' })
    }
  })

  // PUT /marking-domains/:id - Update marking domain
  fastify.put('/marking-domains/:id', async (request, reply) => {
    try {
      const { id } = markingDomainParamsSchema.parse(request.params)
      const data = updateMarkingDomainSchema.parse(request.body)
      const markingDomain = await markingDomainService.update(id, data)
      reply.send(markingDomain)
    } catch (error) {
      if (error instanceof Error && error.message === 'MarkingDomain not found') {
        reply.status(404).send({ error: 'MarkingDomain not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // DELETE /marking-domains/:id - Delete marking domain
  fastify.delete('/marking-domains/:id', async (request, reply) => {
    try {
      const { id } = markingDomainParamsSchema.parse(request.params)
      await markingDomainService.delete(id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'MarkingDomain not found') {
        reply.status(404).send({ error: 'MarkingDomain not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })
}


================================================
File: src/entities/marking-domain/marking-domain.schema.ts
================================================
import { z } from 'zod'

// Create MarkingDomain Schema
export const createMarkingDomainSchema = z.object({
  name: z.string()
    .min(1, 'Name is required')
    .max(100, 'Name must be less than 100 characters')
    .trim()
})

// Update MarkingDomain Schema
export const updateMarkingDomainSchema = z.object({
  name: z.string()
    .min(1, 'Name is required')
    .max(100, 'Name must be less than 100 characters')
    .trim()
    .optional()
})

// URL Params Schema
export const markingDomainParamsSchema = z.object({
  id: z.string().uuid('Invalid marking domain ID')
})

// Response Schema
export const markingDomainResponseSchema = z.object({
  id: z.string(),
  name: z.string(),
  createdAt: z.date()
})

// Type exports
export type CreateMarkingDomainInput = z.infer<typeof createMarkingDomainSchema>
export type UpdateMarkingDomainInput = z.infer<typeof updateMarkingDomainSchema>
export type MarkingDomainParams = z.infer<typeof markingDomainParamsSchema>
export type MarkingDomainResponse = z.infer<typeof markingDomainResponseSchema>


================================================
File: src/entities/marking-domain/marking-domain.service.ts
================================================
import { PrismaClient } from '@prisma/client'
import { CreateMarkingDomainInput, UpdateMarkingDomainInput } from './marking-domain.schema'

export class MarkingDomainService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateMarkingDomainInput) {
    return await this.prisma.markingDomain.create({
      data: {
        name: data.name
      }
    })
  }

  async findAll() {
    return await this.prisma.markingDomain.findMany({
      orderBy: {
        name: 'asc'
      }
    })
  }

  async findById(id: string) {
    const markingDomain = await this.prisma.markingDomain.findUnique({
      where: { id }
    })

    if (!markingDomain) {
      throw new Error('MarkingDomain not found')
    }

    return markingDomain
  }

  async update(id: string, data: UpdateMarkingDomainInput) {
    // Check if exists first
    await this.findById(id)

    return await this.prisma.markingDomain.update({
      where: { id },
      data
    })
  }

  async delete(id: string) {
    // Check if exists first
    await this.findById(id)

    return await this.prisma.markingDomain.delete({
      where: { id }
    })
  }
}


================================================
File: src/entities/simulation/simulation.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { z } from 'zod'
import { SimulationService } from './simulation.service'
import { 
  createSimulationSchema, 
  updateSimulationSchema, 
  simulationParamsSchema,
  simulationCourseCaseParamsSchema,
  VoiceModelEnum
} from './simulation.schema'

// Additional schemas for business operations
const creditCostUpdateSchema = z.object({
  creditCost: z.number().int().min(1).max(10)
})

const timeLimitUpdateSchema = z.object({
  timeLimitMinutes: z.number().int().min(1).max(120),
  warningTimeMinutes: z.number().int().min(1).optional()
})

const voiceModelParamsSchema = z.object({
  voiceModel: VoiceModelEnum
})

const creditCostParamsSchema = z.object({
  creditCost: z.string().transform(val => parseInt(val)).refine(val => val >= 1 && val <= 10, 'Invalid credit cost')
})

const courseIdParamsSchema = z.object({
  courseId: z.string().uuid('Invalid course ID')
})

export default async function simulationRoutes(fastify: FastifyInstance) {
  const simulationService = new SimulationService(fastify.prisma)

  // GET /simulations - Get all simulations
  fastify.get('/simulations', async (request, reply) => {
    try {
      const simulations = await simulationService.findAll()
      reply.send(simulations)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch simulations' })
    }
  })

  // GET /simulations/course-case/:courseCaseId - Get simulation by course case
  fastify.get('/simulations/course-case/:courseCaseId', async (request, reply) => {
    try {
      const { courseCaseId } = simulationCourseCaseParamsSchema.parse(request.params)
      const simulation = await simulationService.findByCourseCaseId(courseCaseId)
      reply.send(simulation)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message === 'No simulation configured for this course case') {
          reply.status(404).send({ error: 'No simulation configured for this course case' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // GET /simulations/course/:courseId - Get simulations by course
  fastify.get('/simulations/course/:courseId', async (request, reply) => {
    try {
      const { courseId } = courseIdParamsSchema.parse(request.params)
      const simulations = await simulationService.findByCourse(courseId)
      reply.send(simulations)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /simulations/voice-model/:voiceModel - Get simulations by voice model
  fastify.get('/simulations/voice-model/:voiceModel', async (request, reply) => {
    try {
      const { voiceModel } = voiceModelParamsSchema.parse(request.params)
      const simulations = await simulationService.findByVoiceModel(voiceModel)
      reply.send(simulations)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid voice model' })
    }
  })

  // GET /simulations/credit-cost/:creditCost - Get simulations by credit cost
  fastify.get('/simulations/credit-cost/:creditCost', async (request, reply) => {
    try {
      const { creditCost } = creditCostParamsSchema.parse(request.params)
      const simulations = await simulationService.findByCreditCost(creditCost)
      reply.send(simulations)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid credit cost' })
    }
  })

  // GET /simulations/stats - Get simulation statistics (all courses)
  fastify.get('/simulations/stats', async (request, reply) => {
    try {
      const stats = await simulationService.getSimulationStats()
      reply.send(stats)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch simulation statistics' })
    }
  })

  // GET /simulations/stats/course/:courseId - Get simulation statistics for specific course
  fastify.get('/simulations/stats/course/:courseId', async (request, reply) => {
    try {
      const { courseId } = courseIdParamsSchema.parse(request.params)
      const stats = await simulationService.getSimulationStats(courseId)
      reply.send(stats)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /simulations/:id - Get simulation by ID
  fastify.get('/simulations/:id', async (request, reply) => {
    try {
      const { id } = simulationParamsSchema.parse(request.params)
      const simulation = await simulationService.findById(id)
      reply.send(simulation)
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation not found') {
        reply.status(404).send({ error: 'Simulation not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /simulations - Create new simulation
  fastify.post('/simulations', async (request, reply) => {
    try {
      const data = createSimulationSchema.parse(request.body)
      const simulation = await simulationService.create(data)
      reply.status(201).send(simulation)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message === 'This course case already has a simulation configured') {
          reply.status(400).send({ error: 'This course case already has a simulation configured' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PUT /simulations/:id - Update simulation
  fastify.put('/simulations/:id', async (request, reply) => {
    try {
      const { id } = simulationParamsSchema.parse(request.params)
      const data = updateSimulationSchema.parse(request.body)
      const simulation = await simulationService.update(id, data)
      reply.send(simulation)
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation not found') {
        reply.status(404).send({ error: 'Simulation not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // PATCH /simulations/:id/credit-cost - Update simulation credit cost
  fastify.patch('/simulations/:id/credit-cost', async (request, reply) => {
    try {
      const { id } = simulationParamsSchema.parse(request.params)
      const { creditCost } = creditCostUpdateSchema.parse(request.body)
      const simulation = await simulationService.updateCreditCost(id, creditCost)
      reply.send({
        message: `Credit cost updated to ${creditCost} successfully`,
        simulation
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Simulation not found') {
          reply.status(404).send({ error: 'Simulation not found' })
        } else if (error.message.includes('Credit cost must be')) {
          reply.status(400).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PATCH /simulations/:id/time-limit - Update simulation time limit
  fastify.patch('/simulations/:id/time-limit', async (request, reply) => {
    try {
      const { id } = simulationParamsSchema.parse(request.params)
      const { timeLimitMinutes, warningTimeMinutes } = timeLimitUpdateSchema.parse(request.body)
      const simulation = await simulationService.updateTimeLimit(id, timeLimitMinutes, warningTimeMinutes)
      reply.send({
        message: `Time limit updated to ${timeLimitMinutes} minutes successfully`,
        simulation
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Simulation not found') {
          reply.status(404).send({ error: 'Simulation not found' })
        } else if (error.message.includes('Time limit must be') || error.message.includes('Warning time must be')) {
          reply.status(400).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // DELETE /simulations/:id - Delete simulation
  fastify.delete('/simulations/:id', async (request, reply) => {
    try {
      const { id } = simulationParamsSchema.parse(request.params)
      await simulationService.delete(id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Simulation not found') {
          reply.status(404).send({ error: 'Simulation not found' })
        } else if (error.message === 'Cannot delete simulation with existing student attempts') {
          reply.status(400).send({ error: 'Cannot delete simulation with existing student attempts' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })
}


================================================
File: src/entities/simulation/simulation.schema.ts
================================================
import { z } from 'zod'

// VoiceModel enum
export const VoiceModelEnum = z.enum(['VOICE_1', 'VOICE_2'])

// Create Simulation Schema
export const createSimulationSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  casePrompt: z.string()
    .min(10, 'Case prompt must be at least 10 characters')
    .max(2000, 'Case prompt must be less than 2000 characters')
    .trim(),
  openingLine: z.string()
    .min(5, 'Opening line must be at least 5 characters')
    .max(500, 'Opening line must be less than 500 characters')
    .trim(),
  timeLimitMinutes: z.number()
    .int('Time limit must be a whole number')
    .min(1, 'Time limit must be at least 1 minute')
    .max(120, 'Time limit cannot exceed 120 minutes'),
  voiceModel: VoiceModelEnum,
  warningTimeMinutes: z.number()
    .int('Warning time must be a whole number')
    .min(1, 'Warning time must be at least 1 minute')
    .optional(),
  creditCost: z.number()
    .int('Credit cost must be a whole number')
    .min(1, 'Credit cost must be at least 1')
    .max(10, 'Credit cost cannot exceed 10')
    .default(1)
}).refine((data) => {
  // Business rule: Warning time should be less than total time limit
  if (data.warningTimeMinutes && data.warningTimeMinutes >= data.timeLimitMinutes) {
    return false
  }
  return true
}, {
  message: 'Warning time must be less than time limit',
  path: ['warningTimeMinutes']
})

// Update Simulation Schema
export const updateSimulationSchema = z.object({
  casePrompt: z.string()
    .min(10, 'Case prompt must be at least 10 characters')
    .max(2000, 'Case prompt must be less than 2000 characters')
    .trim()
    .optional(),
  openingLine: z.string()
    .min(5, 'Opening line must be at least 5 characters')
    .max(500, 'Opening line must be less than 500 characters')
    .trim()
    .optional(),
  timeLimitMinutes: z.number()
    .int('Time limit must be a whole number')
    .min(1, 'Time limit must be at least 1 minute')
    .max(120, 'Time limit cannot exceed 120 minutes')
    .optional(),
  voiceModel: VoiceModelEnum.optional(),
  warningTimeMinutes: z.number()
    .int('Warning time must be a whole number')
    .min(1, 'Warning time must be at least 1 minute')
    .optional(),
  creditCost: z.number()
    .int('Credit cost must be a whole number')
    .min(1, 'Credit cost must be at least 1')
    .max(10, 'Credit cost cannot exceed 10')
    .optional()
})

// URL Params Schemas
export const simulationParamsSchema = z.object({
  id: z.string().uuid('Invalid simulation ID')
})

export const simulationCourseCaseParamsSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID')
})

// Response Schema
export const simulationResponseSchema = z.object({
  id: z.string(),
  courseCaseId: z.string(),
  casePrompt: z.string(),
  openingLine: z.string(),
  timeLimitMinutes: z.number(),
  voiceModel: VoiceModelEnum,
  warningTimeMinutes: z.number().nullable(),
  creditCost: z.number(),
  createdAt: z.date(),
  updatedAt: z.date(),
  courseCase: z.object({
    id: z.string(),
    title: z.string(),
    diagnosis: z.string(),
    patientName: z.string(),
    patientAge: z.number(),
    patientGender: z.string(),
    description: z.string(),
    course: z.object({
      id: z.string(),
      title: z.string(),
      exam: z.object({
        id: z.string(),
        title: z.string(),
        slug: z.string()
      })
    })
  })
})

// Type exports
export type CreateSimulationInput = z.infer<typeof createSimulationSchema>
export type UpdateSimulationInput = z.infer<typeof updateSimulationSchema>
export type SimulationParams = z.infer<typeof simulationParamsSchema>
export type SimulationCourseCaseParams = z.infer<typeof simulationCourseCaseParamsSchema>
export type SimulationResponse = z.infer<typeof simulationResponseSchema>
export type VoiceModel = z.infer<typeof VoiceModelEnum>


================================================
File: src/entities/simulation/simulation.service.ts
================================================
import { PrismaClient } from '@prisma/client'
import { CreateSimulationInput, UpdateSimulationInput, VoiceModel } from './simulation.schema'

export class SimulationService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateSimulationInput) {
    // Verify the course case exists
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id: data.courseCaseId },
      include: {
        course: {
          include: { exam: true }
        }
      }
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    // Check if this course case already has a simulation
    const existingSimulation = await this.prisma.simulation.findUnique({
      where: { courseCaseId: data.courseCaseId }
    })

    if (existingSimulation) {
      throw new Error('This course case already has a simulation configured')
    }

    return await this.prisma.simulation.create({
      data: {
        courseCaseId: data.courseCaseId,
        casePrompt: data.casePrompt,
        openingLine: data.openingLine,
        timeLimitMinutes: data.timeLimitMinutes,
        voiceModel: data.voiceModel,
        warningTimeMinutes: data.warningTimeMinutes,
        creditCost: data.creditCost
      },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  async findAll() {
    return await this.prisma.simulation.findMany({
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async findById(id: string) {
    const simulation = await this.prisma.simulation.findUnique({
      where: { id },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!simulation) {
      throw new Error('Simulation not found')
    }

    return simulation
  }

  async findByCourseCaseId(courseCaseId: string) {
    // Verify course case exists
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id: courseCaseId }
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    const simulation = await this.prisma.simulation.findUnique({
      where: { courseCaseId },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!simulation) {
      throw new Error('No simulation configured for this course case')
    }

    return simulation
  }

  async findByCourse(courseId: string) {
    return await this.prisma.simulation.findMany({
      where: {
        courseCase: {
          courseId: courseId
        }
      },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: {
        courseCase: {
          displayOrder: 'asc'
        }
      }
    })
  }

  async findByVoiceModel(voiceModel: VoiceModel) {
    return await this.prisma.simulation.findMany({
      where: { voiceModel },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async findByCreditCost(creditCost: number) {
    return await this.prisma.simulation.findMany({
      where: { creditCost },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async update(id: string, data: UpdateSimulationInput) {
    // Check if simulation exists
    await this.findById(id)

    return await this.prisma.simulation.update({
      where: { id },
      data,
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  async delete(id: string) {
    // Check if simulation exists
    await this.findById(id)

    // Check if there are any simulation attempts
    const attemptCount = await this.prisma.simulationAttempt.count({
      where: { simulationId: id }
    })

    if (attemptCount > 0) {
      throw new Error('Cannot delete simulation with existing student attempts')
    }

    return await this.prisma.simulation.delete({
      where: { id }
    })
  }

  // BUSINESS LOGIC METHODS

  async updateCreditCost(id: string, creditCost: number) {
    if (creditCost < 1 || creditCost > 10) {
      throw new Error('Credit cost must be between 1 and 10')
    }

    const simulation = await this.findById(id)
    
    return await this.prisma.simulation.update({
      where: { id },
      data: { creditCost },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  async updateTimeLimit(id: string, timeLimitMinutes: number, warningTimeMinutes?: number) {
    if (timeLimitMinutes < 1 || timeLimitMinutes > 120) {
      throw new Error('Time limit must be between 1 and 120 minutes')
    }

    if (warningTimeMinutes && warningTimeMinutes >= timeLimitMinutes) {
      throw new Error('Warning time must be less than time limit')
    }

    const simulation = await this.findById(id)
    
    return await this.prisma.simulation.update({
      where: { id },
      data: { 
        timeLimitMinutes,
        warningTimeMinutes
      },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  async getSimulationStats(courseId?: string) {
    const whereClause = courseId ? {
      courseCase: { courseId }
    } : {}

    const totalSimulations = await this.prisma.simulation.count({
      where: whereClause
    })

    const voiceModelStats = await this.prisma.simulation.groupBy({
      by: ['voiceModel'],
      where: whereClause,
      _count: { voiceModel: true }
    })

    const creditCostStats = await this.prisma.simulation.groupBy({
      by: ['creditCost'],
      where: whereClause,
      _count: { creditCost: true }
    })

    const timeLimitStats = await this.prisma.simulation.aggregate({
      where: whereClause,
      _min: { timeLimitMinutes: true },
      _max: { timeLimitMinutes: true },
      _avg: { timeLimitMinutes: true }
    })

    return {
      courseId: courseId || 'all',
      totalSimulations,
      voiceModelDistribution: voiceModelStats.map((stat: { voiceModel: string; _count: { voiceModel: number } }) => ({
        voiceModel: stat.voiceModel,
        count: stat._count.voiceModel
      })),
      creditCostDistribution: creditCostStats.map((stat: { creditCost: number; _count: { creditCost: number } }) => ({
        creditCost: stat.creditCost,
        count: stat._count.creditCost
      })),
      timeLimitRange: {
        min: timeLimitStats._min.timeLimitMinutes,
        max: timeLimitStats._max.timeLimitMinutes,
        avg: timeLimitStats._avg.timeLimitMinutes ? Math.round(timeLimitStats._avg.timeLimitMinutes) : null
      }
    }
  }
}


================================================
File: src/entities/simulation-attempt/simulation-attempt.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { SimulationAttemptService } from './simulation-attempt.service'
import { 
  createSimulationAttemptSchema, 
  completeSimulationAttemptSchema,
  updateSimulationAttemptSchema,
  simulationAttemptParamsSchema,
  simulationAttemptStudentParamsSchema,
  simulationAttemptSimulationParamsSchema,
  simulationAttemptQuerySchema
} from './simulation-attempt.schema'

export default async function simulationAttemptRoutes(fastify: FastifyInstance) {
  const simulationAttemptService = new SimulationAttemptService(fastify.prisma)

  // GET /simulation-attempts - Get all simulation attempts (with query filters)
  fastify.get('/simulation-attempts', async (request, reply) => {
    try {
      const query = simulationAttemptQuerySchema.parse(request.query)
      const attempts = await simulationAttemptService.findAll(query)
      reply.send(attempts)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch simulation attempts' })
    }
  })

  // GET /simulation-attempts/student/:studentId - Get attempts by student
  fastify.get('/simulation-attempts/student/:studentId', async (request, reply) => {
    try {
      const { studentId } = simulationAttemptStudentParamsSchema.parse(request.params)
      const query = simulationAttemptQuerySchema.parse(request.query)
      const attempts = await simulationAttemptService.findByStudent(studentId, query)
      reply.send(attempts)
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /simulation-attempts/simulation/:simulationId - Get attempts by simulation
  fastify.get('/simulation-attempts/simulation/:simulationId', async (request, reply) => {
    try {
      const { simulationId } = simulationAttemptSimulationParamsSchema.parse(request.params)
      const query = simulationAttemptQuerySchema.parse(request.query)
      const attempts = await simulationAttemptService.findBySimulation(simulationId, query)
      reply.send(attempts)
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation not found') {
        reply.status(404).send({ error: 'Simulation not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /simulation-attempts/student/:studentId/stats - Get student performance statistics
  fastify.get('/simulation-attempts/student/:studentId/stats', async (request, reply) => {
    try {
      const { studentId } = simulationAttemptStudentParamsSchema.parse(request.params)
      const stats = await simulationAttemptService.getStudentStats(studentId)
      reply.send(stats)
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /simulation-attempts/simulation/:simulationId/stats - Get simulation usage statistics
  fastify.get('/simulation-attempts/simulation/:simulationId/stats', async (request, reply) => {
    try {
      const { simulationId } = simulationAttemptSimulationParamsSchema.parse(request.params)
      const stats = await simulationAttemptService.getSimulationStats(simulationId)
      reply.send(stats)
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation not found') {
        reply.status(404).send({ error: 'Simulation not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /simulation-attempts/:id - Get simulation attempt by ID
  fastify.get('/simulation-attempts/:id', async (request, reply) => {
    try {
      const { id } = simulationAttemptParamsSchema.parse(request.params)
      const attempt = await simulationAttemptService.findById(id)
      reply.send(attempt)
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation attempt not found') {
        reply.status(404).send({ error: 'Simulation attempt not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /simulation-attempts - Start new simulation attempt (deducts credits)
  fastify.post('/simulation-attempts', async (request, reply) => {
    try {
      const data = createSimulationAttemptSchema.parse(request.body)
      const attempt = await simulationAttemptService.create(data)
      reply.status(201).send({
        message: 'Simulation attempt started successfully',
        attempt,
        creditsDeducted: attempt.simulation.creditCost,
        remainingCredits: attempt.student.creditBalance
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Student not found') {
          reply.status(404).send({ error: 'Student not found' })
        } else if (error.message === 'Simulation not found') {
          reply.status(404).send({ error: 'Simulation not found' })
        } else if (error.message.includes('Insufficient credits')) {
          reply.status(400).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PATCH /simulation-attempts/:id/complete - Complete simulation attempt (add feedback & score)
  fastify.patch('/simulation-attempts/:id/complete', async (request, reply) => {
    try {
      const { id } = simulationAttemptParamsSchema.parse(request.params)
      const data = completeSimulationAttemptSchema.parse(request.body)
      const attempt = await simulationAttemptService.complete(id, data)
      reply.send({
        message: 'Simulation attempt completed successfully',
        attempt,
        duration: `${Math.floor(attempt.durationSeconds! / 60)}:${String(attempt.durationSeconds! % 60).padStart(2, '0')}`,
        score: attempt.score,
        feedbackGenerated: !!attempt.aiFeedback
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Simulation attempt not found') {
          reply.status(404).send({ error: 'Simulation attempt not found' })
        } else if (error.message === 'Simulation attempt is already completed') {
          reply.status(400).send({ error: 'Simulation attempt is already completed' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PUT /simulation-attempts/:id - Update simulation attempt (admin only)
  fastify.put('/simulation-attempts/:id', async (request, reply) => {
    try {
      const { id } = simulationAttemptParamsSchema.parse(request.params)
      const data = updateSimulationAttemptSchema.parse(request.body)
      const attempt = await simulationAttemptService.update(id, data)
      reply.send({
        message: 'Simulation attempt updated successfully',
        attempt
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation attempt not found') {
        reply.status(404).send({ error: 'Simulation attempt not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // DELETE /simulation-attempts/:id - Delete simulation attempt (refunds credits if incomplete)
  fastify.delete('/simulation-attempts/:id', async (request, reply) => {
    try {
      const { id } = simulationAttemptParamsSchema.parse(request.params)
      
      // Get attempt details before deletion for response
      const attempt = await simulationAttemptService.findById(id)
      const wasIncomplete = !attempt.isCompleted
      const creditsToRefund = wasIncomplete ? attempt.simulation.creditCost : 0
      
      await simulationAttemptService.delete(id)
      
      reply.send({
        message: 'Simulation attempt deleted successfully',
        creditsRefunded: creditsToRefund,
        wasIncomplete
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation attempt not found') {
        reply.status(404).send({ error: 'Simulation attempt not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /simulation-attempts/:id/transcript - Get detailed transcript for an attempt
  fastify.get('/simulation-attempts/:id/transcript', async (request, reply) => {
    try {
      const { id } = simulationAttemptParamsSchema.parse(request.params)
      const attempt = await simulationAttemptService.findById(id)
      
      if (!attempt.transcript) {
        reply.status(404).send({ error: 'No transcript available for this attempt' })
        return
      }
      
      reply.send({
        attemptId: attempt.id,
        studentName: `${attempt.student.firstName} ${attempt.student.lastName}`,
        caseTitle: attempt.simulation.courseCase.title,
        startedAt: attempt.startedAt,
        endedAt: attempt.endedAt,
        isCompleted: attempt.isCompleted,
        transcript: attempt.transcript
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation attempt not found') {
        reply.status(404).send({ error: 'Simulation attempt not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /simulation-attempts/:id/feedback - Get detailed AI feedback for an attempt
  fastify.get('/simulation-attempts/:id/feedback', async (request, reply) => {
    try {
      const { id } = simulationAttemptParamsSchema.parse(request.params)
      const attempt = await simulationAttemptService.findById(id)
      
      if (!attempt.aiFeedback) {
        reply.status(404).send({ error: 'No AI feedback available for this attempt' })
        return
      }
      
      reply.send({
        attemptId: attempt.id,
        studentName: `${attempt.student.firstName} ${attempt.student.lastName}`,
        caseTitle: attempt.simulation.courseCase.title,
        score: attempt.score,
        isCompleted: attempt.isCompleted,
        feedback: attempt.aiFeedback
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation attempt not found') {
        reply.status(404).send({ error: 'Simulation attempt not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })
}


================================================
File: src/entities/simulation-attempt/simulation-attempt.schema.ts
================================================
import { z } from 'zod'

// Create SimulationAttempt Schema (start session)
export const createSimulationAttemptSchema = z.object({
  studentId: z.string().uuid('Invalid student ID'),
  simulationId: z.string().uuid('Invalid simulation ID')
  // startedAt will be auto-set to now()
  // endedAt, score, feedback will be set when session completes
})

// Complete SimulationAttempt Schema (end session)
export const completeSimulationAttemptSchema = z.object({
  score: z.number()
    .min(0, 'Score cannot be negative')
    .max(100, 'Score cannot exceed 100')
    .optional(),
  aiFeedback: z.object({
    overallFeedback: z.string(),
    strengths: z.array(z.string()),
    improvements: z.array(z.string()),
    score: z.number().min(0).max(100).optional(),
    markingDomains: z.array(z.object({
      domain: z.string(),
      score: z.number().min(0).max(100),
      feedback: z.string()
    })).optional()
  }).optional(),
  transcript: z.object({
    messages: z.array(z.object({
      timestamp: z.string(),
      speaker: z.enum(['student', 'ai_patient']),
      message: z.string()
    })),
    duration: z.number(),
    totalMessages: z.number()
  }).optional()
})

// Update SimulationAttempt Schema (for admin edits)
export const updateSimulationAttemptSchema = z.object({
  score: z.number()
    .min(0, 'Score cannot be negative')
    .max(100, 'Score cannot exceed 100')
    .optional(),
  aiFeedback: z.object({
    overallFeedback: z.string(),
    strengths: z.array(z.string()),
    improvements: z.array(z.string()),
    score: z.number().min(0).max(100).optional(),
    markingDomains: z.array(z.object({
      domain: z.string(),
      score: z.number().min(0).max(100),
      feedback: z.string()
    })).optional()
  }).optional(),
  transcript: z.object({
    messages: z.array(z.object({
      timestamp: z.string(),
      speaker: z.enum(['student', 'ai_patient']),
      message: z.string()
    })),
    duration: z.number(),
    totalMessages: z.number()
  }).optional()
})

// URL Params Schemas
export const simulationAttemptParamsSchema = z.object({
  id: z.string().uuid('Invalid simulation attempt ID')
})

export const simulationAttemptStudentParamsSchema = z.object({
  studentId: z.string().uuid('Invalid student ID')
})

export const simulationAttemptSimulationParamsSchema = z.object({
  simulationId: z.string().uuid('Invalid simulation ID')
})

// Query Params Schemas
export const simulationAttemptQuerySchema = z.object({
  completed: z.string().transform(val => val === 'true').optional(),
  limit: z.string().transform(val => parseInt(val)).refine(val => val > 0 && val <= 100, 'Limit must be between 1 and 100').optional(),
  offset: z.string().transform(val => parseInt(val)).refine(val => val >= 0, 'Offset must be non-negative').optional()
})

// Response Schema
export const simulationAttemptResponseSchema = z.object({
  id: z.string(),
  studentId: z.string(),
  simulationId: z.string(),
  startedAt: z.date(),
  endedAt: z.date().nullable(),
  durationSeconds: z.number().nullable(),
  isCompleted: z.boolean(),
  score: z.number().nullable(),
  aiFeedback: z.any().nullable(), // JSON field
  transcript: z.any().nullable(), // JSON field
  createdAt: z.date(),
  student: z.object({
    id: z.string(),
    firstName: z.string(),
    lastName: z.string(),
    creditBalance: z.number()
  }),
  simulation: z.object({
    id: z.string(),
    timeLimitMinutes: z.number(),
    creditCost: z.number(),
    voiceModel: z.string(),
    courseCase: z.object({
      id: z.string(),
      title: z.string(),
      diagnosis: z.string(),
      patientName: z.string(),
      course: z.object({
        id: z.string(),
        title: z.string()
      })
    })
  })
})

// Type exports
export type CreateSimulationAttemptInput = z.infer<typeof createSimulationAttemptSchema>
export type CompleteSimulationAttemptInput = z.infer<typeof completeSimulationAttemptSchema>
export type UpdateSimulationAttemptInput = z.infer<typeof updateSimulationAttemptSchema>
export type SimulationAttemptParams = z.infer<typeof simulationAttemptParamsSchema>
export type SimulationAttemptStudentParams = z.infer<typeof simulationAttemptStudentParamsSchema>
export type SimulationAttemptSimulationParams = z.infer<typeof simulationAttemptSimulationParamsSchema>
export type SimulationAttemptQuery = z.infer<typeof simulationAttemptQuerySchema>
export type SimulationAttemptResponse = z.infer<typeof simulationAttemptResponseSchema>


================================================
File: src/entities/simulation-attempt/simulation-attempt.service.ts
================================================
import { PrismaClient, Prisma } from '@prisma/client'
import { CreateSimulationAttemptInput, CompleteSimulationAttemptInput, UpdateSimulationAttemptInput } from './simulation-attempt.schema'

export class SimulationAttemptService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateSimulationAttemptInput) {
    // Verify the student exists
    const student = await this.prisma.student.findUnique({
      where: { id: data.studentId }
    })

    if (!student) {
      throw new Error('Student not found')
    }

    // Verify the simulation exists
    const simulation = await this.prisma.simulation.findUnique({
      where: { id: data.simulationId },
      include: {
        courseCase: {
          include: {
            course: true
          }
        }
      }
    })

    if (!simulation) {
      throw new Error('Simulation not found')
    }

    // Check if student has sufficient credits
    if (student.creditBalance < simulation.creditCost) {
      throw new Error(`Insufficient credits. Required: ${simulation.creditCost}, Available: ${student.creditBalance}`)
    }

    // Start transaction to deduct credits and create attempt
    return await this.prisma.$transaction(async (tx: Prisma.TransactionClient) => {
      // Deduct credits from student
      await tx.student.update({
        where: { id: data.studentId },
        data: {
          creditBalance: student.creditBalance - simulation.creditCost
        }
      })

      // Create simulation attempt
      const attempt = await tx.simulationAttempt.create({
        data: {
          studentId: data.studentId,
          simulationId: data.simulationId,
          startedAt: new Date()
        },
        include: {
          student: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              creditBalance: true
            }
          },
          simulation: {
            include: {
              courseCase: {
                include: {
                  course: {
                    select: {
                      id: true,
                      title: true
                    }
                  }
                }
              }
            }
          }
        }
      })

      return attempt
    })
  }

  async complete(id: string, data: CompleteSimulationAttemptInput) {
    // Check if attempt exists and is not already completed
    const attempt = await this.prisma.simulationAttempt.findUnique({
      where: { id },
      include: {
        simulation: true
      }
    })

    if (!attempt) {
      throw new Error('Simulation attempt not found')
    }

    if (attempt.isCompleted) {
      throw new Error('Simulation attempt is already completed')
    }

    const endTime = new Date()
    const durationSeconds = Math.floor((endTime.getTime() - attempt.startedAt.getTime()) / 1000)

    return await this.prisma.simulationAttempt.update({
      where: { id },
      data: {
        endedAt: endTime,
        durationSeconds: durationSeconds,
        isCompleted: true,
        score: data.score,
        aiFeedback: data.aiFeedback,
        transcript: data.transcript
      },
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            creditBalance: true
          }
        },
        simulation: {
          include: {
            courseCase: {
              include: {
                course: {
                  select: {
                    id: true,
                    title: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  async findAll(query?: { completed?: boolean; limit?: number; offset?: number }) {
    const where: any = {}
    if (query?.completed !== undefined) {
      where.isCompleted = query.completed
    }

    return await this.prisma.simulationAttempt.findMany({
      where,
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            creditBalance: true
          }
        },
        simulation: {
          include: {
            courseCase: {
              include: {
                course: {
                  select: {
                    id: true,
                    title: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: {
        startedAt: 'desc'
      },
      take: query?.limit || 50,
      skip: query?.offset || 0
    })
  }

  async findById(id: string) {
    const attempt = await this.prisma.simulationAttempt.findUnique({
      where: { id },
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            creditBalance: true
          }
        },
        simulation: {
          include: {
            courseCase: {
              include: {
                course: {
                  select: {
                    id: true,
                    title: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!attempt) {
      throw new Error('Simulation attempt not found')
    }

    return attempt
  }

  async findByStudent(studentId: string, query?: { completed?: boolean; limit?: number; offset?: number }) {
    // Verify student exists
    const student = await this.prisma.student.findUnique({
      where: { id: studentId }
    })

    if (!student) {
      throw new Error('Student not found')
    }

    const where: any = { studentId }
    if (query?.completed !== undefined) {
      where.isCompleted = query.completed
    }

    return await this.prisma.simulationAttempt.findMany({
      where,
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            creditBalance: true
          }
        },
        simulation: {
          include: {
            courseCase: {
              include: {
                course: {
                  select: {
                    id: true,
                    title: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: {
        startedAt: 'desc'
      },
      take: query?.limit || 50,
      skip: query?.offset || 0
    })
  }

  async findBySimulation(simulationId: string, query?: { completed?: boolean; limit?: number; offset?: number }) {
    // Verify simulation exists
    const simulation = await this.prisma.simulation.findUnique({
      where: { id: simulationId }
    })

    if (!simulation) {
      throw new Error('Simulation not found')
    }

    const where: any = { simulationId }
    if (query?.completed !== undefined) {
      where.isCompleted = query.completed
    }

    return await this.prisma.simulationAttempt.findMany({
      where,
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            creditBalance: true
          }
        },
        simulation: {
          include: {
            courseCase: {
              include: {
                course: {
                  select: {
                    id: true,
                    title: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: {
        startedAt: 'desc'
      },
      take: query?.limit || 50,
      skip: query?.offset || 0
    })
  }

  async update(id: string, data: UpdateSimulationAttemptInput) {
    // Check if attempt exists
    await this.findById(id)

    return await this.prisma.simulationAttempt.update({
      where: { id },
      data,
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            creditBalance: true
          }
        },
        simulation: {
          include: {
            courseCase: {
              include: {
                course: {
                  select: {
                    id: true,
                    title: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  async delete(id: string) {
    // Check if attempt exists
    const attempt = await this.findById(id)

    // If attempt was not completed, refund credits to student
    if (!attempt.isCompleted) {
      await this.prisma.$transaction(async (tx: Prisma.TransactionClient) => {
        // Get current student credit balance
        const student = await tx.student.findUnique({
          where: { id: attempt.studentId }
        })

        if (student) {
          // Refund credits
          await tx.student.update({
            where: { id: attempt.studentId },
            data: {
              creditBalance: student.creditBalance + attempt.simulation.creditCost
            }
          })
        }

        // Delete the attempt
        await tx.simulationAttempt.delete({
          where: { id }
        })
      })
    } else {
      // Just delete if completed (no refund)
      await this.prisma.simulationAttempt.delete({
        where: { id }
      })
    }
  }

  // BUSINESS LOGIC METHODS

  async getStudentStats(studentId: string) {
    const student = await this.prisma.student.findUnique({
      where: { id: studentId }
    })

    if (!student) {
      throw new Error('Student not found')
    }

    const totalAttempts = await this.prisma.simulationAttempt.count({
      where: { studentId }
    })

    const completedAttempts = await this.prisma.simulationAttempt.count({
      where: { studentId, isCompleted: true }
    })

    const incompleteAttempts = totalAttempts - completedAttempts

    const scoreStats = await this.prisma.simulationAttempt.aggregate({
      where: { studentId, isCompleted: true, score: { not: null } },
      _avg: { score: true },
      _min: { score: true },
      _max: { score: true }
    })

    const durationStats = await this.prisma.simulationAttempt.aggregate({
      where: { studentId, isCompleted: true },
      _avg: { durationSeconds: true },
      _min: { durationSeconds: true },
      _max: { durationSeconds: true }
    })

    return {
      studentId,
      studentName: `${student.firstName} ${student.lastName}`,
      currentCreditBalance: student.creditBalance,
      totalAttempts,
      completedAttempts,
      incompleteAttempts,
      completionRate: totalAttempts > 0 ? Math.round((completedAttempts / totalAttempts) * 100) : 0,
      scoreStats: {
        average: scoreStats._avg.score ? Number(scoreStats._avg.score.toFixed(1)) : null,
        minimum: scoreStats._min.score ? Number(scoreStats._min.score) : null,
        maximum: scoreStats._max.score ? Number(scoreStats._max.score) : null
      },
      durationStats: {
        averageSeconds: durationStats._avg.durationSeconds ? Math.round(durationStats._avg.durationSeconds) : null,
        minimumSeconds: durationStats._min.durationSeconds,
        maximumSeconds: durationStats._max.durationSeconds
      }
    }
  }

  async getSimulationStats(simulationId: string) {
    const simulation = await this.prisma.simulation.findUnique({
      where: { id: simulationId },
      include: {
        courseCase: true
      }
    })

    if (!simulation) {
      throw new Error('Simulation not found')
    }

    const totalAttempts = await this.prisma.simulationAttempt.count({
      where: { simulationId }
    })

    const completedAttempts = await this.prisma.simulationAttempt.count({
      where: { simulationId, isCompleted: true }
    })

    const uniqueStudents = await this.prisma.simulationAttempt.findMany({
      where: { simulationId },
      select: { studentId: true },
      distinct: ['studentId']
    })

    const scoreStats = await this.prisma.simulationAttempt.aggregate({
      where: { simulationId, isCompleted: true, score: { not: null } },
      _avg: { score: true },
      _min: { score: true },
      _max: { score: true }
    })

    return {
      simulationId,
      caseTitle: simulation.courseCase.title,
      totalAttempts,
      completedAttempts,
      incompleteAttempts: totalAttempts - completedAttempts,
      uniqueStudents: uniqueStudents.length,
      completionRate: totalAttempts > 0 ? Math.round((completedAttempts / totalAttempts) * 100) : 0,
      scoreStats: {
        average: scoreStats._avg.score ? Number(scoreStats._avg.score.toFixed(1)) : null,
        minimum: scoreStats._min.score ? Number(scoreStats._min.score) : null,
        maximum: scoreStats._max.score ? Number(scoreStats._max.score) : null
      }
    }
  }
}


================================================
File: src/entities/specialty/specialty.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { SpecialtyService } from './specialty.service'
import { 
  createSpecialtySchema, 
  updateSpecialtySchema, 
  specialtyParamsSchema 
} from './specialty.schema'

export default async function specialtyRoutes(fastify: FastifyInstance) {
  const specialtyService = new SpecialtyService(fastify.prisma)

  // GET /specialties - Get all specialties
  fastify.get('/specialties', async (request, reply) => {
    try {
      const specialties = await specialtyService.findAll()
      reply.send(specialties)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch specialties' })
    }
  })

  // GET /specialties/:id - Get specialty by ID
  fastify.get('/specialties/:id', async (request, reply) => {
    try {
      const { id } = specialtyParamsSchema.parse(request.params)
      const specialty = await specialtyService.findById(id)
      reply.send(specialty)
    } catch (error) {
      if (error instanceof Error && error.message === 'Specialty not found') {
        reply.status(404).send({ error: 'Specialty not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /specialties - Create new specialty
  fastify.post('/specialties', async (request, reply) => {
    try {
      const data = createSpecialtySchema.parse(request.body)
      const specialty = await specialtyService.create(data)
      reply.status(201).send(specialty)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid data or specialty already exists' })
    }
  })

  // PUT /specialties/:id - Update specialty
  fastify.put('/specialties/:id', async (request, reply) => {
    try {
      const { id } = specialtyParamsSchema.parse(request.params)
      const data = updateSpecialtySchema.parse(request.body)
      const specialty = await specialtyService.update(id, data)
      reply.send(specialty)
    } catch (error) {
      if (error instanceof Error && error.message === 'Specialty not found') {
        reply.status(404).send({ error: 'Specialty not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // DELETE /specialties/:id - Delete specialty
  fastify.delete('/specialties/:id', async (request, reply) => {
    try {
      const { id } = specialtyParamsSchema.parse(request.params)
      await specialtyService.delete(id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'Specialty not found') {
        reply.status(404).send({ error: 'Specialty not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })
}


================================================
File: src/entities/specialty/specialty.schema.ts
================================================
import { z } from 'zod'

// Create Specialty Schema
export const createSpecialtySchema = z.object({
  name: z.string()
    .min(1, 'Name is required')
    .max(100, 'Name must be less than 100 characters')
    .trim()
})

// Update Specialty Schema
export const updateSpecialtySchema = z.object({
  name: z.string()
    .min(1, 'Name is required')
    .max(100, 'Name must be less than 100 characters')
    .trim()
    .optional()
})

// URL Params Schema
export const specialtyParamsSchema = z.object({
  id: z.string().uuid('Invalid specialty ID')
})

// Response Schema (what we send back)
export const specialtyResponseSchema = z.object({
  id: z.string(),
  name: z.string(),
  createdAt: z.date()
})

// Type exports for TypeScript
export type CreateSpecialtyInput = z.infer<typeof createSpecialtySchema>
export type UpdateSpecialtyInput = z.infer<typeof updateSpecialtySchema>
export type SpecialtyParams = z.infer<typeof specialtyParamsSchema>
export type SpecialtyResponse = z.infer<typeof specialtyResponseSchema>


================================================
File: src/entities/specialty/specialty.service.ts
================================================
import { PrismaClient } from '@prisma/client'
import { CreateSpecialtyInput, UpdateSpecialtyInput } from './specialty.schema'

export class SpecialtyService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateSpecialtyInput) {
    return await this.prisma.specialty.create({
      data: {
        name: data.name
      }
    })
  }

  async findAll() {
    return await this.prisma.specialty.findMany({
      orderBy: {
        name: 'asc'
      }
    })
  }

  async findById(id: string) {
    const specialty = await this.prisma.specialty.findUnique({
      where: { id }
    })

    if (!specialty) {
      throw new Error('Specialty not found')
    }

    return specialty
  }

  async update(id: string, data: UpdateSpecialtyInput) {
    // Check if exists first
    await this.findById(id)

    return await this.prisma.specialty.update({
      where: { id },
      data
    })
  }

  async delete(id: string) {
    // Check if exists first
    await this.findById(id)

    return await this.prisma.specialty.delete({
      where: { id }
    })
  }
}


================================================
File: src/entities/student/student.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { z } from 'zod'
import { StudentService } from './student.service'
import { 
  createStudentSchema, 
  updateStudentSchema, 
  studentUserParamsSchema 
} from './student.schema'

// Credit operation schemas
const creditOperationSchema = z.object({
  amount: z.number().positive('Amount must be positive'),
  reason: z.string().optional()
})

export default async function studentRoutes(fastify: FastifyInstance) {
  const studentService = new StudentService(fastify.prisma)

  // GET /students - Get all students
  fastify.get('/students', async (request, reply) => {
    try {
      const students = await studentService.findAll()
      reply.send(students)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch students' })
    }
  })

  // GET /students/:userId - Get student by User ID
  fastify.get('/students/:userId', async (request, reply) => {
    try {
      const { userId } = studentUserParamsSchema.parse(request.params)
      const student = await studentService.findByUserId(userId)
      reply.send(student)
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /students - Create new student (creates User + Student)
  fastify.post('/students', async (request, reply) => {
    try {
      const data = createStudentSchema.parse(request.body)
      const student = await studentService.create(data)
      reply.status(201).send(student)
    } catch (error) {
      if (error instanceof Error && error.message.includes('Unique constraint failed')) {
        reply.status(400).send({ error: 'Email already exists' })
      } else {
        reply.status(400).send({ error: 'Invalid data' })
      }
    }
  })

  // PUT /students/:userId - Update student by User ID
  fastify.put('/students/:userId', async (request, reply) => {
    try {
      const { userId } = studentUserParamsSchema.parse(request.params)
      const data = updateStudentSchema.parse(request.body)
      
      // Get student by userId first to get the UUID for update
      const existingStudent = await studentService.findByUserId(userId)
      const student = await studentService.update(existingStudent.id, data)
      reply.send(student)
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // DELETE /students/:userId - Delete student by User ID
  fastify.delete('/students/:userId', async (request, reply) => {
    try {
      const { userId } = studentUserParamsSchema.parse(request.params)
      
      // Get student by userId first to get the UUID for deletion
      const existingStudent = await studentService.findByUserId(userId)
      await studentService.delete(existingStudent.id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // CREDIT MANAGEMENT ENDPOINTS

  // GET /students/:userId/credits - Get credit balance
  fastify.get('/students/:userId/credits', async (request, reply) => {
    try {
      const { userId } = studentUserParamsSchema.parse(request.params)
      const balance = await studentService.getCreditBalance(userId)
      reply.send({ userId, creditBalance: balance })
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /students/:userId/credits/add - Add credits
  fastify.post('/students/:userId/credits/add', async (request, reply) => {
    try {
      const { userId } = studentUserParamsSchema.parse(request.params)
      const { amount, reason } = creditOperationSchema.parse(request.body)
      
      const student = await studentService.addCredits(userId, amount, reason)
      reply.send({
        message: 'Credits added successfully',
        student,
        operation: {
          type: 'credit',
          amount,
          reason: reason || 'Manual credit addition'
        }
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: error instanceof Error ? error.message : 'Invalid request' })
      }
    }
  })

  // POST /students/:userId/credits/deduct - Deduct credits
  fastify.post('/students/:userId/credits/deduct', async (request, reply) => {
    try {
      const { userId } = studentUserParamsSchema.parse(request.params)
      const { amount, reason } = creditOperationSchema.parse(request.body)
      
      const student = await studentService.deductCredits(userId, amount, reason)
      reply.send({
        message: 'Credits deducted successfully',
        student,
        operation: {
          type: 'debit',
          amount,
          reason: reason || 'Manual credit deduction'
        }
      })
    } catch (error) {
      if (error instanceof Error && (error.message === 'Student not found' || error.message === 'Insufficient credits')) {
        const status = error.message === 'Student not found' ? 404 : 400
        reply.status(status).send({ error: error.message })
      } else {
        reply.status(400).send({ error: error instanceof Error ? error.message : 'Invalid request' })
      }
    }
  })

  // GET /students/:userId/credits/check/:amount - Check if student has sufficient credits
  fastify.get('/students/:userId/credits/check/:amount', async (request, reply) => {
    try {
      const { userId } = studentUserParamsSchema.parse(request.params)
      const { amount } = request.params as { amount: string }
      const requiredAmount = parseInt(amount)
      
      if (isNaN(requiredAmount) || requiredAmount <= 0) {
        return reply.status(400).send({ error: 'Invalid amount' })
      }
      
      const hasSufficientCredits = await studentService.checkSufficientCredits(userId, requiredAmount)
      const currentBalance = await studentService.getCreditBalance(userId)
      
      reply.send({
        userId,
        requiredAmount,
        currentBalance,
        hasSufficientCredits,
        shortfall: hasSufficientCredits ? 0 : requiredAmount - currentBalance
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })
}


================================================
File: src/entities/student/student.schema.ts
================================================
import { z } from 'zod'

// Create Student Schema (includes User data)
export const createStudentSchema = z.object({
  // User fields
  email: z.string().email('Invalid email format'),
  name: z.string().optional(),
  
  // Student fields
  firstName: z.string()
    .min(1, 'First name is required')
    .max(50, 'First name must be less than 50 characters')
    .trim(),
  lastName: z.string()
    .min(1, 'Last name is required')
    .max(50, 'Last name must be less than 50 characters')
    .trim(),
  dateOfBirth: z.string()
    .datetime('Invalid date format')
    .or(z.date())
    .transform((val) => new Date(val))
    .refine((date) => {
      const age = (new Date().getTime() - date.getTime()) / (1000 * 60 * 60 * 24 * 365.25)
      return age >= 18 && age <= 100
    }, 'Age must be between 18 and 100 years')
  // Note: creditBalance is NOT included - always starts at 0
})

// Update Student Schema
export const updateStudentSchema = z.object({
  firstName: z.string()
    .min(1, 'First name is required')
    .max(50, 'First name must be less than 50 characters')
    .trim()
    .optional(),
  lastName: z.string()
    .min(1, 'Last name is required')
    .max(50, 'Last name must be less than 50 characters')
    .trim()
    .optional(),
  dateOfBirth: z.string()
    .datetime('Invalid date format')
    .or(z.date())
    .transform((val) => new Date(val))
    .refine((date) => {
      const age = (new Date().getTime() - date.getTime()) / (1000 * 60 * 60 * 24 * 365.25)
      return age >= 18 && age <= 100
    }, 'Age must be between 18 and 100 years')
    .optional()
  // Note: creditBalance updates will be handled by separate business methods
})

// URL Params Schema
const studentUserParamsSchema = z.object({
  userId: z.string().transform(val => parseInt(val)).refine(val => !isNaN(val), 'Invalid user ID')
})

// Response Schema
export const studentResponseSchema = z.object({
  id: z.string(),
  userId: z.number(),
  firstName: z.string(),
  lastName: z.string(),
  dateOfBirth: z.date(),
  creditBalance: z.number(),
  createdAt: z.date(),
  updatedAt: z.date(),
  user: z.object({
    id: z.number(),
    email: z.string(),
    name: z.string().nullable()
  })
})

// Type exports
export type CreateStudentInput = z.infer<typeof createStudentSchema>
export type UpdateStudentInput = z.infer<typeof updateStudentSchema>
export type StudentUserParams = z.infer<typeof studentUserParamsSchema>
export type StudentResponse = z.infer<typeof studentResponseSchema>

// Export the params schema
export { studentUserParamsSchema }


================================================
File: src/entities/student/student.service.ts
================================================
import { PrismaClient, Prisma } from '@prisma/client'
import { CreateStudentInput, UpdateStudentInput } from './student.schema'

export class StudentService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateStudentInput) {
    // Create User and Student in a transaction
    return await this.prisma.$transaction(async (tx: Prisma.TransactionClient) => {
      // First, create the User
      const user = await tx.user.create({
        data: {
          email: data.email,
          name: data.name
        }
      })

      // Then, create the Student linked to the User
      const student = await tx.student.create({
        data: {
          userId: user.id,
          firstName: data.firstName,
          lastName: data.lastName,
          dateOfBirth: data.dateOfBirth,
          creditBalance: 0 // Always start with 0 credits
        },
        include: {
          user: true
        }
      })

      return student
    })
  }

  async findAll() {
    return await this.prisma.student.findMany({
      include: {
        user: true
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async findById(id: string) {
    const student = await this.prisma.student.findUnique({
      where: { id },
      include: {
        user: true
      }
    })

    if (!student) {
      throw new Error('Student not found')
    }

    return student
  }

  async findByUserId(userId: number) {
    const student = await this.prisma.student.findUnique({
      where: { userId },
      include: {
        user: true
      }
    })

    if (!student) {
      throw new Error('Student not found')
    }

    return student
  }

  async update(id: string, data: UpdateStudentInput) {
    // Check if exists first
    await this.findById(id)

    return await this.prisma.student.update({
      where: { id },
      data,
      include: {
        user: true
      }
    })
  }

  async delete(id: string) {
    // Check if exists first
    const student = await this.findById(id)

    // Delete in transaction (Student first, then User)
    return await this.prisma.$transaction(async (tx: Prisma.TransactionClient) => {
      await tx.student.delete({
        where: { id }
      })

      await tx.user.delete({
        where: { id: student.userId }
      })
    })
  }

  // CREDIT MANAGEMENT BUSINESS LOGIC

  async addCredits(userId: number, amount: number, reason?: string) {
    if (amount <= 0) {
      throw new Error('Credit amount must be positive')
    }

    const student = await this.findByUserId(userId)
    
    return await this.prisma.student.update({
      where: { userId },
      data: {
        creditBalance: student.creditBalance + amount
      },
      include: {
        user: true
      }
    })
  }

  async deductCredits(userId: number, amount: number, reason?: string) {
    if (amount <= 0) {
      throw new Error('Credit amount must be positive')
    }

    const student = await this.findByUserId(userId)
    
    if (student.creditBalance < amount) {
      throw new Error('Insufficient credits')
    }

    return await this.prisma.student.update({
      where: { userId },
      data: {
        creditBalance: student.creditBalance - amount
      },
      include: {
        user: true
      }
    })
  }

  async getCreditBalance(userId: number): Promise<number> {
    const student = await this.findByUserId(userId)
    return student.creditBalance
  }

  async checkSufficientCredits(userId: number, requiredAmount: number): Promise<boolean> {
    const balance = await this.getCreditBalance(userId)
    return balance >= requiredAmount
  }
}


================================================
File: src/entities/subscription/subscription.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { SubscriptionService } from './subscription.service'
import { 
  createSubscriptionSchema,
  subscriptionParamsSchema,
  subscriptionStudentParamsSchema,
  subscriptionCourseParamsSchema,
  subscriptionCheckParamsSchema,
  subscriptionQuerySchema
} from './subscription.schema'
import { requireAuth, getCurrentStudentId } from '../../middleware/auth.middleware'

export default async function subscriptionRoutes(fastify: FastifyInstance) {
  const subscriptionService = new SubscriptionService(fastify.prisma)

  // GET /subscriptions - Get all subscriptions (admin only - instructors)
  fastify.get('/subscriptions', {
    preHandler: requireAuth('instructor')
  }, async (request, reply) => {
    try {
      const query = subscriptionQuerySchema.parse(request.query)
      const subscriptions = await subscriptionService.findAll(query)
      reply.send(subscriptions)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch subscriptions' })
    }
  })

  // GET /subscriptions/my - Get current student's subscriptions
  fastify.get('/subscriptions/my', {
    preHandler: requireAuth('student')
  }, async (request, reply) => {
    try {
      const studentId = getCurrentStudentId(request)!
      const query = subscriptionQuerySchema.parse(request.query)
      const subscriptions = await subscriptionService.findByStudent(studentId, query)
      reply.send(subscriptions)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch your subscriptions' })
    }
  })

  // GET /subscriptions/student/:studentId - Get subscriptions by student (instructor only)
  fastify.get('/subscriptions/student/:studentId', {
    preHandler: requireAuth('instructor')
  }, async (request, reply) => {
    try {
      const { studentId } = subscriptionStudentParamsSchema.parse(request.params)
      const query = subscriptionQuerySchema.parse(request.query)
      const subscriptions = await subscriptionService.findByStudent(studentId, query)
      reply.send(subscriptions)
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /subscriptions/course/:courseId - Get subscriptions by course (instructor only)
  fastify.get('/subscriptions/course/:courseId', {
    preHandler: requireAuth('instructor')
  }, async (request, reply) => {
    try {
      const { courseId } = subscriptionCourseParamsSchema.parse(request.params)
      const query = subscriptionQuerySchema.parse(request.query)
      const subscriptions = await subscriptionService.findByCourse(courseId, query)
      reply.send(subscriptions)
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /subscriptions/check/:studentId/:courseId - Check subscription status (instructor)
  fastify.get('/subscriptions/check/:studentId/:courseId', {
    preHandler: requireAuth('instructor')
  }, async (request, reply) => {
    try {
      const { studentId, courseId } = subscriptionCheckParamsSchema.parse(request.params)
      const status = await subscriptionService.checkSubscription(studentId, courseId)
      reply.send(status)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /subscriptions/my/:courseId/check - Check current student's subscription to a course
  fastify.get('/subscriptions/my/:courseId/check', {
    preHandler: requireAuth('student')
  }, async (request, reply) => {
    try {
      const studentId = getCurrentStudentId(request)!
      const { courseId } = subscriptionCourseParamsSchema.parse(request.params)
      const status = await subscriptionService.checkSubscription(studentId, courseId)
      reply.send(status)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /subscriptions/my/stats - Get current student's subscription statistics
  fastify.get('/subscriptions/my/stats', {
    preHandler: requireAuth('student')
  }, async (request, reply) => {
    try {
      const studentId = getCurrentStudentId(request)!
      const stats = await subscriptionService.getStudentStats(studentId)
      reply.send(stats)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch subscription statistics' })
    }
  })

  // GET /subscriptions/student/:studentId/stats - Get student subscription stats (instructor)
  fastify.get('/subscriptions/student/:studentId/stats', {
    preHandler: requireAuth('instructor')
  }, async (request, reply) => {
    try {
      const { studentId } = subscriptionStudentParamsSchema.parse(request.params)
      const stats = await subscriptionService.getStudentStats(studentId)
      reply.send(stats)
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /subscriptions/my/courses - Get all courses student has access to
  fastify.get('/subscriptions/my/courses', {
    preHandler: requireAuth('student')
  }, async (request, reply) => {
    try {
      const studentId = getCurrentStudentId(request)!
      const accessibleCourseIds = await subscriptionService.getAccessibleCourses(studentId)
      
      // Fetch full course details
      const courses = await fastify.prisma.course.findMany({
        where: {
          id: { in: accessibleCourseIds }
        },
        include: {
          exam: {
            select: {
              id: true,
              title: true,
              slug: true
            }
          }
        }
      })
      
      reply.send({
        totalAccessibleCourses: courses.length,
        courses
      })
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch accessible courses' })
    }
  })

  // GET /subscriptions/:id - Get subscription by ID
  fastify.get('/subscriptions/:id', {
    preHandler: requireAuth()
  }, async (request, reply) => {
    try {
      const { id } = subscriptionParamsSchema.parse(request.params)
      const subscription = await subscriptionService.findById(id)
      
      // Check authorization - students can only see their own subscriptions
      if (request.userType === 'student' && subscription.studentId !== getCurrentStudentId(request)) {
        reply.status(403).send({ error: 'Access denied' })
        return
      }
      
      reply.send(subscription)
    } catch (error) {
      if (error instanceof Error && error.message === 'Subscription not found') {
        reply.status(404).send({ error: 'Subscription not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /subscriptions - Create new subscription (mock payment)
  fastify.post('/subscriptions', {
    preHandler: requireAuth('student')
  }, async (request, reply) => {
    try {
      const studentId = getCurrentStudentId(request)!
      const data = createSubscriptionSchema.parse(request.body)
      
      // Ensure student is subscribing for themselves
      if (data.studentId !== studentId) {
        reply.status(403).send({ error: 'You can only create subscriptions for yourself' })
        return
      }
      
      const subscription = await subscriptionService.create(data)
      
      // Get updated student info for credit balance
      const student = await fastify.prisma.student.findUnique({
        where: { id: studentId }
      })
      
      reply.status(201).send({
        message: 'Subscription created successfully',
        subscription,
        creditsAdded: subscription.course.style === 'RANDOM' 
          ? (data.durationMonths === 3 ? subscription.course.credits3Months :
             data.durationMonths === 6 ? subscription.course.credits6Months :
             subscription.course.credits12Months)
          : 0,
        newCreditBalance: student?.creditBalance || 0
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Student not found') {
          reply.status(404).send({ error: 'Student not found' })
        } else if (error.message === 'Course not found') {
          reply.status(404).send({ error: 'Course not found' })
        } else if (error.message === 'Course is not published') {
          reply.status(400).send({ error: 'Course is not published' })
        } else if (error.message === 'Student already has an active subscription to this course') {
          reply.status(400).send({ error: 'You already have an active subscription to this course' })
        } else {
          reply.status(400).send({ error: 'Invalid subscription data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /subscriptions/update-status - Update subscription statuses (can be called periodically)
  fastify.post('/subscriptions/update-status', {
    preHandler: requireAuth('instructor')
  }, async (request, reply) => {
    try {
      await subscriptionService.updateSubscriptionStatus()
      reply.send({ message: 'Subscription statuses updated successfully' })
    } catch (error) {
      reply.status(500).send({ error: 'Failed to update subscription statuses' })
    }
  })

  // Helper endpoint to check content access
  fastify.get('/subscriptions/can-access/:courseId', {
    preHandler: requireAuth('student')
  }, async (request, reply) => {
    try {
      const studentId = getCurrentStudentId(request)!
      const { courseId } = subscriptionCourseParamsSchema.parse(request.params)
      const canAccess = await subscriptionService.canAccessCourseContent(studentId, courseId)
      
      reply.send({
        courseId,
        canAccess,
        reason: canAccess ? 'Active subscription or free content' : 'No active subscription'
      })
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })
}


================================================
File: src/entities/subscription/subscription.schema.ts
================================================
import { z } from 'zod'

// Create Subscription Schema (mocking payment for now)
export const createSubscriptionSchema = z.object({
  studentId: z.string().uuid('Invalid student ID'),
  courseId: z.string().uuid('Invalid course ID'),
  durationMonths: z.enum(['3', '6', '12']).transform(val => parseInt(val)),
  // In production, paymentId would come from Stripe
  mockPaymentId: z.string().default('mock_payment_' + Date.now())
})

// Check Subscription Schema
export const checkSubscriptionSchema = z.object({
  studentId: z.string().uuid('Invalid student ID'),
  courseId: z.string().uuid('Invalid course ID')
})

// URL Params Schemas
export const subscriptionParamsSchema = z.object({
  id: z.string().uuid('Invalid subscription ID')
})

export const subscriptionStudentParamsSchema = z.object({
  studentId: z.string().uuid('Invalid student ID')
})

export const subscriptionCourseParamsSchema = z.object({
  courseId: z.string().uuid('Invalid course ID')
})

export const subscriptionCheckParamsSchema = z.object({
  studentId: z.string().uuid('Invalid student ID'),
  courseId: z.string().uuid('Invalid course ID')
})

// Query Params Schema
export const subscriptionQuerySchema = z.object({
  active: z.string().transform(val => val === 'true').optional(),
  includeExpired: z.string().transform(val => val === 'true').optional()
})

// Response Schemas
export const subscriptionResponseSchema = z.object({
  id: z.string(),
  studentId: z.string(),
  courseId: z.string(),
  paymentId: z.string(),
  durationMonths: z.number(),
  startDate: z.date(),
  endDate: z.date(),
  isActive: z.boolean(),
  createdAt: z.date(),
  student: z.object({
    id: z.string(),
    firstName: z.string(),
    lastName: z.string(),
    email: z.string().optional()
  }).optional(),
  course: z.object({
    id: z.string(),
    title: z.string(),
    style: z.string(),
    exam: z.object({
      id: z.string(),
      title: z.string(),
      slug: z.string()
    })
  }).optional()
})

export const subscriptionStatusResponseSchema = z.object({
  hasActiveSubscription: z.boolean(),
  subscription: subscriptionResponseSchema.optional(),
  daysRemaining: z.number().optional(),
  isExpired: z.boolean()
})

export const subscriptionStatsResponseSchema = z.object({
  studentId: z.string(),
  totalSubscriptions: z.number(),
  activeSubscriptions: z.number(),
  expiredSubscriptions: z.number(),
  totalCreditsReceived: z.number(),
  subscriptionsByDuration: z.object({
    threeMonth: z.number(),
    sixMonth: z.number(),
    twelveMonth: z.number()
  })
})

// Type exports
export type CreateSubscriptionInput = z.infer<typeof createSubscriptionSchema>
export type CheckSubscriptionInput = z.infer<typeof checkSubscriptionSchema>
export type SubscriptionParams = z.infer<typeof subscriptionParamsSchema>
export type SubscriptionStudentParams = z.infer<typeof subscriptionStudentParamsSchema>
export type SubscriptionCourseParams = z.infer<typeof subscriptionCourseParamsSchema>
export type SubscriptionCheckParams = z.infer<typeof subscriptionCheckParamsSchema>
export type SubscriptionQuery = z.infer<typeof subscriptionQuerySchema>
export type SubscriptionResponse = z.infer<typeof subscriptionResponseSchema>
export type SubscriptionStatusResponse = z.infer<typeof subscriptionStatusResponseSchema>
export type SubscriptionStatsResponse = z.infer<typeof subscriptionStatsResponseSchema>


================================================
File: src/entities/subscription/subscription.service.ts
================================================
import { PrismaClient, Prisma, PaymentStatus, CreditTransactionType, CreditTransactionSource } from '@prisma/client'
import { CreateSubscriptionInput } from './subscription.schema'

export class SubscriptionService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateSubscriptionInput) {
    // Verify the student exists
    const student = await this.prisma.student.findUnique({
      where: { id: data.studentId }
    })

    if (!student) {
      throw new Error('Student not found')
    }

    // Verify the course exists and get pricing/credit info
    const course = await this.prisma.course.findUnique({
      where: { id: data.courseId },
      include: {
        exam: true
      }
    })

    if (!course) {
      throw new Error('Course not found')
    }

    if (!course.isPublished) {
      throw new Error('Course is not published')
    }

    // Check if student already has an active subscription to this course
    const existingActiveSubscription = await this.checkActiveSubscription(data.studentId, data.courseId)
    if (existingActiveSubscription) {
      throw new Error('Student already has an active subscription to this course')
    }

    // Get pricing and credits based on duration
    const pricing = this.getCoursePricing(course, data.durationMonths)
    
    // Calculate subscription dates
    const startDate = new Date()
    const endDate = new Date()
    endDate.setMonth(endDate.getMonth() + data.durationMonths)

    // Create subscription with payment and complimentary credits in a transaction
    return await this.prisma.$transaction(async (tx: Prisma.TransactionClient) => {
      // Create mock payment record
      const payment = await tx.payment.create({
        data: {
          studentId: data.studentId,
          stripePaymentId: data.mockPaymentId,
          amount: pricing.price,
          currency: 'USD',
          paymentType: 'SUBSCRIPTION',
          paymentStatus: PaymentStatus.COMPLETED,
          courseId: data.courseId,
          subscriptionDuration: data.durationMonths,
          creditsAmount: null // Credits are tracked separately
        }
      })

      // Create subscription
      const subscription = await tx.subscription.create({
        data: {
          studentId: data.studentId,
          courseId: data.courseId,
          paymentId: payment.id,
          durationMonths: data.durationMonths,
          startDate: startDate,
          endDate: endDate,
          isActive: true
        },
        include: {
          course: {
            include: {
              exam: {
                select: {
                  id: true,
                  title: true,
                  slug: true
                }
              }
            }
          },
          student: {
            select: {
              id: true,
              firstName: true,
              lastName: true
            }
          }
        }
      })

      // Add complimentary credits
      await tx.student.update({
        where: { id: data.studentId },
        data: {
          creditBalance: {
            increment: pricing.credits
          }
        }
      })

      // Create credit transaction record
      await tx.creditTransaction.create({
        data: {
          studentId: data.studentId,
          transactionType: CreditTransactionType.CREDIT,
          amount: pricing.credits,
          balanceAfter: student.creditBalance + pricing.credits,
          sourceType: CreditTransactionSource.SUBSCRIPTION,
          sourceId: subscription.id,
          description: `Complimentary credits for ${data.durationMonths}-month subscription to ${course.title}`,
          expiresAt: endDate // Credits expire with subscription
        }
      })

      return subscription
    })
  }

  async findAll(query?: { active?: boolean; includeExpired?: boolean }) {
    const where: any = {}
    
    if (query?.active !== undefined) {
      where.isActive = query.active
    }
    
    if (!query?.includeExpired) {
      where.endDate = { gte: new Date() }
    }

    return await this.prisma.subscription.findMany({
      where,
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true
          }
        },
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async findById(id: string) {
    const subscription = await this.prisma.subscription.findUnique({
      where: { id },
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true
          }
        },
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        }
      }
    })

    if (!subscription) {
      throw new Error('Subscription not found')
    }

    return subscription
  }

  async findByStudent(studentId: string, query?: { active?: boolean; includeExpired?: boolean }) {
    // Verify student exists
    const student = await this.prisma.student.findUnique({
      where: { id: studentId }
    })

    if (!student) {
      throw new Error('Student not found')
    }

    const where: any = { studentId }
    
    if (query?.active !== undefined) {
      where.isActive = query.active
    }
    
    if (!query?.includeExpired) {
      where.endDate = { gte: new Date() }
    }

    const subscriptions = await this.prisma.subscription.findMany({
      where,
      include: {
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        }
      },
      orderBy: {
        endDate: 'desc'
      }
    })

    // Update isActive status based on dates
    return subscriptions.map((sub:any) => ({
      ...sub,
      isActive: this.isSubscriptionActive(sub)
    }))
  }

  async findByCourse(courseId: string, query?: { active?: boolean }) {
    // Verify course exists
    const course = await this.prisma.course.findUnique({
      where: { id: courseId }
    })

    if (!course) {
      throw new Error('Course not found')
    }

    const where: any = { courseId }
    
    if (query?.active !== undefined) {
      where.isActive = query.active
    } else {
      // Default to only active subscriptions
      where.endDate = { gte: new Date() }
    }

    return await this.prisma.subscription.findMany({
      where,
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async checkSubscription(studentId: string, courseId: string) {
    const subscription = await this.prisma.subscription.findFirst({
      where: {
        studentId,
        courseId,
        endDate: { gte: new Date() }
      },
      include: {
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        }
      }
    })

    if (!subscription) {
      return {
        hasActiveSubscription: false,
        subscription: undefined,
        daysRemaining: 0,
        isExpired: true
      }
    }

    const daysRemaining = Math.ceil((subscription.endDate.getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24))
    const isActive = this.isSubscriptionActive(subscription)

    return {
      hasActiveSubscription: isActive,
      subscription: {
        ...subscription,
        isActive
      },
      daysRemaining: daysRemaining > 0 ? daysRemaining : 0,
      isExpired: !isActive
    }
  }

  async checkActiveSubscription(studentId: string, courseId: string): Promise<boolean> {
    const result = await this.checkSubscription(studentId, courseId)
    return result.hasActiveSubscription
  }

  async getStudentStats(studentId: string) {
    // Verify student exists
    const student = await this.prisma.student.findUnique({
      where: { id: studentId }
    })

    if (!student) {
      throw new Error('Student not found')
    }

    const subscriptions = await this.prisma.subscription.findMany({
      where: { studentId }
    })

    const now = new Date()
    const activeSubscriptions = subscriptions.filter((sub:any) => 
      sub.endDate >= now && sub.startDate <= now
    )

    const expiredSubscriptions = subscriptions.filter((sub:any) => 
      sub.endDate < now
    )

    // Get total credits received from subscriptions
    const creditTransactions = await this.prisma.creditTransaction.findMany({
      where: {
        studentId,
        sourceType: CreditTransactionSource.SUBSCRIPTION,
        transactionType: CreditTransactionType.CREDIT
      }
    })

    const totalCreditsReceived = creditTransactions.reduce((sum:any, t:any) => sum + t.amount, 0)

    // Count by duration
    const subscriptionsByDuration = {
      threeMonth: subscriptions.filter((s:any) => s.durationMonths === 3).length,
      sixMonth: subscriptions.filter((s:any) => s.durationMonths === 6).length,
      twelveMonth: subscriptions.filter((s:any) => s.durationMonths === 12).length
    }

    return {
      studentId,
      totalSubscriptions: subscriptions.length,
      activeSubscriptions: activeSubscriptions.length,
      expiredSubscriptions: expiredSubscriptions.length,
      totalCreditsReceived,
      subscriptionsByDuration
    }
  }

  async updateSubscriptionStatus() {
    // This method can be called periodically to update isActive status
    const now = new Date()
    
    // Deactivate expired subscriptions
    await this.prisma.subscription.updateMany({
      where: {
        endDate: { lt: now },
        isActive: true
      },
      data: {
        isActive: false
      }
    })

    // Activate subscriptions that should be active
    await this.prisma.subscription.updateMany({
      where: {
        startDate: { lte: now },
        endDate: { gte: now },
        isActive: false
      },
      data: {
        isActive: true
      }
    })
  }

  // Helper methods

  private getCoursePricing(course: any, durationMonths: number) {
    switch (durationMonths) {
      case 3:
        return {
          price: course.price3Months,
          credits: course.credits3Months
        }
      case 6:
        return {
          price: course.price6Months,
          credits: course.credits6Months
        }
      case 12:
        return {
          price: course.price12Months,
          credits: course.credits12Months
        }
      default:
        throw new Error('Invalid subscription duration')
    }
  }

  private isSubscriptionActive(subscription: any): boolean {
    const now = new Date()
    return subscription.startDate <= now && subscription.endDate >= now
  }

  // Method to check if student can access course content
  async canAccessCourseContent(studentId: string, courseId: string): Promise<boolean> {
    // Check if the course case is free first
    const courseCase = await this.prisma.courseCase.findFirst({
      where: { courseId }
    })

    if (courseCase?.isFree) {
      return true // Free content is always accessible
    }

    // Check subscription
    return await this.checkActiveSubscription(studentId, courseId)
  }

  // Method to get all courses a student has access to
  async getAccessibleCourses(studentId: string) {
    const activeSubscriptions = await this.findByStudent(studentId, { active: true })
    
    const subscribedCourseIds = activeSubscriptions.map((sub:any) => sub.courseId)
    
    // Also get courses with free content
    const coursesWithFreeContent = await this.prisma.course.findMany({
      where: {
        courseCases: {
          some: {
            isFree: true
          }
        },
        isPublished: true
      },
      select: {
        id: true
      }
    })

    const freeCourseIds = coursesWithFreeContent.map((c:any) => c.id)
    
    // Combine and deduplicate
    const accessibleCourseIds = [...new Set([...subscribedCourseIds, ...freeCourseIds])]
    
    return accessibleCourseIds
  }
}


================================================
File: src/middleware/auth.middleware.ts
================================================
import { FastifyRequest, FastifyReply } from 'fastify'
import { JWTPayload } from '../entities/auth/auth.schema'

// Extend FastifyJWT interface instead of FastifyRequest
declare module '@fastify/jwt' {
  interface FastifyJWT {
    payload: JWTPayload
    user: JWTPayload
  }
}

// Add custom properties to FastifyRequest
declare module 'fastify' {
  interface FastifyRequest {
    userType?: 'student' | 'instructor'
  }
}

// Auth middleware - verifies JWT and attaches user to request
export async function authenticate(request: FastifyRequest, reply: FastifyReply) {
  try {
    await request.jwtVerify()
    
    // The JWT payload is automatically attached to request.user by fastify-jwt
    const user = request.user as JWTPayload
    request.userType = user.userType
  } catch (err) {
    reply.status(401).send({ error: 'Unauthorized' })
  }
}

// Role-based middleware - checks if user has required role
export function requireRole(role: 'student' | 'instructor') {
  return async function (request: FastifyRequest, reply: FastifyReply) {
    const user = request.user as JWTPayload | undefined
    
    if (!user) {
      reply.status(401).send({ error: 'Unauthorized' })
      return
    }

    if (request.userType !== role) {
      reply.status(403).send({ error: `Access denied. ${role} role required.` })
      return
    }
  }
}

// Combined auth middleware that requires authentication and specific role
export function requireAuth(role?: 'student' | 'instructor') {
  return async function (request: FastifyRequest, reply: FastifyReply) {
    // First authenticate
    await authenticate(request, reply)
    
    // If authentication passed and role is specified, check role
    if (role && request.user) {
      await requireRole(role)(request, reply)
    }
  }
}

// Optional auth middleware - attaches user if token is valid, but doesn't fail if not
export async function optionalAuth(request: FastifyRequest, reply: FastifyReply) {
  try {
    await request.jwtVerify()
    const user = request.user as JWTPayload
    request.userType = user.userType
  } catch (err) {
    // Don't fail, just continue without user
    request.userType = undefined
  }
}

// Helper to get current user ID
export function getCurrentUserId(request: FastifyRequest): number | null {
  const user = request.user as JWTPayload | undefined
  return user?.userId || null
}

// Helper to get current student ID
export function getCurrentStudentId(request: FastifyRequest): string | null {
  const user = request.user as JWTPayload | undefined
  if (request.userType === 'student' && user?.studentId) {
    return user.studentId
  }
  return null
}

// Helper to get current instructor ID
export function getCurrentInstructorId(request: FastifyRequest): string | null {
  const user = request.user as JWTPayload | undefined
  if (request.userType === 'instructor' && user?.instructorId) {
    return user.instructorId
  }
  return null
}


================================================
File: src/shared/junction-tables.schema.ts
================================================
// junction-tables.schema.ts
import { z } from 'zod'
import { PatientGenderEnum } from '../entities/course-case/course-case.schema'

// ===== COURSE CASE JUNCTION SCHEMAS =====

// Assign Specialties Schema
export const assignSpecialtiesSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  specialtyIds: z.array(z.string().uuid('Invalid specialty ID'))
    .min(1, 'At least one specialty is required')
    .max(10, 'Cannot assign more than 10 specialties')
})

// Assign Curriculums Schema  
export const assignCurriculumsSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  curriculumIds: z.array(z.string().uuid('Invalid curriculum ID'))
    .min(1, 'At least one curriculum item is required')
    .max(15, 'Cannot assign more than 15 curriculum items')
})

// Filter Cases Schema
export const filterCasesSchema = z.object({
  courseId: z.string().uuid('Invalid course ID'),
  specialtyIds: z.array(z.string().uuid('Invalid specialty ID')).optional(),
  curriculumIds: z.array(z.string().uuid('Invalid curriculum ID')).optional(),
  isFree: z.boolean().optional(),
  patientGender: PatientGenderEnum.optional()
})

// Bulk Assignment Schema
export const bulkAssignFiltersSchema = z.object({
  assignments: z.array(z.object({
    courseCaseId: z.string().uuid('Invalid course case ID'),
    specialtyIds: z.array(z.string().uuid('Invalid specialty ID')).optional(),
    curriculumIds: z.array(z.string().uuid('Invalid curriculum ID')).optional()
  })).min(1, 'At least one assignment is required').max(50, 'Cannot process more than 50 assignments at once')
})

// Remove Assignment Schemas
export const removeSpecialtySchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  specialtyId: z.string().uuid('Invalid specialty ID')
})

export const removeCurriculumSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  curriculumId: z.string().uuid('Invalid curriculum ID')
})

// URL Params Schemas
export const courseCaseParamsSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID')
})

export const courseParamsSchema = z.object({
  courseId: z.string().uuid('Invalid course ID')
})

export const specialtyRemoveParamsSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  specialtyId: z.string().uuid('Invalid specialty ID')
})

export const curriculumRemoveParamsSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  curriculumId: z.string().uuid('Invalid curriculum ID')
})

// Query Params Schema (for filtering)
export const filterQuerySchema = z.object({
  specialtyIds: z.string().optional().transform((val) => 
    val ? val.split(',').filter(id => id.trim().length > 0) : undefined
  ),
  curriculumIds: z.string().optional().transform((val) => 
    val ? val.split(',').filter(id => id.trim().length > 0) : undefined
  ),
  isFree: z.string().optional().transform((val) => 
    val === 'true' ? true : val === 'false' ? false : undefined
  ),
  patientGender: z.string().optional().refine((val) => 
    !val || ['MALE', 'FEMALE', 'OTHER'].includes(val), 'Invalid patient gender'
  ).transform((val) => val as 'MALE' | 'FEMALE' | 'OTHER' | undefined)
})

// Response Schemas
export const caseWithFiltersResponseSchema = z.object({
  id: z.string(),
  courseId: z.string(),
  title: z.string(),
  diagnosis: z.string(),
  patientName: z.string(),
  patientAge: z.number(),
  patientGender: PatientGenderEnum,
  description: z.string(),
  isFree: z.boolean(),
  displayOrder: z.number(),
  createdAt: z.date(),
  updatedAt: z.date(),
  specialties: z.array(z.object({
    id: z.string(),
    name: z.string()
  })),
  curriculums: z.array(z.object({
    id: z.string(),
    name: z.string()
  })),
  course: z.object({
    id: z.string(),
    title: z.string(),
    exam: z.object({
      id: z.string(),
      title: z.string(),
      slug: z.string()
    })
  })
})

export const filteringStatsResponseSchema = z.object({
  courseId: z.string(),
  totalCases: z.number(),
  specialtyDistribution: z.array(z.object({
    specialtyId: z.string(),
    count: z.number(),
    specialty: z.object({
      id: z.string(),
      name: z.string()
    })
  })),
  curriculumDistribution: z.array(z.object({
    curriculumId: z.string(),
    count: z.number(),
    curriculum: z.object({
      id: z.string(),
      name: z.string()
    })
  }))
})

// ===== EXAM JUNCTION SCHEMAS =====

// Assign Specialties to Exam Schema
export const assignExamSpecialtiesSchema = z.object({
  examId: z.string().uuid('Invalid exam ID'),
  specialtyIds: z.array(z.string().uuid('Invalid specialty ID'))
    .min(1, 'At least one specialty is required')
    .max(20, 'Cannot assign more than 20 specialties')
})

// Assign Curriculums to Exam Schema  
export const assignExamCurriculumsSchema = z.object({
  examId: z.string().uuid('Invalid exam ID'),
  curriculumIds: z.array(z.string().uuid('Invalid curriculum ID'))
    .min(1, 'At least one curriculum item is required')
    .max(30, 'Cannot assign more than 30 curriculum items')
})

// Assign Marking Domains to Exam Schema
export const assignExamMarkingDomainsSchema = z.object({
  examId: z.string().uuid('Invalid exam ID'),
  markingDomainIds: z.array(z.string().uuid('Invalid marking domain ID'))
    .min(1, 'At least one marking domain is required')
    .max(15, 'Cannot assign more than 15 marking domains')
})

// Bulk Configuration Schema
export const bulkConfigureExamSchema = z.object({
  examId: z.string().uuid('Invalid exam ID'),
  specialtyIds: z.array(z.string().uuid('Invalid specialty ID')).optional(),
  curriculumIds: z.array(z.string().uuid('Invalid curriculum ID')).optional(),
  markingDomainIds: z.array(z.string().uuid('Invalid marking domain ID')).optional()
}).refine(
  (data) => data.specialtyIds || data.curriculumIds || data.markingDomainIds,
  { message: 'At least one assignment type must be provided' }
)

// URL Params Schemas for Exam Removal Operations
export const examRemoveSpecialtyParamsSchema = z.object({
  examId: z.string().uuid('Invalid exam ID'),
  specialtyId: z.string().uuid('Invalid specialty ID')
})

export const examRemoveCurriculumParamsSchema = z.object({
  examId: z.string().uuid('Invalid exam ID'),
  curriculumId: z.string().uuid('Invalid curriculum ID')
})

export const examRemoveMarkingDomainParamsSchema = z.object({
  examId: z.string().uuid('Invalid exam ID'),
  markingDomainId: z.string().uuid('Invalid marking domain ID')
})

// Exam Response Schemas
export const examConfigurationResponseSchema = z.object({
  exam: z.object({
    id: z.string(),
    title: z.string(),
    slug: z.string(),
    description: z.string().nullable(),
    isActive: z.boolean()
  }),
  configuration: z.object({
    specialties: z.array(z.object({
      id: z.string(),
      name: z.string(),
      description: z.string().optional()
    })),
    curriculums: z.array(z.object({
      id: z.string(),
      name: z.string(),
      description: z.string().optional()
    })),
    markingDomains: z.array(z.object({
      id: z.string(),
      name: z.string(),
      description: z.string().optional()
    }))
  }),
  summary: z.object({
    specialtiesCount: z.number(),
    curriculumsCount: z.number(),
    markingDomainsCount: z.number(),
    isFullyConfigured: z.boolean()
  })
})

export const examUsageStatsResponseSchema = z.object({
  examId: z.string(),
  examTitle: z.string(),
  usage: z.object({
    coursesCount: z.number(),
    casesCount: z.number(),
    simulationsCount: z.number()
  }),
  configuration: z.object({
    specialtiesCount: z.number(),
    curriculumsCount: z.number(),
    markingDomainsCount: z.number()
  })
})

// ===== TYPE EXPORTS =====

// Course Case Types
export type AssignSpecialtiesInput = z.infer<typeof assignSpecialtiesSchema>
export type AssignCurriculumsInput = z.infer<typeof assignCurriculumsSchema>
export type FilterCasesInput = z.infer<typeof filterCasesSchema>
export type BulkAssignFiltersInput = z.infer<typeof bulkAssignFiltersSchema>
export type RemoveSpecialtyInput = z.infer<typeof removeSpecialtySchema>
export type RemoveCurriculumInput = z.infer<typeof removeCurriculumSchema>
export type CourseCaseParams = z.infer<typeof courseCaseParamsSchema>
export type CourseParams = z.infer<typeof courseParamsSchema>
export type SpecialtyRemoveParams = z.infer<typeof specialtyRemoveParamsSchema>
export type CurriculumRemoveParams = z.infer<typeof curriculumRemoveParamsSchema>
export type FilterQuery = z.infer<typeof filterQuerySchema>
export type CaseWithFiltersResponse = z.infer<typeof caseWithFiltersResponseSchema>
export type FilteringStatsResponse = z.infer<typeof filteringStatsResponseSchema>

// Exam Types
export type AssignExamSpecialtiesInput = z.infer<typeof assignExamSpecialtiesSchema>
export type AssignExamCurriculumsInput = z.infer<typeof assignExamCurriculumsSchema>
export type AssignExamMarkingDomainsInput = z.infer<typeof assignExamMarkingDomainsSchema>
export type BulkConfigureExamInput = z.infer<typeof bulkConfigureExamSchema>
export type ExamRemoveSpecialtyParams = z.infer<typeof examRemoveSpecialtyParamsSchema>
export type ExamRemoveCurriculumParams = z.infer<typeof examRemoveCurriculumParamsSchema>
export type ExamRemoveMarkingDomainParams = z.infer<typeof examRemoveMarkingDomainParamsSchema>
export type ExamConfigurationResponse = z.infer<typeof examConfigurationResponseSchema>
export type ExamUsageStatsResponse = z.infer<typeof examUsageStatsResponseSchema>


================================================
File: src/shared/types.ts
================================================
import { PrismaClient } from '@prisma/client'

declare module 'fastify' {
  interface FastifyInstance {
    prisma: PrismaClient
  }
}


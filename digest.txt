Directory structure:
â””â”€â”€ mvp-backend/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ package.json
    â”œâ”€â”€ tsconfig.json
    â”œâ”€â”€ logs/
    â”œâ”€â”€ prisma/
    â”‚   â”œâ”€â”€ schema.prisma
    â”‚   â””â”€â”€ migrations/
    â”‚       â”œâ”€â”€ migration_lock.toml
    â”‚       â”œâ”€â”€ 20250918122015_initial/
    â”‚       â”‚   â””â”€â”€ migration.sql
    â”‚       â””â”€â”€ 20250920113010_add_minutes_billed_to_simulation_attempts/
    â”‚           â””â”€â”€ migration.sql
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ server.ts
    â”‚   â”œâ”€â”€ entities/
    â”‚   â”‚   â”œâ”€â”€ auth/
    â”‚   â”‚   â”‚   â”œâ”€â”€ auth.routes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ auth.schema.ts
    â”‚   â”‚   â”‚   â””â”€â”€ auth.service.ts
    â”‚   â”‚   â”œâ”€â”€ billing/
    â”‚   â”‚   â”‚   â”œâ”€â”€ billing.routes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ billing.schema.ts
    â”‚   â”‚   â”‚   â””â”€â”€ billing.service.ts
    â”‚   â”‚   â”œâ”€â”€ case-tab/
    â”‚   â”‚   â”‚   â”œâ”€â”€ case-tab.routes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ case-tab.schema.ts
    â”‚   â”‚   â”‚   â””â”€â”€ case-tab.service.ts
    â”‚   â”‚   â”œâ”€â”€ course/
    â”‚   â”‚   â”‚   â”œâ”€â”€ course.routes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ course.schema.ts
    â”‚   â”‚   â”‚   â””â”€â”€ course.service.ts
    â”‚   â”‚   â”œâ”€â”€ course-case/
    â”‚   â”‚   â”‚   â”œâ”€â”€ course-case.routes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ course-case.schema.ts
    â”‚   â”‚   â”‚   â””â”€â”€ course-case.service.ts
    â”‚   â”‚   â”œâ”€â”€ curriculum/
    â”‚   â”‚   â”‚   â”œâ”€â”€ curriculum.routes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ curriculum.schema.ts
    â”‚   â”‚   â”‚   â””â”€â”€ curriculum.service.ts
    â”‚   â”‚   â”œâ”€â”€ exam/
    â”‚   â”‚   â”‚   â”œâ”€â”€ exam.routes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ exam.schema.ts
    â”‚   â”‚   â”‚   â””â”€â”€ exam.service.ts
    â”‚   â”‚   â”œâ”€â”€ instructor/
    â”‚   â”‚   â”‚   â”œâ”€â”€ instructor.routes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ instructor.schema.ts
    â”‚   â”‚   â”‚   â””â”€â”€ instructor.service.ts
    â”‚   â”‚   â”œâ”€â”€ marking-criterion/
    â”‚   â”‚   â”‚   â”œâ”€â”€ marking-criterion.routes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ marking-criterion.schema.ts
    â”‚   â”‚   â”‚   â””â”€â”€ marking-criterion.service.ts
    â”‚   â”‚   â”œâ”€â”€ marking-domain/
    â”‚   â”‚   â”‚   â”œâ”€â”€ marking-domain.routes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ marking-domain.schema.ts
    â”‚   â”‚   â”‚   â””â”€â”€ marking-domain.service.ts
    â”‚   â”‚   â”œâ”€â”€ payment/
    â”‚   â”‚   â”‚   â”œâ”€â”€ payment.routes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ payment.schema.ts
    â”‚   â”‚   â”‚   â””â”€â”€ payment.service.ts
    â”‚   â”‚   â”œâ”€â”€ simulation/
    â”‚   â”‚   â”‚   â”œâ”€â”€ simulation.routes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ simulation.schema.ts
    â”‚   â”‚   â”‚   â””â”€â”€ simulation.service.ts
    â”‚   â”‚   â”œâ”€â”€ simulation-attempt/
    â”‚   â”‚   â”‚   â”œâ”€â”€ ai-feedback.service.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ simulation-attempt.routes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ simulation-attempt.schema.ts
    â”‚   â”‚   â”‚   â””â”€â”€ simulation-attempt.service.ts
    â”‚   â”‚   â”œâ”€â”€ specialty/
    â”‚   â”‚   â”‚   â”œâ”€â”€ specialty.routes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ specialty.schema.ts
    â”‚   â”‚   â”‚   â””â”€â”€ specialty.service.ts
    â”‚   â”‚   â”œâ”€â”€ student/
    â”‚   â”‚   â”‚   â”œâ”€â”€ student.routes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ student.schema.ts
    â”‚   â”‚   â”‚   â””â”€â”€ student.service.ts
    â”‚   â”‚   â””â”€â”€ subscription/
    â”‚   â”‚       â”œâ”€â”€ subscription.routes.ts
    â”‚   â”‚       â”œâ”€â”€ subscription.schema.ts
    â”‚   â”‚       â””â”€â”€ subscription.service.ts
    â”‚   â”œâ”€â”€ middleware/
    â”‚   â”‚   â””â”€â”€ auth.middleware.ts
    â”‚   â”œâ”€â”€ services/
    â”‚   â”‚   â””â”€â”€ voice-token.service.ts
    â”‚   â””â”€â”€ shared/
    â”‚       â”œâ”€â”€ junction-tables.schema.ts
    â”‚       â””â”€â”€ types.ts
    â””â”€â”€ test/

================================================
File: README.md
================================================
MVP-BACKEND


# 1. Link to your Railway project (if not already linked)
railway link

# 2. Set your database connection
railway variables --set DATABASE_URL="postgresql://postgres:IBdHmFwKDoDzMYEyVyhuYBwgdaWayUiJ@caboose.proxy.rlwy.net:55655/railway"

# 3. Set environment
railway variables --set NODE_ENV="production"

# 4. Deploy your app
railway up



# Run migrations on Railway
railway run npx prisma migrate deploy

# Or if that doesn't work, try:
railway run npx prisma db push


# Check your variables are set
railway variables

# Check deployment logs
railway logs

Reset Database:
Local: Stop prisma dev and restart
Production:
railway run npx prisma migrate reset
railway run npx prisma migrate deploy


View Database:
Local: npx prisma studio
Production: railway run npx prisma studio


npx prisma migrate dev --name add-curriculum





================================================
File: package.json
================================================
{
  "name": "mvp-backend",
  "version": "1.0.0",
  "description": "MVP-BACKEND",
  "main": "index.js",
  "scripts": {
    "dev": "nodemon --exec ts-node src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "postinstall": "prisma generate",
    "db:migrate": "npx prisma migrate deploy",
    "db:generate": "npx prisma generate"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/MHGanainy/mvp-backend.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/MHGanainy/mvp-backend/issues"
  },
  "homepage": "https://github.com/MHGanainy/mvp-backend#readme",
  "dependencies": {
    "@fastify/cors": "^11.0.1",
    "@fastify/helmet": "^13.0.1",
    "@fastify/jwt": "^9.1.0",
    "@fastify/rate-limit": "^10.3.0",
    "@fastify/swagger": "^9.5.1",
    "@fastify/swagger-ui": "^5.2.3",
    "@prisma/client": "^6.11.1",
    "bcryptjs": "^3.0.2",
    "fastify": "^5.4.0",
    "fastify-type-provider-zod": "^5.0.2",
    "jsonwebtoken": "^9.0.2",
    "openai": "^5.11.0",
    "pino-pretty": "^13.0.0",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/node": "^24.0.10",
    "nodemon": "^3.1.10",
    "prisma": "^6.11.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.8.3"
  }
}



================================================
File: tsconfig.json
================================================
{
    "compilerOptions": {
      "target": "ES2020",
      "module": "commonjs",
      "lib": ["ES2020"],
      "outDir": "./dist",
      "rootDir": "./src",
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules", "dist"]
  }



================================================
File: prisma/schema.prisma
================================================
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            Int         @id @default(autoincrement())
  email         String      @unique
  name          String?
  createdAt     DateTime    @default(now()) @map("created_at")
  emailVerified Boolean     @default(true) @map("email_verified")
  passwordHash  String?     @map("password_hash")
  updatedAt     DateTime    @updatedAt @map("updated_at")
  instructor    Instructor?
  student       Student?

  @@map("users")
}

model Instructor {
  id        String   @id @default(uuid())
  userId    Int      @unique @map("user_id")
  firstName String   @map("first_name")
  lastName  String   @map("last_name")
  bio       String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  courses   Course[]
  exams     Exam[]
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("instructors")
}

model Student {
  id                 String              @id @default(uuid())
  userId             Int                 @unique @map("user_id")
  firstName          String              @map("first_name")
  lastName           String              @map("last_name")
  dateOfBirth        DateTime            @map("date_of_birth") @db.Date
  creditBalance      Int                 @default(0) @map("credit_balance")
  createdAt          DateTime            @default(now()) @map("created_at")
  updatedAt          DateTime            @updatedAt @map("updated_at")
  creditTransactions CreditTransaction[]
  payments           Payment[]
  simulationAttempts SimulationAttempt[]
  user               User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscriptions      Subscription[]

  @@map("students")
}

model Exam {
  id                 String              @id @default(uuid())
  instructorId       String              @map("instructor_id")
  title              String
  slug               String              @unique
  description        String?
  isActive           Boolean             @default(true) @map("is_active")
  createdAt          DateTime            @default(now()) @map("created_at")
  updatedAt          DateTime            @updatedAt @map("updated_at")
  courses            Course[]
  examCurriculums    ExamCurriculum[]
  examMarkingDomains ExamMarkingDomain[]
  examSpecialties    ExamSpecialty[]
  instructor         Instructor          @relation(fields: [instructorId], references: [id], onDelete: Restrict)

  @@map("exams")
}

model Course {
  id              String         @id @default(uuid())
  examId          String         @map("exam_id")
  instructorId    String         @map("instructor_id")
  title           String
  description     String?
  style           CourseStyle    @default(RANDOM)
  price3Months    Decimal        @map("price_3_months") @db.Decimal(10, 2)
  price6Months    Decimal        @map("price_6_months") @db.Decimal(10, 2)
  price12Months   Decimal        @map("price_12_months") @db.Decimal(10, 2)
  credits3Months  Int            @map("credits_3_months")
  credits6Months  Int            @map("credits_6_months")
  credits12Months Int            @map("credits_12_months")
  isPublished     Boolean        @default(false) @map("is_published")
  createdAt       DateTime       @default(now()) @map("created_at")
  updatedAt       DateTime       @updatedAt @map("updated_at")
  infoPoints      String[]       @default([]) @map("info_points")
  courseCases     CourseCase[]
  exam            Exam           @relation(fields: [examId], references: [id], onDelete: Cascade)
  instructor      Instructor     @relation(fields: [instructorId], references: [id], onDelete: Restrict)
  subscriptions   Subscription[]

  @@map("courses")
}

model CourseCase {
  id              String             @id @default(uuid())
  courseId        String             @map("course_id")
  title           String
  diagnosis       String
  patientName     String             @map("patient_name")
  patientAge      Int                @map("patient_age")
  patientGender   PatientGender      @map("patient_gender")
  description     String
  isFree          Boolean            @default(false) @map("is_free")
  displayOrder    Int                @map("display_order")
  createdAt       DateTime           @default(now()) @map("created_at")
  updatedAt       DateTime           @updatedAt @map("updated_at")
  caseCurriculums CaseCurriculum[]
  caseSpecialties CaseSpecialty[]
  caseTabs        CaseTab[]
  course          Course             @relation(fields: [courseId], references: [id], onDelete: Cascade)
  simulation      Simulation?
  markingCriteria MarkingCriterion[] // Relation to the new model

  @@map("course_cases")
}

model MarkingCriterion {
  id              String        @id @default(uuid())
  courseCaseId    String        @map("course_case_id")
  markingDomainId String        @map("marking_domain_id")
  text            String
  points          Int           @default(0)
  displayOrder    Int           @map("display_order")
  createdAt       DateTime      @default(now()) @map("created_at")
  courseCase      CourseCase    @relation(fields: [courseCaseId], references: [id], onDelete: Cascade)
  markingDomain   MarkingDomain @relation(fields: [markingDomainId], references: [id], onDelete: Cascade)

  @@map("marking_criteria")
}

model CaseTab {
  id           String      @id @default(uuid())
  courseCaseId String      @map("course_case_id")
  tabType      CaseTabType @map("tab_type")
  createdAt    DateTime    @default(now()) @map("created_at")
  updatedAt    DateTime    @updatedAt @map("updated_at")
  content      String[]    @default([])
  courseCase   CourseCase  @relation(fields: [courseCaseId], references: [id], onDelete: Cascade)

  @@unique([courseCaseId, tabType])
  @@map("case_tabs")
}

model Simulation {
  id                 String              @id @default(uuid())
  courseCaseId       String              @unique @map("course_case_id")
  casePrompt         String              @map("case_prompt")
  openingLine        String              @map("opening_line")
  timeLimitMinutes   Int                 @map("time_limit_minutes")
  voiceModel         VoiceModel          @map("voice_model")
  warningTimeMinutes Int?                @map("warning_time_minutes")
  creditCost         Int                 @default(1) @map("credit_cost")
  createdAt          DateTime            @default(now()) @map("created_at")
  updatedAt          DateTime            @updatedAt @map("updated_at")
  simulationAttempts SimulationAttempt[]
  courseCase         CourseCase          @relation(fields: [courseCaseId], references: [id], onDelete: Cascade)

  @@map("simulations")
}

model SimulationAttempt {
  id               String      @id @default(uuid())
  studentId        String      @map("student_id")
  simulationId     String      @map("simulation_id")
  startedAt        DateTime    @map("started_at")
  endedAt          DateTime?   @map("ended_at")
  durationSeconds  Int?        @map("duration_seconds")
  isCompleted      Boolean     @default(false) @map("is_completed")
  score            Decimal?    @db.Decimal(5, 2)
  aiFeedback       Json?       @map("ai_feedback")
  aiPrompt         Json?       @map("ai_prompt")
  transcript       Json?
  createdAt        DateTime    @default(now()) @map("created_at")
  simulation       Simulation  @relation(fields: [simulationId], references: [id], onDelete: Cascade)
  student          Student     @relation(fields: [studentId], references: [id], onDelete: Cascade)
  correlationToken String?     @unique
  minutesBilled    Int?        @default(0) @map("minutes_billed")

  @@map("simulation_attempts")
}

model Payment {
  id                   String        @id @default(uuid())
  studentId            String        @map("student_id")
  stripePaymentId      String        @unique @map("stripe_payment_id")
  amount               Decimal       @db.Decimal(10, 2)
  currency             String        @default("USD")
  paymentType          PaymentType   @map("payment_type")
  paymentStatus        PaymentStatus @map("payment_status")
  courseId             String?       @map("course_id")
  subscriptionDuration Int?          @map("subscription_duration")
  creditsAmount        Int?          @map("credits_amount")
  createdAt            DateTime      @default(now()) @map("created_at")
  student              Student       @relation(fields: [studentId], references: [id], onDelete: Cascade)
  subscription         Subscription?

  @@map("payments")
}

model Subscription {
  id             String   @id @default(uuid())
  studentId      String   @map("student_id")
  courseId       String   @map("course_id")
  paymentId      String   @unique @map("payment_id")
  durationMonths Int      @map("duration_months")
  startDate      DateTime @map("start_date") @db.Date
  endDate        DateTime @map("end_date") @db.Date
  isActive       Boolean  @map("is_active")
  createdAt      DateTime @default(now()) @map("created_at")
  course         Course   @relation(fields: [courseId], references: [id], onDelete: Restrict)
  payment        Payment  @relation(fields: [paymentId], references: [id])
  student        Student  @relation(fields: [studentId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

model CreditTransaction {
  id              String                  @id @default(uuid())
  studentId       String                  @map("student_id")
  transactionType CreditTransactionType   @map("transaction_type")
  amount          Int
  balanceAfter    Int                     @map("balance_after")
  sourceType      CreditTransactionSource @map("source_type")
  sourceId        String?                 @map("source_id")
  description     String?
  expiresAt       DateTime?               @map("expires_at")
  createdAt       DateTime                @default(now()) @map("created_at")
  student         Student                 @relation(fields: [studentId], references: [id], onDelete: Cascade)

  @@map("credit_transactions")
}

model Specialty {
  id              String          @id @default(uuid())
  name            String          @unique
  createdAt       DateTime        @default(now()) @map("created_at")
  caseSpecialties CaseSpecialty[]
  examSpecialties ExamSpecialty[]

  @@map("specialties")
}

model Curriculum {
  id              String           @id @default(uuid())
  name            String           @unique
  createdAt       DateTime         @default(now()) @map("created_at")
  caseCurriculums CaseCurriculum[]
  examCurriculums ExamCurriculum[]

  @@map("curriculums")
}

model MarkingDomain {
  id                 String              @id @default(uuid())
  name               String              @unique
  createdAt          DateTime            @default(now()) @map("created_at")
  examMarkingDomains ExamMarkingDomain[]
  markingCriteria    MarkingCriterion[] // Relation to the new model

  @@map("marking_domains")
}

model ExamSpecialty {
  examId      String    @map("exam_id")
  specialtyId String    @map("specialty_id")
  createdAt   DateTime  @default(now()) @map("created_at")
  exam        Exam      @relation(fields: [examId], references: [id], onDelete: Cascade)
  specialty   Specialty @relation(fields: [specialtyId], references: [id], onDelete: Cascade)

  @@id([examId, specialtyId])
  @@map("exam_specialties")
}

model ExamCurriculum {
  examId       String     @map("exam_id")
  curriculumId String     @map("curriculum_id")
  createdAt    DateTime   @default(now()) @map("created_at")
  curriculum   Curriculum @relation(fields: [curriculumId], references: [id], onDelete: Cascade)
  exam         Exam       @relation(fields: [examId], references: [id], onDelete: Cascade)

  @@id([examId, curriculumId])
  @@map("exam_curriculums")
}

model ExamMarkingDomain {
  examId          String        @map("exam_id")
  markingDomainId String        @map("marking_domain_id")
  createdAt       DateTime      @default(now()) @map("created_at")
  exam            Exam          @relation(fields: [examId], references: [id], onDelete: Cascade)
  markingDomain   MarkingDomain @relation(fields: [markingDomainId], references: [id], onDelete: Cascade)

  @@id([examId, markingDomainId])
  @@map("exam_marking_domains")
}

model CaseSpecialty {
  courseCaseId String    @map("course_case_id")
  specialtyId  String    @map("specialty_id")
  createdAt    DateTime  @default(now()) @map("created_at")
  courseCase   CourseCase @relation(fields: [courseCaseId], references: [id], onDelete: Cascade)
  specialty    Specialty @relation(fields: [specialtyId], references: [id], onDelete: Cascade)

  @@id([courseCaseId, specialtyId])
  @@map("case_specialties")
}

model CaseCurriculum {
  courseCaseId String     @map("course_case_id")
  curriculumId String     @map("curriculum_id")
  createdAt    DateTime   @default(now()) @map("created_at")
  courseCase   CourseCase @relation(fields: [courseCaseId], references: [id], onDelete: Cascade)
  curriculum   Curriculum @relation(fields: [curriculumId], references: [id], onDelete: Cascade)

  @@id([courseCaseId, curriculumId])
  @@map("case_curriculums")
}

enum CourseStyle {
  RANDOM
  STRUCTURED
}

enum PatientGender {
  MALE
  FEMALE
  OTHER
}

enum VoiceModel {
  VOICE_1
  VOICE_2
}
enum CaseTabType {
  DOCTORS_NOTE
  PATIENT_SCRIPT
  MEDICAL_NOTES
}

enum PaymentType {
  SUBSCRIPTION
  CREDITS
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
}

enum CreditTransactionType {
  CREDIT
  DEBIT
}

enum CreditTransactionSource {
  SUBSCRIPTION
  PURCHASE
  SIMULATION
  MANUAL
}


================================================
File: prisma/migrations/migration_lock.toml
================================================
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"



================================================
File: prisma/migrations/20250918122015_initial/migration.sql
================================================
-- CreateEnum
CREATE TYPE "CourseStyle" AS ENUM ('RANDOM', 'STRUCTURED');

-- CreateEnum
CREATE TYPE "PatientGender" AS ENUM ('MALE', 'FEMALE', 'OTHER');

-- CreateEnum
CREATE TYPE "VoiceModel" AS ENUM ('VOICE_1', 'VOICE_2');

-- CreateEnum
CREATE TYPE "CaseTabType" AS ENUM ('DOCTORS_NOTE', 'PATIENT_SCRIPT', 'MEDICAL_NOTES');

-- CreateEnum
CREATE TYPE "PaymentType" AS ENUM ('SUBSCRIPTION', 'CREDITS');

-- CreateEnum
CREATE TYPE "PaymentStatus" AS ENUM ('PENDING', 'COMPLETED', 'FAILED');

-- CreateEnum
CREATE TYPE "CreditTransactionType" AS ENUM ('CREDIT', 'DEBIT');

-- CreateEnum
CREATE TYPE "CreditTransactionSource" AS ENUM ('SUBSCRIPTION', 'PURCHASE', 'SIMULATION', 'MANUAL');

-- CreateTable
CREATE TABLE "users" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "email_verified" BOOLEAN NOT NULL DEFAULT true,
    "password_hash" TEXT,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "instructors" (
    "id" TEXT NOT NULL,
    "user_id" INTEGER NOT NULL,
    "first_name" TEXT NOT NULL,
    "last_name" TEXT NOT NULL,
    "bio" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "instructors_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "students" (
    "id" TEXT NOT NULL,
    "user_id" INTEGER NOT NULL,
    "first_name" TEXT NOT NULL,
    "last_name" TEXT NOT NULL,
    "date_of_birth" DATE NOT NULL,
    "credit_balance" INTEGER NOT NULL DEFAULT 0,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "students_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "exams" (
    "id" TEXT NOT NULL,
    "instructor_id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "slug" TEXT NOT NULL,
    "description" TEXT,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "exams_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "courses" (
    "id" TEXT NOT NULL,
    "exam_id" TEXT NOT NULL,
    "instructor_id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "style" "CourseStyle" NOT NULL DEFAULT 'RANDOM',
    "price_3_months" DECIMAL(10,2) NOT NULL,
    "price_6_months" DECIMAL(10,2) NOT NULL,
    "price_12_months" DECIMAL(10,2) NOT NULL,
    "credits_3_months" INTEGER NOT NULL,
    "credits_6_months" INTEGER NOT NULL,
    "credits_12_months" INTEGER NOT NULL,
    "is_published" BOOLEAN NOT NULL DEFAULT false,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "info_points" TEXT[] DEFAULT ARRAY[]::TEXT[],

    CONSTRAINT "courses_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "course_cases" (
    "id" TEXT NOT NULL,
    "course_id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "diagnosis" TEXT NOT NULL,
    "patient_name" TEXT NOT NULL,
    "patient_age" INTEGER NOT NULL,
    "patient_gender" "PatientGender" NOT NULL,
    "description" TEXT NOT NULL,
    "is_free" BOOLEAN NOT NULL DEFAULT false,
    "display_order" INTEGER NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "course_cases_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "marking_criteria" (
    "id" TEXT NOT NULL,
    "course_case_id" TEXT NOT NULL,
    "marking_domain_id" TEXT NOT NULL,
    "text" TEXT NOT NULL,
    "points" INTEGER NOT NULL DEFAULT 0,
    "display_order" INTEGER NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "marking_criteria_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "case_tabs" (
    "id" TEXT NOT NULL,
    "course_case_id" TEXT NOT NULL,
    "tab_type" "CaseTabType" NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "content" TEXT[] DEFAULT ARRAY[]::TEXT[],

    CONSTRAINT "case_tabs_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "simulations" (
    "id" TEXT NOT NULL,
    "course_case_id" TEXT NOT NULL,
    "case_prompt" TEXT NOT NULL,
    "opening_line" TEXT NOT NULL,
    "time_limit_minutes" INTEGER NOT NULL,
    "voice_model" "VoiceModel" NOT NULL,
    "warning_time_minutes" INTEGER,
    "credit_cost" INTEGER NOT NULL DEFAULT 1,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "simulations_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "simulation_attempts" (
    "id" TEXT NOT NULL,
    "student_id" TEXT NOT NULL,
    "simulation_id" TEXT NOT NULL,
    "started_at" TIMESTAMP(3) NOT NULL,
    "ended_at" TIMESTAMP(3),
    "duration_seconds" INTEGER,
    "is_completed" BOOLEAN NOT NULL DEFAULT false,
    "score" DECIMAL(5,2),
    "ai_feedback" JSONB,
    "ai_prompt" JSONB,
    "transcript" JSONB,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "correlationToken" TEXT,

    CONSTRAINT "simulation_attempts_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "payments" (
    "id" TEXT NOT NULL,
    "student_id" TEXT NOT NULL,
    "stripe_payment_id" TEXT NOT NULL,
    "amount" DECIMAL(10,2) NOT NULL,
    "currency" TEXT NOT NULL DEFAULT 'USD',
    "payment_type" "PaymentType" NOT NULL,
    "payment_status" "PaymentStatus" NOT NULL,
    "course_id" TEXT,
    "subscription_duration" INTEGER,
    "credits_amount" INTEGER,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "payments_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "subscriptions" (
    "id" TEXT NOT NULL,
    "student_id" TEXT NOT NULL,
    "course_id" TEXT NOT NULL,
    "payment_id" TEXT NOT NULL,
    "duration_months" INTEGER NOT NULL,
    "start_date" DATE NOT NULL,
    "end_date" DATE NOT NULL,
    "is_active" BOOLEAN NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "subscriptions_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "credit_transactions" (
    "id" TEXT NOT NULL,
    "student_id" TEXT NOT NULL,
    "transaction_type" "CreditTransactionType" NOT NULL,
    "amount" INTEGER NOT NULL,
    "balance_after" INTEGER NOT NULL,
    "source_type" "CreditTransactionSource" NOT NULL,
    "source_id" TEXT,
    "description" TEXT,
    "expires_at" TIMESTAMP(3),
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "credit_transactions_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "specialties" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "specialties_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "curriculums" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "curriculums_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "marking_domains" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "marking_domains_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "exam_specialties" (
    "exam_id" TEXT NOT NULL,
    "specialty_id" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "exam_specialties_pkey" PRIMARY KEY ("exam_id","specialty_id")
);

-- CreateTable
CREATE TABLE "exam_curriculums" (
    "exam_id" TEXT NOT NULL,
    "curriculum_id" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "exam_curriculums_pkey" PRIMARY KEY ("exam_id","curriculum_id")
);

-- CreateTable
CREATE TABLE "exam_marking_domains" (
    "exam_id" TEXT NOT NULL,
    "marking_domain_id" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "exam_marking_domains_pkey" PRIMARY KEY ("exam_id","marking_domain_id")
);

-- CreateTable
CREATE TABLE "case_specialties" (
    "course_case_id" TEXT NOT NULL,
    "specialty_id" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "case_specialties_pkey" PRIMARY KEY ("course_case_id","specialty_id")
);

-- CreateTable
CREATE TABLE "case_curriculums" (
    "course_case_id" TEXT NOT NULL,
    "curriculum_id" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "case_curriculums_pkey" PRIMARY KEY ("course_case_id","curriculum_id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "users"("email");

-- CreateIndex
CREATE UNIQUE INDEX "instructors_user_id_key" ON "instructors"("user_id");

-- CreateIndex
CREATE UNIQUE INDEX "students_user_id_key" ON "students"("user_id");

-- CreateIndex
CREATE UNIQUE INDEX "exams_slug_key" ON "exams"("slug");

-- CreateIndex
CREATE UNIQUE INDEX "case_tabs_course_case_id_tab_type_key" ON "case_tabs"("course_case_id", "tab_type");

-- CreateIndex
CREATE UNIQUE INDEX "simulations_course_case_id_key" ON "simulations"("course_case_id");

-- CreateIndex
CREATE UNIQUE INDEX "simulation_attempts_correlationToken_key" ON "simulation_attempts"("correlationToken");

-- CreateIndex
CREATE UNIQUE INDEX "payments_stripe_payment_id_key" ON "payments"("stripe_payment_id");

-- CreateIndex
CREATE UNIQUE INDEX "subscriptions_payment_id_key" ON "subscriptions"("payment_id");

-- CreateIndex
CREATE UNIQUE INDEX "specialties_name_key" ON "specialties"("name");

-- CreateIndex
CREATE UNIQUE INDEX "curriculums_name_key" ON "curriculums"("name");

-- CreateIndex
CREATE UNIQUE INDEX "marking_domains_name_key" ON "marking_domains"("name");

-- AddForeignKey
ALTER TABLE "instructors" ADD CONSTRAINT "instructors_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "students" ADD CONSTRAINT "students_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "exams" ADD CONSTRAINT "exams_instructor_id_fkey" FOREIGN KEY ("instructor_id") REFERENCES "instructors"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "courses" ADD CONSTRAINT "courses_exam_id_fkey" FOREIGN KEY ("exam_id") REFERENCES "exams"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "courses" ADD CONSTRAINT "courses_instructor_id_fkey" FOREIGN KEY ("instructor_id") REFERENCES "instructors"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "course_cases" ADD CONSTRAINT "course_cases_course_id_fkey" FOREIGN KEY ("course_id") REFERENCES "courses"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "marking_criteria" ADD CONSTRAINT "marking_criteria_course_case_id_fkey" FOREIGN KEY ("course_case_id") REFERENCES "course_cases"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "marking_criteria" ADD CONSTRAINT "marking_criteria_marking_domain_id_fkey" FOREIGN KEY ("marking_domain_id") REFERENCES "marking_domains"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "case_tabs" ADD CONSTRAINT "case_tabs_course_case_id_fkey" FOREIGN KEY ("course_case_id") REFERENCES "course_cases"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "simulations" ADD CONSTRAINT "simulations_course_case_id_fkey" FOREIGN KEY ("course_case_id") REFERENCES "course_cases"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "simulation_attempts" ADD CONSTRAINT "simulation_attempts_simulation_id_fkey" FOREIGN KEY ("simulation_id") REFERENCES "simulations"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "simulation_attempts" ADD CONSTRAINT "simulation_attempts_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "students"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "payments" ADD CONSTRAINT "payments_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "students"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "subscriptions" ADD CONSTRAINT "subscriptions_course_id_fkey" FOREIGN KEY ("course_id") REFERENCES "courses"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "subscriptions" ADD CONSTRAINT "subscriptions_payment_id_fkey" FOREIGN KEY ("payment_id") REFERENCES "payments"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "subscriptions" ADD CONSTRAINT "subscriptions_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "students"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "credit_transactions" ADD CONSTRAINT "credit_transactions_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "students"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "exam_specialties" ADD CONSTRAINT "exam_specialties_exam_id_fkey" FOREIGN KEY ("exam_id") REFERENCES "exams"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "exam_specialties" ADD CONSTRAINT "exam_specialties_specialty_id_fkey" FOREIGN KEY ("specialty_id") REFERENCES "specialties"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "exam_curriculums" ADD CONSTRAINT "exam_curriculums_curriculum_id_fkey" FOREIGN KEY ("curriculum_id") REFERENCES "curriculums"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "exam_curriculums" ADD CONSTRAINT "exam_curriculums_exam_id_fkey" FOREIGN KEY ("exam_id") REFERENCES "exams"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "exam_marking_domains" ADD CONSTRAINT "exam_marking_domains_exam_id_fkey" FOREIGN KEY ("exam_id") REFERENCES "exams"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "exam_marking_domains" ADD CONSTRAINT "exam_marking_domains_marking_domain_id_fkey" FOREIGN KEY ("marking_domain_id") REFERENCES "marking_domains"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "case_specialties" ADD CONSTRAINT "case_specialties_course_case_id_fkey" FOREIGN KEY ("course_case_id") REFERENCES "course_cases"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "case_specialties" ADD CONSTRAINT "case_specialties_specialty_id_fkey" FOREIGN KEY ("specialty_id") REFERENCES "specialties"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "case_curriculums" ADD CONSTRAINT "case_curriculums_course_case_id_fkey" FOREIGN KEY ("course_case_id") REFERENCES "course_cases"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "case_curriculums" ADD CONSTRAINT "case_curriculums_curriculum_id_fkey" FOREIGN KEY ("curriculum_id") REFERENCES "curriculums"("id") ON DELETE CASCADE ON UPDATE CASCADE;



================================================
File: prisma/migrations/20250920113010_add_minutes_billed_to_simulation_attempts/migration.sql
================================================
-- AlterTable
ALTER TABLE "simulation_attempts" ADD COLUMN     "minutes_billed" INTEGER DEFAULT 0;



================================================
File: src/server.ts
================================================
import Fastify from 'fastify'
import { PrismaClient } from '@prisma/client'
import fastifyJwt from '@fastify/jwt'
import fastifyCors from '@fastify/cors'
import './shared/types'

// Add all imports
import authRoutes from './entities/auth/auth.routes'
import subscriptionRoutes from './entities/subscription/subscription.routes'
import specialtyRoutes from './entities/specialty/specialty.routes'
import curriculumRoutes from './entities/curriculum/curriculum.routes'
import markingDomainRoutes from './entities/marking-domain/marking-domain.routes'
import instructorRoutes from './entities/instructor/instructor.routes'
import studentRoutes from './entities/student/student.routes'
import examRoutes from './entities/exam/exam.routes'
import courseRoutes from './entities/course/course.routes'
import courseCaseRoutes from './entities/course-case/course-case.routes'
import caseTabRoutes from './entities/case-tab/case-tab.routes'  
import simulationRoutes from './entities/simulation/simulation.routes'
import simulationAttemptRoutes from './entities/simulation-attempt/simulation-attempt.routes'
import paymentRoutes from './entities/payment/payment.routes'
import markingCriterionRoutes from './entities/marking-criterion/marking-criterion.routes'
import billingRoutes from './entities/billing/billing.routes'

const fastify = Fastify({ logger: true })
const prisma = new PrismaClient()

// Register prisma on fastify instance
fastify.decorate('prisma', prisma)

// Register JWT plugin
const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-this-in-production'
fastify.register(fastifyJwt, {
  secret: JWT_SECRET,
  sign: {
    expiresIn: '1h'
  }
})

// Register CORS plugin - Allow ALL origins
fastify.register(fastifyCors, {
  origin: true, // This allows ALL origins
  credentials: true, // Allow cookies/credentials
  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'] // Allowed methods
})

// Health check
fastify.get('/health', async () => {
  return { status: 'OK', timestamp: new Date().toISOString() }
})

// Clean User routes
fastify.get('/users', async () => {
  const users = await prisma.user.findMany({
    include: { 
      instructor: true,
      student: true
    }
  })
  return users
})

fastify.post('/users', async (request) => {
  const { email, name } = request.body as { email: string; name?: string }
  
  const user = await prisma.user.create({
    data: { email, name }
  })
  return user
})

fastify.get('/users/:id', async (request) => {
  const { id } = request.params as { id: string }
  
  const user = await prisma.user.findUnique({
    where: { id: parseInt(id) },
    include: { 
      instructor: true,
      student: true
    }
  })
  
  if (!user) {
    throw new Error('User not found')
  }
  
  return user
})

// Start server
const start = async () => {
    try {
      // Register auth routes FIRST (no prefix needed)
      await fastify.register(authRoutes, { prefix: '/api' })
      
      // Register subscription routes (also at root level for easier access)
      await fastify.register(subscriptionRoutes, { prefix: '/api' })
      
      // Register all other route sets
      await fastify.register(specialtyRoutes, { prefix: '/api' })
      await fastify.register(curriculumRoutes, { prefix: '/api' })
      await fastify.register(markingDomainRoutes, { prefix: '/api' })
      await fastify.register(instructorRoutes, { prefix: '/api' })
      await fastify.register(studentRoutes, { prefix: '/api' })
      await fastify.register(examRoutes, { prefix: '/api' })
      await fastify.register(courseRoutes, { prefix: '/api' })
      await fastify.register(courseCaseRoutes, { prefix: '/api' })
      await fastify.register(caseTabRoutes, { prefix: '/api' })  
      await fastify.register(simulationRoutes, { prefix: '/api' })
      await fastify.register(simulationAttemptRoutes, { prefix: '/api' })
      await fastify.register(paymentRoutes, { prefix: '/api' })
      await fastify.register(markingCriterionRoutes, { prefix: '/api' })
      await fastify.register(billingRoutes, { prefix: '/api' })
      const port = Number(process.env.PORT) || 3000
      const host = process.env.NODE_ENV === 'production' ? '0.0.0.0' : 'localhost'
      
      await fastify.listen({ port, host })
      console.log(`ðŸš€ Server running on ${host}:${port}`)
      console.log(`ðŸ” JWT authentication enabled`)
      console.log(`ðŸŒ CORS enabled for ALL origins`)
    } catch (err) {
      fastify.log.error(err)
      process.exit(1)
    }
  }
  
  start()


================================================
File: src/entities/auth/auth.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { AuthService } from './auth.service'
import { 
  loginSchema, 
  refreshTokenSchema,
  registerStudentSchema,
  registerInstructorSchema
} from './auth.schema'

export default async function authRoutes(fastify: FastifyInstance) {
  const authService = new AuthService(fastify.prisma, fastify)

  // POST /auth/register/student - Student registration
  fastify.post('/auth/register/student', async (request, reply) => {
    try {
      const data = registerStudentSchema.parse(request.body)
      const result = await authService.registerStudent(data)
      reply.status(201).send(result)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Email already registered') {
          reply.status(400).send({ error: 'Email already registered' })
        } else {
          reply.status(400).send({ error: 'Invalid registration data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /auth/register/instructor - Instructor registration
  fastify.post('/auth/register/instructor', async (request, reply) => {
    try {
      const data = registerInstructorSchema.parse(request.body)
      const result = await authService.registerInstructor(data)
      reply.status(201).send(result)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Email already registered') {
          reply.status(400).send({ error: 'Email already registered' })
        } else {
          reply.status(400).send({ error: 'Invalid registration data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /auth/login - Login endpoint
  fastify.post('/auth/login', async (request, reply) => {
    try {
      const data = loginSchema.parse(request.body)
      const result = await authService.login(data)
      reply.send(result)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Invalid credentials' || 
            error.message === 'User is not a student' || 
            error.message === 'User is not an instructor') {
          reply.status(401).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid login data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /auth/refresh - Refresh token endpoint
  fastify.post('/auth/refresh', async (request, reply) => {
    try {
      const data = refreshTokenSchema.parse(request.body)
      const result = await authService.refreshToken(data.refreshToken)
      reply.send(result)
    } catch (error) {
      if (error instanceof Error && error.message === 'Invalid refresh token') {
        reply.status(401).send({ error: 'Invalid refresh token' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /auth/me - Get current user (requires authentication)
  fastify.get('/auth/me', {
    preHandler: async (request, reply) => {
      try {
        await request.jwtVerify()
      } catch (err) {
        reply.status(401).send({ error: 'Unauthorized' })
      }
    }
  }, async (request, reply) => {
    try {
      const userId = (request.user as any).userId
      
      const user = await fastify.prisma.user.findUnique({
        where: { id: userId },
        include: {
          student: true,
          instructor: true
        }
      })

      if (!user) {
        reply.status(404).send({ error: 'User not found' })
        return
      }

      const role = user.student ? 'student' : 'instructor'
      const profile = user.student ? {
        id: user.student.id,
        firstName: user.student.firstName,
        lastName: user.student.lastName,
        creditBalance: user.student.creditBalance
      } : {
        id: user.instructor!.id,
        firstName: user.instructor!.firstName,
        lastName: user.instructor!.lastName,
        bio: user.instructor!.bio
      }

      reply.send({
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          role,
          profile
        }
      })
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch user information' })
    }
  })

  // POST /auth/logout - Logout endpoint (optional, mainly for client-side token removal)
  fastify.post('/auth/logout', {
    preHandler: async (request, reply) => {
      try {
        await request.jwtVerify()
      } catch (err) {
        reply.status(401).send({ error: 'Unauthorized' })
      }
    }
  }, async (request, reply) => {
    // In a stateless JWT system, logout is handled client-side
    // You could implement token blacklisting here if needed
    reply.send({ message: 'Logged out successfully' })
  })
}


================================================
File: src/entities/auth/auth.schema.ts
================================================
import { z } from 'zod'

// Student Registration Schema
export const registerStudentSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
  firstName: z.string()
    .min(1, 'First name is required')
    .max(50, 'First name must be less than 50 characters')
    .trim(),
  lastName: z.string()
    .min(1, 'Last name is required')
    .max(50, 'Last name must be less than 50 characters')
    .trim(),
  dateOfBirth: z.string()
    .datetime('Invalid date format')
    .or(z.date())
    .transform((val) => new Date(val))
    .refine((date) => {
      const age = (new Date().getTime() - date.getTime()) / (1000 * 60 * 60 * 24 * 365.25)
      return age >= 18 && age <= 100
    }, 'Age must be between 18 and 100 years'),
  name: z.string().optional() // Optional display name
})

// Instructor Registration Schema
export const registerInstructorSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
  firstName: z.string()
    .min(1, 'First name is required')
    .max(50, 'First name must be less than 50 characters')
    .trim(),
  lastName: z.string()
    .min(1, 'Last name is required')
    .max(50, 'Last name must be less than 50 characters')
    .trim(),
  bio: z.string()
    .max(500, 'Bio must be less than 500 characters')
    .optional(),
  name: z.string().optional() // Optional display name
})

// Login Schema
export const loginSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
  userType: z.enum(['student', 'instructor'])
})

// Token Refresh Schema
export const refreshTokenSchema = z.object({
  refreshToken: z.string()
})

// JWT Payload Schema - Updated with 'role' field
export const jwtPayloadSchema = z.object({
  userId: z.number(),
  role: z.enum(['student', 'instructor']), // Changed from userType to role
  email: z.string().email(),
  studentId: z.string().uuid().optional(),
  instructorId: z.string().uuid().optional()
})

// Auth Response Schema
export const authResponseSchema = z.object({
  accessToken: z.string(),
  refreshToken: z.string(),
  expiresIn: z.number(),
  role: z.enum(['student', 'instructor']), // Changed from userType to role
  user: z.object({
    id: z.number(),
    email: z.string(),
    name: z.string().nullable(),
    profile: z.union([
      z.object({
        id: z.string(),
        firstName: z.string(),
        lastName: z.string(),
        creditBalance: z.number()
      }),
      z.object({
        id: z.string(),
        firstName: z.string(),
        lastName: z.string(),
        bio: z.string().nullable()
      })
    ])
  })
})

// Type exports
export type RegisterStudentInput = z.infer<typeof registerStudentSchema>
export type RegisterInstructorInput = z.infer<typeof registerInstructorSchema>
export type LoginInput = z.infer<typeof loginSchema>
export type RefreshTokenInput = z.infer<typeof refreshTokenSchema>
export type JWTPayload = z.infer<typeof jwtPayloadSchema>
export type AuthResponse = z.infer<typeof authResponseSchema>


================================================
File: src/entities/auth/auth.service.ts
================================================
import { PrismaClient, Prisma } from '@prisma/client'
import * as bcrypt from 'bcryptjs'
import { FastifyInstance } from 'fastify'
import { 
  LoginInput, 
  JWTPayload, 
  RegisterStudentInput, 
  RegisterInstructorInput 
} from './auth.schema'

export class AuthService {
  private fastify: FastifyInstance
  
  constructor(private prisma: PrismaClient, fastify: FastifyInstance) {
    this.fastify = fastify
  }

  // Student Registration
  async registerStudent(data: RegisterStudentInput) {
    // Check if email already exists
    const existingUser = await this.prisma.user.findUnique({
      where: { email: data.email }
    })

    if (existingUser) {
      throw new Error('Email already registered')
    }

    // Hash password
    const passwordHash = await this.hashPassword(data.password)

    // Create user and student profile in transaction
    const result = await this.prisma.$transaction(async (tx: Prisma.TransactionClient) => {
      // Create user
      const user = await tx.user.create({
        data: {
          email: data.email,
          name: data.name || `${data.firstName} ${data.lastName}`,
          passwordHash,
          emailVerified: true // Always true in simplified flow
        }
      })

      // Create student profile
      const student = await tx.student.create({
        data: {
          userId: user.id,
          firstName: data.firstName,
          lastName: data.lastName,
          dateOfBirth: data.dateOfBirth,
          creditBalance: 0 // Start with 0 credits
        }
      })

      return { user, student }
    })

    // Generate tokens for auto-login
    const payload: JWTPayload = {
      userId: result.user.id,
      role: 'student',
      email: result.user.email,
      studentId: result.student.id
    }

    const accessToken = await this.generateAccessToken(payload)
    const refreshToken = await this.generateRefreshToken(payload)

    return {
      accessToken,
      refreshToken,
      expiresIn: 3600, // 1 hour
      role: 'student',
      user: {
        id: result.user.id,
        email: result.user.email,
        name: result.user.name,
        profile: {
          id: result.student.id,
          firstName: result.student.firstName,
          lastName: result.student.lastName,
          creditBalance: result.student.creditBalance
        }
      }
    }
  }

  // Instructor Registration
  async registerInstructor(data: RegisterInstructorInput) {
    // Check if email already exists
    const existingUser = await this.prisma.user.findUnique({
      where: { email: data.email }
    })

    if (existingUser) {
      throw new Error('Email already registered')
    }

    // Hash password
    const passwordHash = await this.hashPassword(data.password)

    // Create user and instructor profile in transaction
    const result = await this.prisma.$transaction(async (tx: Prisma.TransactionClient) => {
      // Create user
      const user = await tx.user.create({
        data: {
          email: data.email,
          name: data.name || `${data.firstName} ${data.lastName}`,
          passwordHash,
          emailVerified: true // Always true in simplified flow
        }
      })

      // Create instructor profile
      const instructor = await tx.instructor.create({
        data: {
          userId: user.id,
          firstName: data.firstName,
          lastName: data.lastName,
          bio: data.bio
        }
      })

      return { user, instructor }
    })

    // Generate tokens for auto-login
    const payload: JWTPayload = {
      userId: result.user.id,
      role: 'instructor',
      email: result.user.email,
      instructorId: result.instructor.id
    }

    const accessToken = await this.generateAccessToken(payload)
    const refreshToken = await this.generateRefreshToken(payload)

    return {
      accessToken,
      refreshToken,
      expiresIn: 3600, // 1 hour
      role: 'instructor',
      user: {
        id: result.user.id,
        email: result.user.email,
        name: result.user.name,
        profile: {
          id: result.instructor.id,
          firstName: result.instructor.firstName,
          lastName: result.instructor.lastName,
          bio: result.instructor.bio
        }
      }
    }
  }

  async login(data: LoginInput) {
    // Find user by email
    const user = await this.prisma.user.findUnique({
      where: { email: data.email },
      include: {
        student: true,
        instructor: true
      }
    })

    if (!user) {
      throw new Error('Invalid credentials')
    }

    // Check if user has the correct type
    if (data.userType === 'student' && !user.student) {
      throw new Error('User is not a student')
    }
    if (data.userType === 'instructor' && !user.instructor) {
      throw new Error('User is not an instructor')
    }

    // Verify password
    if (!user.passwordHash) {
      throw new Error('Invalid credentials')
    }

    const isValidPassword = await this.comparePassword(data.password, user.passwordHash)
    
    if (!isValidPassword) {
      throw new Error('Invalid credentials')
    }

    // Generate tokens
    const payload: JWTPayload = {
      userId: user.id,
      role: data.userType, // Using role field
      email: user.email,
      studentId: user.student?.id,
      instructorId: user.instructor?.id
    }

    const accessToken = await this.generateAccessToken(payload)
    const refreshToken = await this.generateRefreshToken(payload)

    // Get profile based on user type
    const profile = data.userType === 'student' ? {
      id: user.student!.id,
      firstName: user.student!.firstName,
      lastName: user.student!.lastName,
      creditBalance: user.student!.creditBalance
    } : {
      id: user.instructor!.id,
      firstName: user.instructor!.firstName,
      lastName: user.instructor!.lastName,
      bio: user.instructor!.bio
    }

    return {
      accessToken,
      refreshToken,
      expiresIn: 3600, // 1 hour
      role: data.userType, // Using role field
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        profile
      }
    }
  }

  async refreshToken(refreshToken: string) {
    try {
      // Verify refresh token
      const decoded = await this.fastify.jwt.verify(refreshToken) as JWTPayload
      
      // Check if user still exists
      const user = await this.prisma.user.findUnique({
        where: { id: decoded.userId },
        include: {
          student: true,
          instructor: true
        }
      })

      if (!user) {
        throw new Error('User not found')
      }

      // Generate new access token
      const newAccessToken = await this.generateAccessToken(decoded)
      
      return {
        accessToken: newAccessToken,
        expiresIn: 3600
      }
    } catch (error) {
      throw new Error('Invalid refresh token')
    }
  }

  async verifyToken(token: string): Promise<JWTPayload> {
    try {
      const decoded = await this.fastify.jwt.verify(token) as JWTPayload
      return decoded
    } catch (error) {
      throw new Error('Invalid token')
    }
  }

  private async generateAccessToken(payload: JWTPayload): Promise<string> {
    return this.fastify.jwt.sign(payload, {
      expiresIn: '1h'
    })
  }

  private async generateRefreshToken(payload: JWTPayload): Promise<string> {
    return this.fastify.jwt.sign(payload, {
      expiresIn: '7d'
    })
  }

  // Password hashing utilities
  async hashPassword(password: string): Promise<string> {
    const saltRounds = 10
    return bcrypt.hash(password, saltRounds)
  }

  async comparePassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash)
  }
}


================================================
File: src/entities/billing/billing.routes.ts
================================================
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { BillingService } from './billing.service';
import {
  BillingWebhookSchema,
  SessionEndSchema,
  type BillingWebhookInput,
  type SessionEndInput,
  BILLING_CONFIG
} from './billing.schema';

export default async function billingRoutes(fastify: FastifyInstance) {
  const billingService = new BillingService(fastify.prisma, fastify.log);

  // Middleware to verify internal secret
  const verifyInternalSecret = async (
    request: FastifyRequest, 
    reply: FastifyReply
  ): Promise<boolean> => {
    const requestId = `auth_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const secret = request.headers['x-internal-secret'] as string;
    const expectedSecret = process.env.VOICE_AGENT_SHARED_SECRET || BILLING_CONFIG.DEFAULT_INTERNAL_SECRET;
    
    // Log authentication attempt
    fastify.log.info({
      requestId,
      action: 'verify_internal_secret',
      has_secret: !!secret,
      ip: request.ip,
      url: request.url,
      method: request.method,
      user_agent: request.headers['user-agent']
    });
    
    if (!secret) {
      fastify.log.error({
        requestId,
        action: 'missing_internal_secret',
        ip: request.ip,
        url: request.url
      });
      
      reply.status(401).send({ 
        error: 'Missing authentication',
        message: 'X-Internal-Secret header is required',
        requestId 
      });
      return false;
    }
    
    if (secret !== expectedSecret) {
      fastify.log.error({
        requestId,
        action: 'invalid_internal_secret',
        ip: request.ip,
        url: request.url
      });
      
      reply.status(401).send({ 
        error: 'Invalid authentication',
        message: 'Invalid internal secret provided',
        requestId 
      });
      return false;
    }
    
    fastify.log.debug({
      requestId,
      action: 'secret_verified_successfully',
      ip: request.ip
    });
    
    return true;
  };

  // Main billing webhook endpoint - called every minute during conversation
  fastify.post('/billing/voice-minute', async (
    request: FastifyRequest<{ Body: BillingWebhookInput }>,
    reply: FastifyReply
  ) => {
    const startTime = Date.now();
    const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // Log incoming request with full details
    fastify.log.info({
      requestId,
      action: 'billing_request_received',
      method: request.method,
      url: request.url,
      body: request.body,
      headers: {
        'content-type': request.headers['content-type'],
        'content-length': request.headers['content-length'],
        'x-internal-secret': 'REDACTED',
        'x-request-id': request.headers['x-request-id']
      },
      ip: request.ip,
      timestamp: new Date().toISOString()
    });

    // Verify authentication
    if (!await verifyInternalSecret(request, reply)) {
      const duration = Date.now() - startTime;
      fastify.log.warn({
        requestId,
        action: 'billing_request_rejected_auth',
        reason: 'invalid_or_missing_secret',
        duration_ms: duration
      });
      return;
    }

    try {
      // Validate request body against schema
      const validatedData = BillingWebhookSchema.parse(request.body);
      
      fastify.log.debug({
        requestId,
        action: 'request_body_validated',
        validated_data: validatedData
      });
      
      // Process billing through service
      const result = await billingService.handleMinuteBilling(validatedData);
      
      const duration = Date.now() - startTime;
      
      // Log successful completion
      fastify.log.info({
        requestId,
        action: 'billing_request_completed',
        duration_ms: duration,
        result,
        conversation_id: validatedData.conversation_id,
        minute: validatedData.minute,
        status: result.status,
        credits_remaining: result.creditsRemaining,
        should_terminate: result.shouldTerminate
      });
      
      // Add response headers for tracking
      reply.header('X-Request-ID', requestId);
      reply.header('X-Processing-Time-MS', duration.toString());
      reply.header('X-Credits-Remaining', result.creditsRemaining.toString());
      
      reply.status(200).send(result);
      
    } catch (error) {
      const duration = Date.now() - startTime;
      
      // Handle validation errors
      if (error instanceof Error && error.name === 'ZodError') {
        const zodError = error as any;
        fastify.log.error({
          requestId,
          action: 'validation_failed',
          duration_ms: duration,
          errors: zodError.errors,
          body: request.body
        });
        
        reply.status(400).send({
          status: 'error',
          message: 'Invalid request data',
          errors: zodError.errors,
          requestId
        });
      } else {
        // Handle other errors
        fastify.log.error({
          requestId,
          action: 'billing_request_failed',
          duration_ms: duration,
          error: error instanceof Error ? error.message : 'Unknown error',
          stack: error instanceof Error ? error.stack : undefined,
          body: request.body
        });
        
        reply.status(500).send({ 
          status: 'error', 
          message: error instanceof Error ? error.message : 'Billing failed',
          requestId
        });
      }
    }
  });

  // Session end endpoint - called when conversation ends
  fastify.post('/billing/end-session', async (
    request: FastifyRequest<{ Body: SessionEndInput }>,
    reply: FastifyReply
  ) => {
    const startTime = Date.now();
    const requestId = `end_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    fastify.log.info({
      requestId,
      action: 'session_end_request_received',
      body: request.body,
      ip: request.ip,
      timestamp: new Date().toISOString()
    });
    
    // Verify authentication
    if (!await verifyInternalSecret(request, reply)) {
      const duration = Date.now() - startTime;
      fastify.log.warn({
        requestId,
        action: 'session_end_rejected_auth',
        reason: 'invalid_or_missing_secret',
        duration_ms: duration
      });
      return;
    }

    try {
      // Validate request body
      const validatedData = SessionEndSchema.parse(request.body);
      
      // Process session end
      const result = await billingService.handleSessionEnd(validatedData);
      
      const duration = Date.now() - startTime;
      
      fastify.log.info({
        requestId,
        action: 'session_end_completed',
        duration_ms: duration,
        result,
        conversation_id: validatedData.conversation_id,
        total_minutes: validatedData.total_minutes,
        attempt_found: result.attemptFound
      });
      
      // Add response headers
      reply.header('X-Request-ID', requestId);
      reply.header('X-Processing-Time-MS', duration.toString());
      
      reply.status(200).send(result);
      
    } catch (error) {
      const duration = Date.now() - startTime;
      
      fastify.log.error({
        requestId,
        action: 'session_end_failed',
        duration_ms: duration,
        error: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined
      });
      
      reply.status(500).send({ 
        error: 'Failed to end billing session',
        message: error instanceof Error ? error.message : 'Unknown error',
        requestId
      });
    }
  });

  // Metrics endpoint - get billing statistics
  fastify.get('/billing/metrics', async (request, reply) => {
    const requestId = `metrics_${Date.now()}`;
    
    try {
      const metrics = billingService.getMetrics();
      
      fastify.log.info({
        requestId,
        action: 'metrics_requested',
        metrics,
        ip: request.ip
      });
      
      reply.send({
        requestId,
        timestamp: new Date().toISOString(),
        metrics
      });
      
    } catch (error) {
      fastify.log.error({
        requestId,
        action: 'metrics_failed',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      
      reply.status(500).send({
        error: 'Failed to get metrics',
        requestId
      });
    }
  });

  // Reset metrics endpoint
  fastify.post('/billing/metrics/reset', async (request, reply) => {
    // Verify authentication for sensitive operation
    if (!await verifyInternalSecret(request, reply)) {
      return;
    }
    
    const requestId = `metrics_reset_${Date.now()}`;
    
    try {
      billingService.resetMetrics();
      
      fastify.log.info({
        requestId,
        action: 'metrics_reset',
        ip: request.ip
      });
      
      reply.send({
        success: true,
        message: 'Metrics reset successfully',
        timestamp: new Date().toISOString()
      });
      
    } catch (error) {
      fastify.log.error({
        requestId,
        action: 'metrics_reset_failed',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      
      reply.status(500).send({
        error: 'Failed to reset metrics',
        requestId
      });
    }
  });

  // Health check endpoint for billing service
  fastify.get('/billing/health', async (request, reply) => {
    const metrics = billingService.getMetrics();
    
    const health = {
      status: 'healthy',
      service: 'billing',
      timestamp: new Date().toISOString(),
      uptime_seconds: metrics.uptime,
      requests_processed: metrics.totalRequests,
      success_rate: metrics.totalRequests > 0 
        ? ((metrics.successfulBillings / metrics.totalRequests) * 100).toFixed(2) + '%'
        : 'N/A'
    };
    
    reply.send(health);
  });

  fastify.log.info('Billing routes registered successfully', {
    endpoints: [
      'POST /billing/voice-minute',
      'POST /billing/end-session',
      'GET /billing/metrics',
      'POST /billing/metrics/reset',
      'GET /billing/health'
    ]
  });
  
  // Cleanup on shutdown
  fastify.addHook('onClose', async () => {
    await billingService.cleanup();
  });
}


================================================
File: src/entities/billing/billing.schema.ts
================================================
import { z } from 'zod';

// Request schemas
export const BillingWebhookSchema = z.object({
    correlation_token: z.string().min(1, "Correlation token is required"),
    conversation_id: z.string().min(1, "Conversation ID is required"),  
    minute: z.number().min(1).int("Minute must be a positive integer"),
    timestamp: z.string().refine((val) => {
      // Accept timestamps with or without timezone, with varying decimal places
      return /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+-]\d{2}:\d{2})?$/.test(val);
    }, "Invalid timestamp format")
  });
  
  export const SessionEndSchema = z.object({
    correlation_token: z.string().min(1, "Correlation token is required"),
    conversation_id: z.string().min(1, "Conversation ID is required"),
    total_minutes: z.number().min(0).int("Total minutes must be a non-negative integer"),
    timestamp: z.string().refine((val) => {
      // Same flexible timestamp validation
      return /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+-]\d{2}:\d{2})?$/.test(val);
    }, "Invalid timestamp format")
  });

// Enhanced Response schemas with minutesBilled tracking
export const BillingResponseSchema = z.object({
  status: z.enum(['continue', 'warning', 'terminate', 'error']),
  creditsRemaining: z.number().int(),
  minuteBilled: z.number().int(),
  totalMinutesBilled: z.number().int(), // NEW: Track total minutes billed for this attempt
  shouldTerminate: z.boolean(),
  message: z.string().optional(),
  gracePeriodSeconds: z.number().int().optional(),
  attemptId: z.string().optional() // NEW: Include attempt ID for tracking
});

export const SessionEndResponseSchema = z.object({
  success: z.boolean(),
  totalMinutesBilled: z.number().int(),
  attemptFound: z.boolean(),
  finalBalance: z.number().int().optional() // NEW: Final credit balance after session
});

export const BillingMetricsSchema = z.object({
  totalRequests: z.number().int(),
  successfulBillings: z.number().int(),
  failedBillings: z.number().int(),
  duplicateRequests: z.number().int(),
  insufficientCreditEvents: z.number().int(),
  averageTransactionTime: z.number(),
  totalTransactionTime: z.number(),
  totalMinutesBilled: z.number().int(), // NEW: Total minutes billed across all attempts
  lastProcessedAt: z.date().optional(),
  uptime: z.number()
});

// Type exports
export type BillingWebhookInput = z.infer<typeof BillingWebhookSchema>;
export type SessionEndInput = z.infer<typeof SessionEndSchema>;
export type BillingResponse = z.infer<typeof BillingResponseSchema>;
export type SessionEndResponse = z.infer<typeof SessionEndResponseSchema>;
export type BillingMetrics = z.infer<typeof BillingMetricsSchema>;

// Enums matching your domain
export enum BillingStatus {
  CONTINUE = 'continue',
  WARNING = 'warning',
  TERMINATE = 'terminate',
  ERROR = 'error'
}

// Configuration constants
export const BILLING_CONFIG = {
  DEFAULT_GRACE_PERIOD_SECONDS: 60,
  WARNING_THRESHOLD_CREDITS: 2,
  MINUTE_DURATION_SECONDS: 60,
  TRANSACTION_TIMEOUT_MS: 10000,
  TRANSACTION_MAX_WAIT_MS: 5000,
  DEFAULT_INTERNAL_SECRET: 'your-internal-secret-change-in-production'
} as const;


================================================
File: src/entities/billing/billing.service.ts
================================================
import { PrismaClient, Prisma, CreditTransactionType, CreditTransactionSource } from '@prisma/client';
import { FastifyBaseLogger } from 'fastify';
import * as fs from 'fs';
import * as path from 'path';
import { 
  BillingStatus, 
  BillingResponse, 
  BillingMetrics,
  BillingWebhookInput,
  SessionEndInput,
  SessionEndResponse,
  BILLING_CONFIG 
} from './billing.schema';

// Create logs directory if it doesn't exist
const logsDir = path.join(process.cwd(), 'logs');
if (!fs.existsSync(logsDir)) {
  fs.mkdirSync(logsDir, { recursive: true });
}

// Dedicated billing logger class
class BillingLogger {
  private logFile: fs.WriteStream;
  private fastifyLogger?: FastifyBaseLogger;
  
  constructor(fastifyLogger?: FastifyBaseLogger) {
    this.fastifyLogger = fastifyLogger;
    this.logFile = fs.createWriteStream(
      path.join(logsDir, 'billing.log'),
      { flags: 'a' }
    );
  }
  
  private formatLog(level: string, message: string, data?: any): string {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      service: 'BillingService',
      message,
      ...data
    };
    return JSON.stringify(logEntry);
  }
  
  log(level: 'info' | 'warn' | 'error' | 'debug', message: string, data?: any) {
    const formatted = this.formatLog(level.toUpperCase(), message, data);
    
    // Write to file
    this.logFile.write(formatted + '\n');
    
    // Console output with color coding
    const colors = {
      info: '\x1b[36m',   // Cyan
      warn: '\x1b[33m',   // Yellow
      error: '\x1b[31m',  // Red
      debug: '\x1b[90m'   // Gray
    };
    const reset = '\x1b[0m';
    console.log(`${colors[level]}[BILLING]${reset} ${formatted}`);
    
    // Fastify logger if available
    if (this.fastifyLogger) {
      this.fastifyLogger[level]({ ...data, service: 'BillingService' }, message);
    }
  }
  
  info(message: string, data?: any) { this.log('info', message, data); }
  warn(message: string, data?: any) { this.log('warn', message, data); }
  error(message: string, data?: any) { this.log('error', message, data); }
  debug(message: string, data?: any) { this.log('debug', message, data); }
  
  close() {
    this.logFile.end();
  }
}

export class BillingService {
  private logger: BillingLogger;
  private metrics: BillingMetrics = {
    totalRequests: 0,
    successfulBillings: 0,
    failedBillings: 0,
    duplicateRequests: 0,
    insufficientCreditEvents: 0,
    averageTransactionTime: 0,
    totalTransactionTime: 0,
    totalMinutesBilled: 0,
    uptime: 0
  };

  constructor(
    private prisma: PrismaClient,
    fastifyLogger?: FastifyBaseLogger
  ) {
    this.logger = new BillingLogger(fastifyLogger);
    this.logger.info('BillingService initialized', {
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV || 'development',
      database_url: process.env.DATABASE_URL ? 'configured' : 'not configured'
    });
  }

  async handleMinuteBilling(data: BillingWebhookInput): Promise<BillingResponse> {
    const requestId = `bill_${data.conversation_id}_min${data.minute}_${Date.now()}`;
    const startTime = Date.now();
    
    this.metrics.totalRequests++;
    this.metrics.lastProcessedAt = new Date();
    
    this.logger.info('Processing billing request', {
      requestId,
      correlation_token: data.correlation_token,
      conversation_id: data.conversation_id,
      minute: data.minute,
      timestamp: data.timestamp,
      metrics_total_requests: this.metrics.totalRequests
    });

    try {
      // Get simulation attempt first to check minutesBilled
      this.logger.debug('Fetching simulation attempt by correlation token', {
        requestId,
        correlation_token: data.correlation_token
      });
      
      const attempt = await this.prisma.simulationAttempt.findUnique({
        where: { correlationToken: data.correlation_token },
        include: {
          student: {
            include: {
              user: true
            }
          },
          simulation: {
            include: {
              courseCase: true
            }
          }
        }
      });

      if (!attempt) {
        this.logger.error('Invalid correlation token - no attempt found', {
          requestId,
          correlation_token: data.correlation_token,
          conversation_id: data.conversation_id
        });

        this.metrics.failedBillings++;
        
        return {
          status: BillingStatus.ERROR,
          creditsRemaining: 0,
          minuteBilled: data.minute,
          totalMinutesBilled: 0,
          shouldTerminate: true,
          message: 'Invalid correlation token - session not found'
        };
      }

      // Check if this minute was already billed using minutesBilled field
      const currentMinutesBilled = attempt.minutesBilled || 0;
      
      this.logger.debug('Checking if minute already billed', {
        requestId,
        minute_requested: data.minute,
        minutes_already_billed: currentMinutesBilled,
        attempt_id: attempt.id
      });
      
      if (data.minute <= currentMinutesBilled) {
        this.metrics.duplicateRequests++;
        
        this.logger.warn('Minute already billed - returning idempotent response', {
          requestId,
          minute_requested: data.minute,
          minutes_already_billed: currentMinutesBilled,
          attempt_id: attempt.id,
          total_duplicates: this.metrics.duplicateRequests
        });

        const response: BillingResponse = {
          status: BillingStatus.CONTINUE,
          creditsRemaining: attempt.student.creditBalance,
          minuteBilled: data.minute,
          totalMinutesBilled: currentMinutesBilled,
          attemptId: attempt.id,
          shouldTerminate: false,
          message: 'Already billed (idempotent response)'
        };
        
        this.logger.info('Returning idempotent response', {
          requestId,
          response,
          duration_ms: Date.now() - startTime
        });
        
        return response;
      }

      // Verify minute is sequential (warn if not)
      if (data.minute > currentMinutesBilled + 1) {
        this.logger.warn('Non-sequential minute billing detected', {
          requestId,
          minute_requested: data.minute,
          expected_minute: currentMinutesBilled + 1,
          gap: data.minute - (currentMinutesBilled + 1),
          attempt_id: attempt.id
        });
      }

      this.logger.info('Attempt found successfully', {
        requestId,
        attempt_id: attempt.id,
        student_id: attempt.student.id,
        student_name: `${attempt.student.firstName} ${attempt.student.lastName}`,
        student_email: attempt.student.user.email,
        current_balance: attempt.student.creditBalance,
        minutes_already_billed: currentMinutesBilled,
        simulation_id: attempt.simulation.id,
        case_title: attempt.simulation.courseCase.title
      });

      const { student } = attempt;

      // Check current credits
      if (student.creditBalance < 1) {
        this.metrics.insufficientCreditEvents++;
        
        this.logger.warn('Insufficient credits detected', {
          requestId,
          student_id: student.id,
          student_email: student.user.email,
          current_balance: student.creditBalance,
          required: 1,
          minutes_billed: currentMinutesBilled,
          total_insufficient_events: this.metrics.insufficientCreditEvents
        });

        return {
          status: BillingStatus.TERMINATE,
          creditsRemaining: 0,
          minuteBilled: data.minute,
          totalMinutesBilled: currentMinutesBilled,
          attemptId: attempt.id,
          shouldTerminate: true,
          message: 'Insufficient credits to continue',
          gracePeriodSeconds: 30
        };
      }

      // Start atomic transaction for credit deduction
      const transactionStartTime = Date.now();
      
      this.logger.info('Starting credit deduction transaction', {
        requestId,
        student_id: student.id,
        amount_to_deduct: 1,
        current_balance: student.creditBalance,
        expected_balance_after: student.creditBalance - 1,
        minute_to_bill: data.minute
      });
      
      try {
        const result = await this.prisma.$transaction(async (tx: Prisma.TransactionClient) => {
          
          // Update student credits atomically
          this.logger.debug('Decrementing student credit balance', {
            requestId,
            student_id: student.id,
            operation: 'DECREMENT',
            amount: 1
          });
          
          const updatedStudent = await tx.student.update({
            where: { id: student.id },
            data: {
              creditBalance: { decrement: 1 }
            }
          });

          this.logger.debug('Student balance updated successfully', {
            requestId,
            student_id: student.id,
            old_balance: student.creditBalance,
            new_balance: updatedStudent.creditBalance,
            change: -1
          });

          // Safety check: verify balance didn't go negative
          if (updatedStudent.creditBalance < 0) {
            this.logger.error('CRITICAL: Balance went negative - rolling back', {
              requestId,
              student_id: student.id,
              balance: updatedStudent.creditBalance
            });
            throw new Error('INSUFFICIENT_CREDITS');
          }

          // Create credit transaction record for audit trail
          this.logger.debug('Creating credit transaction record', {
            requestId,
            student_id: student.id,
            amount: 1,
            balance_after: updatedStudent.creditBalance,
            minute: data.minute
          });
          
          const creditTransaction = await tx.creditTransaction.create({
            data: {
              studentId: student.id,
              transactionType: CreditTransactionType.DEBIT,
              amount: 1,
              balanceAfter: updatedStudent.creditBalance,
              sourceType: CreditTransactionSource.SIMULATION,
              sourceId: attempt.id,
              description: `Voice conversation minute ${data.minute}`,
              createdAt: new Date()
            }
          });

          this.logger.debug('Credit transaction record created', {
            requestId,
            transaction_id: creditTransaction.id,
            transaction_type: creditTransaction.transactionType,
            balance_after: creditTransaction.balanceAfter
          });

          // Update attempt with new minutesBilled and duration
          this.logger.debug('Updating simulation attempt with minutes billed', {
            requestId,
            attempt_id: attempt.id,
            new_minutes_billed: data.minute,
            new_duration_seconds: data.minute * BILLING_CONFIG.MINUTE_DURATION_SECONDS
          });
          
          await tx.simulationAttempt.update({
            where: { id: attempt.id },
            data: {
              minutesBilled: data.minute, // Update the minutesBilled field
              durationSeconds: data.minute * BILLING_CONFIG.MINUTE_DURATION_SECONDS
            }
          });

          this.logger.debug('Attempt updated with minutes billed', {
            requestId,
            attempt_id: attempt.id,
            minutes_billed: data.minute
          });

          return updatedStudent;
        }, {
          maxWait: BILLING_CONFIG.TRANSACTION_MAX_WAIT_MS,
          timeout: BILLING_CONFIG.TRANSACTION_TIMEOUT_MS
        });

        const transactionDuration = Date.now() - transactionStartTime;
        this.metrics.totalTransactionTime += transactionDuration;
        this.metrics.successfulBillings++;
        this.metrics.totalMinutesBilled++;
        this.metrics.averageTransactionTime = 
          this.metrics.totalTransactionTime / this.metrics.successfulBillings;
        
        this.logger.info('Transaction completed successfully', {
          requestId,
          transaction_duration_ms: transactionDuration,
          new_balance: result.creditBalance,
          minute_billed: data.minute,
          total_minutes_billed_this_attempt: data.minute,
          total_successful: this.metrics.successfulBillings,
          total_minutes_billed_all_time: this.metrics.totalMinutesBilled,
          avg_transaction_time: this.metrics.averageTransactionTime.toFixed(2)
        });

        // Determine response based on remaining credits
        let response: BillingResponse;
        
        if (result.creditBalance === 0) {
          this.logger.warn('Last credit used - will terminate conversation', {
            requestId,
            student_id: student.id,
            minute_billed: data.minute,
            total_minutes_this_session: data.minute
          });
          
          response = {
            status: BillingStatus.TERMINATE,
            creditsRemaining: 0,
            minuteBilled: data.minute,
            totalMinutesBilled: data.minute,
            attemptId: attempt.id,
            shouldTerminate: true,
            message: 'Last credit used - conversation will end',
            gracePeriodSeconds: BILLING_CONFIG.DEFAULT_GRACE_PERIOD_SECONDS
          };
          
        } else if (result.creditBalance <= BILLING_CONFIG.WARNING_THRESHOLD_CREDITS) {
          this.logger.warn('Low credits warning threshold reached', {
            requestId,
            student_id: student.id,
            credits_remaining: result.creditBalance,
            minute_billed: data.minute,
            warning_threshold: BILLING_CONFIG.WARNING_THRESHOLD_CREDITS
          });
          
          response = {
            status: BillingStatus.WARNING,
            creditsRemaining: result.creditBalance,
            minuteBilled: data.minute,
            totalMinutesBilled: data.minute,
            attemptId: attempt.id,
            shouldTerminate: false,
            message: `Low credits warning: ${result.creditBalance} minute(s) remaining`
          };
          
        } else {
          response = {
            status: BillingStatus.CONTINUE,
            creditsRemaining: result.creditBalance,
            minuteBilled: data.minute,
            totalMinutesBilled: data.minute,
            attemptId: attempt.id,
            shouldTerminate: false
          };
        }

        const totalDuration = Date.now() - startTime;
        
        this.logger.info('Billing request completed successfully', {
          requestId,
          total_duration_ms: totalDuration,
          transaction_duration_ms: transactionDuration,
          response
        });

        return response;
        
      } catch (error) {
        const transactionDuration = Date.now() - transactionStartTime;
        this.metrics.failedBillings++;
        
        if (error instanceof Error && error.message === 'INSUFFICIENT_CREDITS') {
          this.logger.error('Transaction failed - insufficient credits', {
            requestId,
            transaction_duration_ms: transactionDuration,
            student_id: student.id,
            error: error.message
          });

          // Fix negative balance if it occurred
          this.logger.info('Resetting negative balance to zero', {
            requestId,
            student_id: student.id
          });
          
          await this.prisma.student.update({
            where: { id: student.id },
            data: { creditBalance: 0 }
          });

          this.metrics.insufficientCreditEvents++;

          return {
            status: BillingStatus.TERMINATE,
            creditsRemaining: 0,
            minuteBilled: data.minute,
            totalMinutesBilled: currentMinutesBilled,
            attemptId: attempt.id,
            shouldTerminate: true,
            message: 'Insufficient credits'
          };
        }

        this.logger.error('Transaction failed with unexpected error', {
          requestId,
          transaction_duration_ms: transactionDuration,
          error: error instanceof Error ? error.message : 'Unknown error',
          stack: error instanceof Error ? error.stack : undefined,
          total_failed: this.metrics.failedBillings
        });

        throw error;
      }
      
    } catch (error) {
      const totalDuration = Date.now() - startTime;
      
      this.logger.error('Billing request failed completely', {
        requestId,
        total_duration_ms: totalDuration,
        error: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        conversation_id: data.conversation_id,
        minute: data.minute
      });
      
      throw error;
    }
  }

  async handleSessionEnd(data: SessionEndInput): Promise<SessionEndResponse> {
    const sessionId = `session_end_${data.conversation_id}_${Date.now()}`;
    const startTime = Date.now();
    
    this.logger.info('Processing session end request', {
      sessionId,
      correlation_token: data.correlation_token,
      conversation_id: data.conversation_id,
      total_minutes: data.total_minutes,
      timestamp: data.timestamp
    });

    try {
      const attempt = await this.prisma.simulationAttempt.findUnique({
        where: { correlationToken: data.correlation_token },
        include: {
          student: {
            include: {
              user: true
            }
          },
          simulation: {
            include: {
              courseCase: true
            }
          }
        }
      });

      if (attempt) {
        const currentMinutesBilled = attempt.minutesBilled || 0;
        const finalMinutesBilled = Math.max(data.total_minutes, currentMinutesBilled);
        const finalDurationSeconds = finalMinutesBilled * BILLING_CONFIG.MINUTE_DURATION_SECONDS;
        
        this.logger.info('Updating final attempt duration and minutes billed', {
          sessionId,
          attempt_id: attempt.id,
          student_id: attempt.student.id,
          student_email: attempt.student.user.email,
          old_minutes_billed: currentMinutesBilled,
          new_minutes_billed: finalMinutesBilled,
          old_duration: attempt.durationSeconds,
          new_duration: finalDurationSeconds,
          case_title: attempt.simulation.courseCase.title
        });
        
        // Only update if total_minutes is greater than what's already billed
        if (data.total_minutes > currentMinutesBilled) {
          await this.prisma.simulationAttempt.update({
            where: { id: attempt.id },
            data: {
              minutesBilled: data.total_minutes,
              durationSeconds: finalDurationSeconds,
              endedAt: new Date(data.timestamp)
            }
          });
          
          this.logger.info('Updated attempt with final billing info', {
            sessionId,
            attempt_id: attempt.id,
            minutes_billed: data.total_minutes
          });
        } else {
          // Just update the endedAt timestamp
          await this.prisma.simulationAttempt.update({
            where: { id: attempt.id },
            data: {
              endedAt: new Date(data.timestamp)
            }
          });
          
          this.logger.info('Session ended without additional billing', {
            sessionId,
            attempt_id: attempt.id,
            minutes_already_billed: currentMinutesBilled,
            minutes_reported: data.total_minutes
          });
        }

        const duration = Date.now() - startTime;
        
        this.logger.info('Session end processed successfully', {
          sessionId,
          attempt_id: attempt.id,
          total_minutes_billed: finalMinutesBilled,
          final_balance: attempt.student.creditBalance,
          processing_duration_ms: duration
        });
        
        return { 
          success: true, 
          totalMinutesBilled: finalMinutesBilled,
          attemptFound: true,
          finalBalance: attempt.student.creditBalance
        };
        
      } else {
        this.logger.warn('Session end - attempt not found', {
          sessionId,
          correlation_token: data.correlation_token
        });
        
        return { 
          success: false, 
          totalMinutesBilled: 0,
          attemptFound: false
        };
      }
      
    } catch (error) {
      const duration = Date.now() - startTime;
      
      this.logger.error('Session end processing failed', {
        sessionId,
        duration_ms: duration,
        error: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined
      });
      
      throw error;
    }
  }

  getMetrics(): BillingMetrics {
    return {
      ...this.metrics,
      uptime: process.uptime()
    };
  }
  
  resetMetrics(): void {
    this.logger.info('Resetting billing metrics', {
      old_metrics: this.metrics
    });
    
    this.metrics = {
      totalRequests: 0,
      successfulBillings: 0,
      failedBillings: 0,
      duplicateRequests: 0,
      insufficientCreditEvents: 0,
      averageTransactionTime: 0,
      totalTransactionTime: 0,
      totalMinutesBilled: 0,
      uptime: 0
    };
  }

  async cleanup(): Promise<void> {
    this.logger.info('Cleaning up BillingService', {
      final_metrics: this.metrics
    });
    this.logger.close();
  }
}


================================================
File: src/entities/case-tab/case-tab.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { z } from 'zod'
import { CaseTabService } from './case-tab.service'
import { 
  createCaseTabSchema, 
  updateCaseTabSchema, 
  caseTabParamsSchema,
  caseTabCourseCaseParamsSchema,
  caseTabTypeParamsSchema,
  courseParamsSchema,
  bulkUpdateCaseTabSchema,
  createAllTabsSchema
} from './case-tab.schema'

export default async function caseTabRoutes(fastify: FastifyInstance) {
  const caseTabService = new CaseTabService(fastify.prisma)

  // GET /case-tabs - Get all case tabs
  fastify.get('/case-tabs', async (request, reply) => {
    try {
      const caseTabs = await caseTabService.findAll()
      reply.send(caseTabs)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch case tabs' })
    }
  })

  // GET /case-tabs/course-case/:courseCaseId - Get all tabs for a course case
  fastify.get('/case-tabs/course-case/:courseCaseId', async (request, reply) => {
    try {
      const { courseCaseId } = caseTabCourseCaseParamsSchema.parse(request.params)
      const caseTabs = await caseTabService.findByCourseCase(courseCaseId)
      reply.send(caseTabs)
    } catch (error) {
      if (error instanceof Error && error.message === 'Course case not found') {
        reply.status(404).send({ error: 'Course case not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /case-tabs/course-case/:courseCaseId/:tabType - Get specific tab for a course case
  fastify.get('/case-tabs/course-case/:courseCaseId/:tabType', async (request, reply) => {
    try {
      const { courseCaseId, tabType } = caseTabTypeParamsSchema.parse(request.params)
      const caseTab = await caseTabService.findByTabType(courseCaseId, tabType)
      reply.send(caseTab)
    } catch (error) {
      if (error instanceof Error && error.message.includes('tab not found')) {
        reply.status(404).send({ error: error.message })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /case-tabs/course-case/:courseCaseId/stats - Get tab completion stats for a course case
  fastify.get('/case-tabs/course-case/:courseCaseId/stats', async (request, reply) => {
    try {
      const { courseCaseId } = caseTabCourseCaseParamsSchema.parse(request.params)
      const stats = await caseTabService.getCaseTabStats(courseCaseId)
      reply.send(stats)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /case-tabs/course/:courseId/overview - Get tabs overview for entire course
  fastify.get('/case-tabs/course/:courseId/overview', async (request, reply) => {
    try {
      const { courseId } = courseParamsSchema.parse(request.params)
      const overview = await caseTabService.getCourseTabsOverview(courseId)
      reply.send(overview)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /case-tabs/:id - Get case tab by ID
  fastify.get('/case-tabs/:id', async (request, reply) => {
    try {
      const { id } = caseTabParamsSchema.parse(request.params)
      const caseTab = await caseTabService.findById(id)
      reply.send(caseTab)
    } catch (error) {
      if (error instanceof Error && error.message === 'Case tab not found') {
        reply.status(404).send({ error: 'Case tab not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /case-tabs - Create new case tab
  fastify.post('/case-tabs', async (request, reply) => {
    try {
      const data = createCaseTabSchema.parse(request.body)
      const caseTab = await caseTabService.create(data)
      reply.status(201).send(caseTab)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message.includes('already has a') && error.message.includes('tab')) {
          reply.status(400).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /case-tabs/create-all - Create all 3 tabs for a course case
  fastify.post('/case-tabs/create-all', async (request, reply) => {
    try {
      const { courseCaseId } = createAllTabsSchema.parse(request.body)
      const tabs = await caseTabService.createAllTabsForCase(courseCaseId)
      reply.status(201).send({
        message: 'All tabs created successfully',
        tabs,
        totalCreated: tabs.length
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message === 'Some tabs already exist for this case') {
          reply.status(400).send({ error: 'Some tabs already exist for this case' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PUT /case-tabs/:id - Update case tab
  fastify.put('/case-tabs/:id', async (request, reply) => {
    try {
      const { id } = caseTabParamsSchema.parse(request.params)
      const data = updateCaseTabSchema.parse(request.body)
      const caseTab = await caseTabService.update(id, data)
      reply.send(caseTab)
    } catch (error) {
      if (error instanceof Error && error.message === 'Case tab not found') {
        reply.status(404).send({ error: 'Case tab not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // PUT /case-tabs/course-case/:courseCaseId/bulk-update - Update multiple tabs at once
  fastify.put('/case-tabs/course-case/:courseCaseId/bulk-update', async (request, reply) => {
    try {
      const { courseCaseId } = caseTabCourseCaseParamsSchema.parse(request.params)
      const { tabUpdates } = bulkUpdateCaseTabSchema.parse(request.body)
      
      const updatedTabs = await caseTabService.bulkUpdateTabContent(courseCaseId, tabUpdates)
      reply.send({
        message: 'Tabs updated successfully',
        updatedTabs,
        totalUpdated: updatedTabs.length
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // DELETE /case-tabs/:id - Delete case tab
  fastify.delete('/case-tabs/:id', async (request, reply) => {
    try {
      const { id } = caseTabParamsSchema.parse(request.params)
      await caseTabService.delete(id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'Case tab not found') {
        reply.status(404).send({ error: 'Case tab not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // Helper endpoint to get tab types (useful for frontend) - ADJUSTED
  fastify.get('/case-tabs/types', async (request, reply) => {
    reply.send({
      tabTypes: ['DOCTORS_NOTE', 'PATIENT_SCRIPT', 'MEDICAL_NOTES'],
      descriptions: {
        DOCTORS_NOTE: "Doctor's clinical notes and observations",
        PATIENT_SCRIPT: "Patient dialogue and responses script",
        MEDICAL_NOTES: "Key medical points and references"
      }
    })
  })

  // POST /case-tabs/:id/content - Add an item to a tab's content array
  fastify.post('/case-tabs/:id/content', async (request, reply) => {
    try {
      const { id } = caseTabParamsSchema.parse(request.params)
      const { content } = z.object({ 
        content: z.string().max(10000, 'Content must be less than 10,000 characters') 
      }).parse(request.body)
      
      const caseTab = await caseTabService.addContentItem(id, content)
      reply.send({
        message: 'Content item added successfully',
        caseTab,
        totalItems: caseTab.content.length
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Case tab not found') {
        reply.status(404).send({ error: 'Case tab not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // PUT /case-tabs/:id/content/:index - Update a specific content item
  fastify.put('/case-tabs/:id/content/:index', async (request, reply) => {
    try {
      const { id } = caseTabParamsSchema.parse(request.params)
      const index = parseInt((request.params as any).index as string)
      const { content } = z.object({ 
        content: z.string().max(10000, 'Content must be less than 10,000 characters') 
      }).parse(request.body)
      
      if (isNaN(index) || index < 0) {
        reply.status(400).send({ error: 'Invalid content index' })
        return
      }
      
      const caseTab = await caseTabService.updateContentItem(id, index, content)
      reply.send({
        message: 'Content item updated successfully',
        caseTab
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Case tab not found') {
          reply.status(404).send({ error: 'Case tab not found' })
        } else if (error.message === 'Invalid content index') {
          reply.status(400).send({ error: 'Invalid content index' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // DELETE /case-tabs/:id/content/:index - Remove a content item
  fastify.delete('/case-tabs/:id/content/:index', async (request, reply) => {
    try {
      const { id } = caseTabParamsSchema.parse(request.params)
      const index = parseInt((request.params as any).index as string)
      
      if (isNaN(index) || index < 0) {
        reply.status(400).send({ error: 'Invalid content index' })
        return
      }
      
      const caseTab = await caseTabService.removeContentItem(id, index)
      reply.send({
        message: 'Content item removed successfully',
        caseTab,
        remainingItems: caseTab.content.length
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Case tab not found') {
          reply.status(404).send({ error: 'Case tab not found' })
        } else if (error.message === 'Invalid content index') {
          reply.status(400).send({ error: 'Invalid content index' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })
}


================================================
File: src/entities/case-tab/case-tab.schema.ts
================================================
import { z } from 'zod'
import { PatientGenderEnum } from '../course-case/course-case.schema'

// CaseTabType enum - ADJUSTED: 'MARKING_CRITERIA' has been removed.
export const CaseTabTypeEnum = z.enum(['DOCTORS_NOTE', 'PATIENT_SCRIPT', 'MEDICAL_NOTES'])
export type CaseTabType = z.infer<typeof CaseTabTypeEnum>

// Create CaseTab Schema
export const createCaseTabSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  tabType: CaseTabTypeEnum,
  content: z.array(z.string())
    .default([])
    .refine(arr => arr.every(item => item.length <= 10000), 
      'Each content item must be less than 10,000 characters')
})

// Update CaseTab Schema
export const updateCaseTabSchema = z.object({
  content: z.array(z.string())
    .optional()
    .refine(arr => !arr || arr.every(item => item.length <= 10000), 
      'Each content item must be less than 10,000 characters')
})

// URL Params Schemas
export const caseTabParamsSchema = z.object({
  id: z.string().uuid('Invalid case tab ID')
})

export const caseTabCourseCaseParamsSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID')
})

export const caseTabTypeParamsSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  tabType: CaseTabTypeEnum
})

export const courseParamsSchema = z.object({
  courseId: z.string().uuid('Invalid course ID')
})

// Bulk update schema - ADJUSTED: Max tabs is now 3
export const bulkUpdateCaseTabSchema = z.object({
  tabUpdates: z.array(z.object({
    tabType: CaseTabTypeEnum,
    content: z.array(z.string())
      .refine(arr => arr.every(item => item.length <= 10000), 
        'Each content item must be less than 10,000 characters')
  })).min(1, 'At least one tab update is required').max(3, 'Cannot update more than 3 tabs')
})

// Create all tabs schema
export const createAllTabsSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID')
})

// Response Schema
export const caseTabResponseSchema = z.object({
  id: z.string(),
  courseCaseId: z.string(),
  tabType: CaseTabTypeEnum,
  content: z.array(z.string()),
  createdAt: z.date(),
  updatedAt: z.date(),
  courseCase: z.object({
    id: z.string(),
    title: z.string(),
    diagnosis: z.string(),
    patientName: z.string(),
    course: z.object({
      id: z.string(),
      title: z.string(),
      exam: z.object({
        id: z.string(),
        title: z.string(),
        slug: z.string()
      })
    })
  })
})

// Stats response schemas
export const caseTabStatsResponseSchema = z.object({
  courseCaseId: z.string(),
  totalTabs: z.number(),
  completedTabs: z.number(),
  emptyTabs: z.number(),
  tabDetails: z.array(z.object({
    tabType: CaseTabTypeEnum,
    hasContent: z.boolean(),
    contentItems: z.number(),
    totalContentLength: z.number(),
    lastUpdated: z.date()
  }))
})

export const courseTabsOverviewResponseSchema = z.object({
  courseId: z.string(),
  totalCases: z.number(),
  casesWithAllTabs: z.number(),
  casesWithCompletedContent: z.number(),
  averageCompletion: z.number(),
  caseDetails: z.array(z.object({
    caseId: z.string(),
    caseTitle: z.string(),
    totalTabs: z.number(),
    completedTabs: z.number(),
    completionPercentage: z.number()
  }))
})

// Type exports
export type CreateCaseTabInput = z.infer<typeof createCaseTabSchema>
export type UpdateCaseTabInput = z.infer<typeof updateCaseTabSchema>
export type CaseTabParams = z.infer<typeof caseTabParamsSchema>
export type CaseTabCourseCaseParams = z.infer<typeof caseTabCourseCaseParamsSchema>
export type CaseTabTypeParams = z.infer<typeof caseTabTypeParamsSchema>
export type CourseParams = z.infer<typeof courseParamsSchema>
export type BulkUpdateCaseTabInput = z.infer<typeof bulkUpdateCaseTabSchema>
export type CreateAllTabsInput = z.infer<typeof createAllTabsSchema>
export type CaseTabResponse = z.infer<typeof caseTabResponseSchema>
export type CaseTabStatsResponse = z.infer<typeof caseTabStatsResponseSchema>
export type CourseTabsOverviewResponse = z.infer<typeof courseTabsOverviewResponseSchema>


================================================
File: src/entities/case-tab/case-tab.service.ts
================================================
import { PrismaClient } from '@prisma/client'
import { CreateCaseTabInput, UpdateCaseTabInput, CaseTabType } from './case-tab.schema'

export class CaseTabService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateCaseTabInput) {
    // Verify the course case exists
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id: data.courseCaseId },
      include: {
        course: {
          include: { exam: true }
        }
      }
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    // Check if this case already has a tab of this type
    const existingTab = await this.prisma.caseTab.findUnique({
      where: {
        courseCaseId_tabType: {
          courseCaseId: data.courseCaseId,
          tabType: data.tabType
        }
      }
    })

    if (existingTab) {
      throw new Error(`Case already has a ${data.tabType} tab`)
    }

    return await this.prisma.caseTab.create({
      data: {
        courseCaseId: data.courseCaseId,
        tabType: data.tabType,
        content: data.content
      },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  async findAll() {
    return await this.prisma.caseTab.findMany({
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: [
        { courseCase: { title: 'asc' } },
        { tabType: 'asc' }
      ]
    })
  }

  async findById(id: string) {
    const caseTab = await this.prisma.caseTab.findUnique({
      where: { id },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!caseTab) {
      throw new Error('Case tab not found')
    }

    return caseTab
  }

  async findByCourseCase(courseCaseId: string) {
    // Verify course case exists
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id: courseCaseId }
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    return await this.prisma.caseTab.findMany({
      where: { courseCaseId },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: { tabType: 'asc' }
    })
  }

  async findByTabType(courseCaseId: string, tabType: CaseTabType) {
    const caseTab = await this.prisma.caseTab.findUnique({
      where: {
        courseCaseId_tabType: {
          courseCaseId,
          tabType
        }
      },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!caseTab) {
      throw new Error(`${tabType} tab not found for this case`)
    }

    return caseTab
  }

  async update(id: string, data: UpdateCaseTabInput) {
    // Check if case tab exists
    await this.findById(id)

    return await this.prisma.caseTab.update({
      where: { id },
      data,
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  async delete(id: string) {
    // Check if case tab exists
    await this.findById(id)

    return await this.prisma.caseTab.delete({
      where: { id }
    })
  }

  // BUSINESS LOGIC METHODS

  async createAllTabsForCase(courseCaseId: string) {
    // Verify course case exists
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id: courseCaseId }
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    // Check if any tabs already exist
    const existingTabs = await this.prisma.caseTab.findMany({
      where: { courseCaseId }
    })

    if (existingTabs.length > 0) {
      throw new Error('Some tabs already exist for this case')
    }

    // Create all 3 tabs with empty content arrays - ADJUSTED
    const tabTypes: CaseTabType[] = ['DOCTORS_NOTE', 'PATIENT_SCRIPT', 'MEDICAL_NOTES']
    
    const tabs = await Promise.all(
      tabTypes.map((tabType: CaseTabType) => 
        this.prisma.caseTab.create({
          data: {
            courseCaseId,
            tabType,
            content: [] // Start with empty array
          },
          include: {
            courseCase: {
              include: {
                course: {
                  include: {
                    exam: {
                      select: {
                        id: true,
                        title: true,
                        slug: true
                      }
                    }
                  }
                }
              }
            }
          }
        })
      )
    )

    return tabs
  }

  async getCaseTabStats(courseCaseId: string) {
    const tabs = await this.prisma.caseTab.findMany({
      where: { courseCaseId },
      select: {
        tabType: true,
        content: true,
        updatedAt: true
      }
    })

    return {
      courseCaseId,
      totalTabs: tabs.length,
      completedTabs: tabs.filter((tab: { content: string[] }) => tab.content && tab.content.length > 0).length,
      emptyTabs: tabs.filter((tab: { content: string[] }) => !tab.content || tab.content.length === 0).length,
      tabDetails: tabs.map((tab: { tabType: any; content: string[]; updatedAt: Date }) => ({
        tabType: tab.tabType,
        hasContent: !!(tab.content && tab.content.length > 0),
        contentItems: tab.content?.length || 0,
        totalContentLength: tab.content?.reduce((sum, item) => sum + item.length, 0) || 0,
        lastUpdated: tab.updatedAt
      }))
    }
  }

  async getCourseTabsOverview(courseId: string) {
    // Get all cases for this course
    const courseCases = await this.prisma.courseCase.findMany({
      where: { courseId },
      include: {
        caseTabs: {
          select: {
            tabType: true,
            content: true
          }
        }
      }
    })

    const overview = courseCases.map((courseCase: { 
      id: string; 
      title: string; 
      caseTabs: Array<{ tabType: any; content: string[] }> 
    }) => ({
      caseId: courseCase.id,
      caseTitle: courseCase.title,
      totalTabs: courseCase.caseTabs.length,
      completedTabs: courseCase.caseTabs.filter((tab: { content: string[] }) => tab.content && tab.content.length > 0).length,
      // ADJUSTED: Completion percentage based on 3 tabs
      completionPercentage: courseCase.caseTabs.length > 0 
        ? Math.round((courseCase.caseTabs.filter((tab: { content: string[] }) => tab.content && tab.content.length > 0).length / 3) * 100)
        : 0
    }))

    return {
      courseId,
      totalCases: courseCases.length,
      // ADJUSTED: Check for 3 tabs
      casesWithAllTabs: overview.filter((item: { totalTabs: number }) => item.totalTabs === 3).length,
      casesWithCompletedContent: overview.filter((item: { completedTabs: number }) => item.completedTabs === 3).length,
      averageCompletion: overview.length > 0 
        ? Math.round(overview.reduce((sum: number, item: { completionPercentage: number }) => sum + item.completionPercentage, 0) / overview.length)
        : 0,
      caseDetails: overview
    }
  }

  async bulkUpdateTabContent(courseCaseId: string, tabUpdates: { tabType: CaseTabType; content: string[] }[]) {
    // Verify course case exists
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id: courseCaseId }
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    // Update all tabs in a transaction
    const updatedTabs = await this.prisma.$transaction(
      tabUpdates.map((update: { tabType: CaseTabType; content: string[] }) => 
        this.prisma.caseTab.upsert({
          where: {
            courseCaseId_tabType: {
              courseCaseId,
              tabType: update.tabType
            }
          },
          update: {
            content: update.content
          },
          create: {
            courseCaseId,
            tabType: update.tabType,
            content: update.content
          },
          include: {
            courseCase: {
              include: {
                course: {
                  include: {
                    exam: {
                      select: {
                        id: true,
                        title: true,
                        slug: true
                      }
                    }
                  }
                }
              }
            }
          }
        })
      )
    )

    return updatedTabs
  }

  // Helper method to add a single item to content array
  async addContentItem(id: string, contentItem: string) {
    const caseTab = await this.findById(id)
    
    return await this.prisma.caseTab.update({
      where: { id },
      data: {
        content: [...(caseTab.content || []), contentItem]
      },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  // Helper method to remove a content item by index
  async removeContentItem(id: string, index: number) {
    const caseTab = await this.findById(id)
    
    if (!caseTab.content || index < 0 || index >= caseTab.content.length) {
      throw new Error('Invalid content index')
    }
    
    const newContent = [...caseTab.content]
    newContent.splice(index, 1)
    
    return await this.prisma.caseTab.update({
      where: { id },
      data: {
        content: newContent
      },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  // Helper method to update a specific content item by index
  async updateContentItem(id: string, index: number, newContent: string) {
    const caseTab = await this.findById(id)
    
    if (!caseTab.content || index < 0 || index >= caseTab.content.length) {
      throw new Error('Invalid content index')
    }
    
    const updatedContent = [...caseTab.content]
    updatedContent[index] = newContent
    
    return await this.prisma.caseTab.update({
      where: { id },
      data: {
        content: updatedContent
      },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }
}


================================================
File: src/entities/course/course.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { z } from 'zod'
import { CourseService } from './course.service'
import { 
  createCourseSchema, 
  updateCourseSchema, 
  courseParamsSchema,
  courseExamParamsSchema,
  courseInstructorParamsSchema,
  updateCourseInfoPointsSchema,
  CourseStyleEnum
} from './course.schema'

// Business operation schemas
const pricingUpdateSchema = z.object({
  price3Months: z.number().positive().max(99999.99).transform(val => Number(val.toFixed(2))).optional(),
  price6Months: z.number().positive().max(99999.99).transform(val => Number(val.toFixed(2))).optional(),
  price12Months: z.number().positive().max(99999.99).transform(val => Number(val.toFixed(2))).optional()
})

const creditsUpdateSchema = z.object({
  credits3Months: z.number().int().min(0).max(1000).optional(),
  credits6Months: z.number().int().min(0).max(1000).optional(),
  credits12Months: z.number().int().min(0).max(1000).optional()
})

const styleParamsSchema = z.object({
  style: CourseStyleEnum
})

export default async function courseRoutes(fastify: FastifyInstance) {
  const courseService = new CourseService(fastify.prisma)

  // GET /courses - Get all courses
  fastify.get('/courses', async (request, reply) => {
    try {
      const courses = await courseService.findAll()
      reply.send(courses)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch courses' })
    }
  })

  // GET /courses/published - Get only published courses (public endpoint)
  fastify.get('/courses/published', async (request, reply) => {
    try {
      const courses = await courseService.findPublished()
      reply.send(courses)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch published courses' })
    }
  })

  // GET /courses/style/:style - Get courses by style (RANDOM/STRUCTURED)
  fastify.get('/courses/style/:style', async (request, reply) => {
    try {
      const { style } = styleParamsSchema.parse(request.params)
      const courses = await courseService.findByStyle(style)
      reply.send(courses)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid course style' })
    }
  })

  // GET /courses/exam/:examId - Get courses by exam
  fastify.get('/courses/exam/:examId', async (request, reply) => {
    try {
      const { examId } = courseExamParamsSchema.parse(request.params)
      const courses = await courseService.findByExam(examId)
      reply.send(courses)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /courses/instructor/:instructorId - Get courses by instructor
  fastify.get('/courses/instructor/:instructorId', async (request, reply) => {
    try {
      const { instructorId } = courseInstructorParamsSchema.parse(request.params)
      const courses = await courseService.findByInstructor(instructorId)
      reply.send(courses)
    } catch (error) {
      if (error instanceof Error && error.message === 'Instructor not found') {
        reply.status(404).send({ error: 'Instructor not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /courses/:id - Get course by ID
  fastify.get('/courses/:id', async (request, reply) => {
    try {
      const { id } = courseParamsSchema.parse(request.params)
      const course = await courseService.findById(id)
      reply.send(course)
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /courses/:id/pricing - Get pricing information for a course
  fastify.get('/courses/:id/pricing', async (request, reply) => {
    try {
      const { id } = courseParamsSchema.parse(request.params)
      const pricingInfo = await courseService.getPricingInfo(id)
      reply.send(pricingInfo)
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /courses - Create new course
  fastify.post('/courses', async (request, reply) => {
    try {
      const data = createCourseSchema.parse(request.body)
      const course = await courseService.create(data)
      reply.status(201).send(course)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Instructor not found') {
          reply.status(404).send({ error: 'Instructor not found' })
        } else if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message === 'Instructor can only create courses for their own exams') {
          reply.status(403).send({ error: 'Instructor can only create courses for their own exams' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PUT /courses/:id - Update course
  fastify.put('/courses/:id', async (request, reply) => {
    try {
      const { id } = courseParamsSchema.parse(request.params)
      const data = updateCourseSchema.parse(request.body)
      const course = await courseService.update(id, data)
      reply.send(course)
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // PATCH /courses/:id/toggle - Toggle course published status
  fastify.patch('/courses/:id/toggle', async (request, reply) => {
    try {
      const { id } = courseParamsSchema.parse(request.params)
      const course = await courseService.togglePublished(id)
      reply.send({
        message: `Course ${course.isPublished ? 'published' : 'unpublished'} successfully`,
        course
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // PATCH /courses/:id/pricing - Update course pricing
  fastify.patch('/courses/:id/pricing', async (request, reply) => {
    try {
      const { id } = courseParamsSchema.parse(request.params)
      const pricing = pricingUpdateSchema.parse(request.body)
      const course = await courseService.updatePricing(id, pricing)
      reply.send({
        message: 'Course pricing updated successfully',
        course
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid pricing data' })
      }
    }
  })

  // PATCH /courses/:id/credits - Update course credit allocation
  fastify.patch('/courses/:id/credits', async (request, reply) => {
    try {
      const { id } = courseParamsSchema.parse(request.params)
      const credits = creditsUpdateSchema.parse(request.body)
      const course = await courseService.updateCredits(id, credits)
      reply.send({
        message: 'Course credit allocation updated successfully',
        course
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid credits data' })
      }
    }
  })

  // PATCH /courses/:id/info-points - Update course info points
  fastify.patch('/courses/:id/info-points', async (request, reply) => {
    try {
      const { id } = courseParamsSchema.parse(request.params)
      const { infoPoints } = updateCourseInfoPointsSchema.parse(request.body)
      
      const course = await courseService.update(id, { infoPoints })
      
      reply.send({
        message: 'Course info points updated successfully',
        course
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid info points data' })
      }
    }
  })

  // DELETE /courses/:id - Delete course
  fastify.delete('/courses/:id', async (request, reply) => {
    try {
      const { id } = courseParamsSchema.parse(request.params)
      await courseService.delete(id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })
}


================================================
File: src/entities/course/course.schema.ts
================================================
import { z } from 'zod'

// CourseStyle enum
export const CourseStyleEnum = z.enum(['RANDOM', 'STRUCTURED'])

// Create Course Schema (includes business validation)
export const createCourseSchema = z.object({
  examId: z.string().uuid('Invalid exam ID'),
  instructorId: z.string().uuid('Invalid instructor ID'),
  title: z.string()
    .min(1, 'Title is required')
    .max(200, 'Title must be less than 200 characters')
    .trim(),
  description: z.string()
    .max(1000, 'Description must be less than 1000 characters')
    .optional(),
  style: CourseStyleEnum.default('RANDOM'),
  
  // Info points - array of strings
  infoPoints: z.array(z.string().trim().min(1, 'Info point cannot be empty'))
    .max(10, 'Maximum 10 info points allowed')
    .optional()
    .default([]),
  
  // Pricing validation (business rules)
  price3Months: z.number()
    .positive('3-month price must be positive')
    .max(99999.99, 'Price too high')
    .transform(val => Number(val.toFixed(2))),
  price6Months: z.number()
    .positive('6-month price must be positive') 
    .max(99999.99, 'Price too high')
    .transform(val => Number(val.toFixed(2))),
  price12Months: z.number()
    .positive('12-month price must be positive')
    .max(99999.99, 'Price too high')
    .transform(val => Number(val.toFixed(2))),
    
  // Credit allocation validation
  credits3Months: z.number()
    .int('Credits must be whole numbers')
    .min(0, 'Credits cannot be negative')
    .max(1000, 'Credits too high'),
  credits6Months: z.number()
    .int('Credits must be whole numbers')
    .min(0, 'Credits cannot be negative')
    .max(1000, 'Credits too high'),
  credits12Months: z.number()
    .int('Credits must be whole numbers')
    .min(0, 'Credits cannot be negative')
    .max(1000, 'Credits too high'),
    
  isPublished: z.boolean().default(false).optional()
}).refine((data) => {
  // Business rule: 6-month should be cheaper per month than 3-month
  const monthly3 = data.price3Months / 3
  const monthly6 = data.price6Months / 6
  return monthly6 <= monthly3
}, {
  message: '6-month plan should offer better value than 3-month plan',
  path: ['price6Months']
}).refine((data) => {
  // Business rule: 12-month should be cheapest per month
  const monthly6 = data.price6Months / 6
  const monthly12 = data.price12Months / 12
  return monthly12 <= monthly6
}, {
  message: '12-month plan should offer best value',
  path: ['price12Months']
}).refine((data) => {
  // Business rule: Longer subscriptions should have more credits
  return data.credits6Months >= data.credits3Months && 
         data.credits12Months >= data.credits6Months
}, {
  message: 'Longer subscriptions should include more credits',
  path: ['credits12Months']
})

// Update Course Schema
export const updateCourseSchema = z.object({
  title: z.string()
    .min(1, 'Title is required')
    .max(200, 'Title must be less than 200 characters')
    .trim()
    .optional(),
  description: z.string()
    .max(1000, 'Description must be less than 1000 characters')
    .optional(),
  infoPoints: z.array(z.string().trim().min(1, 'Info point cannot be empty'))
    .max(10, 'Maximum 10 info points allowed')
    .optional(),
  price3Months: z.number()
    .positive('3-month price must be positive')
    .max(99999.99, 'Price too high')
    .transform(val => Number(val.toFixed(2)))
    .optional(),
  price6Months: z.number()
    .positive('6-month price must be positive')
    .max(99999.99, 'Price too high')
    .transform(val => Number(val.toFixed(2)))
    .optional(),
  price12Months: z.number()
    .positive('12-month price must be positive')
    .max(99999.99, 'Price too high')
    .transform(val => Number(val.toFixed(2)))
    .optional(),
  credits3Months: z.number()
    .int('Credits must be whole numbers')
    .min(0, 'Credits cannot be negative')
    .max(1000, 'Credits too high')
    .optional(),
  credits6Months: z.number()
    .int('Credits must be whole numbers')
    .min(0, 'Credits cannot be negative')
    .max(1000, 'Credits too high')
    .optional(),
  credits12Months: z.number()
    .int('Credits must be whole numbers')
    .min(0, 'Credits cannot be negative')
    .max(1000, 'Credits too high')
    .optional(),
  isPublished: z.boolean().optional()
})

// Add info points update schema for easier management
export const updateCourseInfoPointsSchema = z.object({
  infoPoints: z.array(z.string().trim().min(1, 'Info point cannot be empty'))
    .max(10, 'Maximum 10 info points allowed')
})

// URL Params Schemas
export const courseParamsSchema = z.object({
  id: z.string().uuid('Invalid course ID')
})

export const courseExamParamsSchema = z.object({
  examId: z.string().uuid('Invalid exam ID')
})

export const courseInstructorParamsSchema = z.object({
  instructorId: z.string().uuid('Invalid instructor ID')
})

// Response Schema
export const courseResponseSchema = z.object({
  id: z.string(),
  examId: z.string(),
  instructorId: z.string(),
  title: z.string(),
  description: z.string().nullable(),
  style: CourseStyleEnum,
  infoPoints: z.array(z.string()), // Added info points
  price3Months: z.number(),
  price6Months: z.number(),
  price12Months: z.number(),
  credits3Months: z.number(),
  credits6Months: z.number(),
  credits12Months: z.number(),
  isPublished: z.boolean(),
  createdAt: z.date(),
  updatedAt: z.date(),
  exam: z.object({
    id: z.string(),
    title: z.string(),
    slug: z.string(),
    isActive: z.boolean()
  }),
  instructor: z.object({
    id: z.string(),
    firstName: z.string(),
    lastName: z.string(),
    bio: z.string().nullable()
  })
})

// Type exports
export type CreateCourseInput = z.infer<typeof createCourseSchema>
export type UpdateCourseInput = z.infer<typeof updateCourseSchema>
export type UpdateCourseInfoPointsInput = z.infer<typeof updateCourseInfoPointsSchema>
export type CourseParams = z.infer<typeof courseParamsSchema>
export type CourseExamParams = z.infer<typeof courseExamParamsSchema>
export type CourseInstructorParams = z.infer<typeof courseInstructorParamsSchema>
export type CourseResponse = z.infer<typeof courseResponseSchema>
export type CourseStyle = z.infer<typeof CourseStyleEnum>


================================================
File: src/entities/course/course.service.ts
================================================
import { PrismaClient } from '@prisma/client'
import { CreateCourseInput, UpdateCourseInput, CourseStyle } from './course.schema'

export class CourseService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateCourseInput) {
    // Verify the instructor exists
    const instructor = await this.prisma.instructor.findUnique({
      where: { id: data.instructorId }
    })

    if (!instructor) {
      throw new Error('Instructor not found')
    }

    // Verify the exam exists and belongs to the instructor
    const exam = await this.prisma.exam.findUnique({
      where: { id: data.examId }
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    if (exam.instructorId !== data.instructorId) {
      throw new Error('Instructor can only create courses for their own exams')
    }

    return await this.prisma.course.create({
      data: {
        examId: data.examId,
        instructorId: data.instructorId,
        title: data.title,
        description: data.description,
        style: data.style,
        infoPoints: data.infoPoints || [],  // ADDED THIS LINE
        price3Months: data.price3Months,
        price6Months: data.price6Months,
        price12Months: data.price12Months,
        credits3Months: data.credits3Months,
        credits6Months: data.credits6Months,
        credits12Months: data.credits12Months,
        isPublished: data.isPublished ?? false
      },
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })
  }

  async findAll() {
    return await this.prisma.course.findMany({
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async findPublished() {
    return await this.prisma.course.findMany({
      where: { 
        isPublished: true,
        exam: { isActive: true } // Only show courses for active exams
      },
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      },
      orderBy: {
        title: 'asc'
      }
    })
  }

  async findByStyle(style: CourseStyle) {
    return await this.prisma.course.findMany({
      where: { 
        style,
        isPublished: true,
        exam: { isActive: true }
      },
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      },
      orderBy: {
        title: 'asc'
      }
    })
  }

  async findById(id: string) {
    const course = await this.prisma.course.findUnique({
      where: { id },
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })

    if (!course) {
      throw new Error('Course not found')
    }

    return course
  }

  async findByExam(examId: string) {
    // Verify exam exists
    const exam = await this.prisma.exam.findUnique({
      where: { id: examId }
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    return await this.prisma.course.findMany({
      where: { examId },
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async findByInstructor(instructorId: string) {
    // Verify instructor exists
    const instructor = await this.prisma.instructor.findUnique({
      where: { id: instructorId }
    })

    if (!instructor) {
      throw new Error('Instructor not found')
    }

    return await this.prisma.course.findMany({
      where: { instructorId },
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async update(id: string, data: UpdateCourseInput) {
    // Check if course exists
    const course = await this.findById(id)

    return await this.prisma.course.update({
      where: { id },
      data,  // This already includes infoPoints if provided
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })
  }

  async delete(id: string) {
    // Check if course exists
    await this.findById(id)

    return await this.prisma.course.delete({
      where: { id }
    })
  }

  async togglePublished(id: string) {
    const course = await this.findById(id)
    
    return await this.prisma.course.update({
      where: { id },
      data: { isPublished: !course.isPublished },
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })
  }

  // BUSINESS LOGIC METHODS

  async updatePricing(id: string, pricing: {
    price3Months?: number
    price6Months?: number
    price12Months?: number
  }) {
    const course = await this.findById(id)
    
    return await this.prisma.course.update({
      where: { id },
      data: pricing,
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })
  }

  async updateCredits(id: string, credits: {
    credits3Months?: number
    credits6Months?: number
    credits12Months?: number
  }) {
    const course = await this.findById(id)
    
    return await this.prisma.course.update({
      where: { id },
      data: credits,
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })
  }

  async updateInfoPoints(id: string, infoPoints: string[]) {
    const course = await this.findById(id)
    
    return await this.prisma.course.update({
      where: { id },
      data: { infoPoints },
      include: {
        exam: {
          select: {
            id: true,
            title: true,
            slug: true,
            isActive: true
          }
        },
        instructor: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            bio: true
          }
        }
      }
    })
  }

  async getPricingInfo(id: string) {
    const course = await this.findById(id)
    
    return {
      courseId: course.id,
      title: course.title,
      infoPoints: course.infoPoints || [],  // Include info points in pricing info
      pricing: {
        threeMonths: {
          price: course.price3Months,
          credits: course.credits3Months,
          pricePerMonth: Number((Number(course.price3Months) / 3).toFixed(2))
        },
        sixMonths: {
          price: course.price6Months,
          credits: course.credits6Months,
          pricePerMonth: Number((Number(course.price6Months) / 6).toFixed(2))
        },
        twelveMonths: {
          price: course.price12Months,
          credits: course.credits12Months,
          pricePerMonth: Number((Number(course.price12Months) / 12).toFixed(2))
        }
      }
    }
  }
}


================================================
File: src/entities/course-case/course-case.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { z } from 'zod'
import { CourseCaseService } from './course-case.service'
import { 
  createCourseCaseSchema, 
  updateCourseCaseSchema, 
  courseCaseParamsSchema,
  courseCaseCourseParamsSchema,
  reorderCourseCaseSchema,
  PatientGenderEnum,
  createCompleteCourseCaseSchema,  // NEW
  updateCompleteCourseCaseSchema   // NEW
} from './course-case.schema'

import {
  assignSpecialtiesSchema,
  assignCurriculumsSchema,
  filterCasesSchema,
  bulkAssignFiltersSchema,
  removeSpecialtySchema,
  removeCurriculumSchema,
  courseCaseParamsSchema as junctionCourseCaseParamsSchema,
  courseParamsSchema,
  specialtyRemoveParamsSchema,
  curriculumRemoveParamsSchema,
  filterQuerySchema
} from '../../shared/junction-tables.schema'

import { MarkingCriterionService } from '../marking-criterion/marking-criterion.service'

// Additional schemas for query parameters
const genderParamsSchema = z.object({
  courseId: z.string().uuid('Invalid course ID'),
  gender: PatientGenderEnum
})

export default async function courseCaseRoutes(fastify: FastifyInstance) {
  const courseCaseService = new CourseCaseService(fastify.prisma)
  const markingCriterionService = new MarkingCriterionService(fastify.prisma)

  // GET /course-cases - Get all course cases
  fastify.get('/course-cases', async (request, reply) => {
    try {
      const courseCases = await courseCaseService.findAll()
      reply.send(courseCases)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch course cases' })
    }
  })

  // GET /course-cases/course/:courseId - Get cases by course
  fastify.get('/course-cases/course/:courseId', async (request, reply) => {
    try {
      const { courseId } = courseCaseCourseParamsSchema.parse(request.params)
      const courseCases = await courseCaseService.findByCourse(courseId)
      reply.send(courseCases)
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /course-cases/course/:courseId/free - Get free cases by course
  fastify.get('/course-cases/course/:courseId/free', async (request, reply) => {
    try {
      const { courseId } = courseCaseCourseParamsSchema.parse(request.params)
      const courseCases = await courseCaseService.findFreeCases(courseId)
      reply.send(courseCases)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /course-cases/course/:courseId/paid - Get paid cases by course
  fastify.get('/course-cases/course/:courseId/paid', async (request, reply) => {
    try {
      const { courseId } = courseCaseCourseParamsSchema.parse(request.params)
      const courseCases = await courseCaseService.findPaidCases(courseId)
      reply.send(courseCases)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /course-cases/course/:courseId/gender/:gender - Get cases by patient gender
  fastify.get('/course-cases/course/:courseId/gender/:gender', async (request, reply) => {
    try {
      const { courseId, gender } = genderParamsSchema.parse(request.params)
      const courseCases = await courseCaseService.findByGender(courseId, gender)
      reply.send(courseCases)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /course-cases/course/:courseId/stats - Get course case statistics
  fastify.get('/course-cases/course/:courseId/stats', async (request, reply) => {
    try {
      const { courseId } = courseCaseCourseParamsSchema.parse(request.params)
      const stats = await courseCaseService.getCaseStats(courseId)
      reply.send(stats)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /course-cases/course/:courseId/age-range - Get age range statistics
  fastify.get('/course-cases/course/:courseId/age-range', async (request, reply) => {
    try {
      const { courseId } = courseCaseCourseParamsSchema.parse(request.params)
      const ageRange = await courseCaseService.getAgeRange(courseId)
      reply.send(ageRange)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /course-cases/:id - Get course case by ID
  fastify.get('/course-cases/:id', async (request, reply) => {
    try {
      const { id } = courseCaseParamsSchema.parse(request.params)
      const courseCase = await courseCaseService.findById(id)
      reply.send(courseCase)
    } catch (error) {
      if (error instanceof Error && error.message === 'Course case not found') {
        reply.status(404).send({ error: 'Course case not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /course-cases - Create new course case
  fastify.post('/course-cases', async (request, reply) => {
    try {
      const data = createCourseCaseSchema.parse(request.body)
      const courseCase = await courseCaseService.create(data)
      reply.status(201).send(courseCase)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course not found') {
          reply.status(404).send({ error: 'Course not found' })
        } else if (error.message === 'Cases can only be added to RANDOM style courses') {
          reply.status(400).send({ error: 'Cases can only be added to RANDOM style courses' })
        } else if (error.message.includes('Display order') && error.message.includes('already taken')) {
          reply.status(400).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PUT /course-cases/:id - Update course case
  fastify.put('/course-cases/:id', async (request, reply) => {
    try {
      const { id } = courseCaseParamsSchema.parse(request.params)
      const data = updateCourseCaseSchema.parse(request.body)
      const courseCase = await courseCaseService.update(id, data)
      reply.send(courseCase)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message.includes('Display order') && error.message.includes('already taken')) {
          reply.status(400).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PATCH /course-cases/:id/toggle-free - Toggle case free status
  fastify.patch('/course-cases/:id/toggle-free', async (request, reply) => {
    try {
      const { id } = courseCaseParamsSchema.parse(request.params)
      const courseCase = await courseCaseService.toggleFree(id)
      reply.send({
        message: `Case ${courseCase.isFree ? 'marked as free' : 'marked as paid'} successfully`,
        courseCase
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Course case not found') {
        reply.status(404).send({ error: 'Course case not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // PATCH /course-cases/:id/reorder - Reorder course case
  fastify.patch('/course-cases/:id/reorder', async (request, reply) => {
    try {
      const { id } = courseCaseParamsSchema.parse(request.params)
      const { newOrder } = reorderCourseCaseSchema.parse(request.body)
      const courseCase = await courseCaseService.reorder(id, newOrder)
      reply.send({
        message: `Case reordered to position ${newOrder} successfully`,
        courseCase
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message.includes('Display order') && error.message.includes('already taken')) {
          reply.status(400).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // DELETE /course-cases/:id - Delete course case
  fastify.delete('/course-cases/:id', async (request, reply) => {
    try {
      const { id } = courseCaseParamsSchema.parse(request.params)
      await courseCaseService.delete(id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'Course case not found') {
        reply.status(404).send({ error: 'Course case not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /course-cases/course/:courseId/filtered - Get filtered cases
  fastify.get('/course-cases/course/:courseId/filtered', async (request, reply) => {
    try {
      const { courseId } = courseParamsSchema.parse(request.params)
      const filters = filterQuerySchema.parse(request.query)
      
      const courseCases = await courseCaseService.findByFilters(courseId, {
        specialtyIds: filters.specialtyIds,
        curriculumIds: filters.curriculumIds,
        isFree: filters.isFree,
        patientGender: filters.patientGender
      })
      
      reply.send(courseCases)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid filter parameters' })
    }
  })

  // GET /course-cases/:courseCaseId/specialties - Get case specialties
  fastify.get('/course-cases/:courseCaseId/specialties', async (request, reply) => {
    try {
      const { courseCaseId } = junctionCourseCaseParamsSchema.parse(request.params)
      const specialties = await courseCaseService.getCaseSpecialties(courseCaseId)
      reply.send(specialties)
    } catch (error) {
      if (error instanceof Error && error.message === 'Course case not found') {
        reply.status(404).send({ error: 'Course case not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /course-cases/:courseCaseId/curriculums - Get case curriculum items
  fastify.get('/course-cases/:courseCaseId/curriculums', async (request, reply) => {
    try {
      const { courseCaseId } = junctionCourseCaseParamsSchema.parse(request.params)
      const curriculums = await courseCaseService.getCaseCurriculums(courseCaseId)
      reply.send(curriculums)
    } catch (error) {
      if (error instanceof Error && error.message === 'Course case not found') {
        reply.status(404).send({ error: 'Course case not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /course-cases/assign-specialties - Assign specialties to case
  fastify.post('/course-cases/assign-specialties', async (request, reply) => {
    try {
      const { courseCaseId, specialtyIds } = assignSpecialtiesSchema.parse(request.body)
      const result = await courseCaseService.assignSpecialties(courseCaseId, specialtyIds)
      reply.send({
        message: 'Specialties assigned successfully',
        assignments: result,
        courseCaseId,
        specialtiesCount: specialtyIds.length
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message === 'One or more specialties not found') {
          reply.status(404).send({ error: 'One or more specialties not found' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /course-cases/assign-curriculums - Assign curriculum items to case
  fastify.post('/course-cases/assign-curriculums', async (request, reply) => {
    try {
      const { courseCaseId, curriculumIds } = assignCurriculumsSchema.parse(request.body)
      const result = await courseCaseService.assignCurriculums(courseCaseId, curriculumIds)
      reply.send({
        message: 'Curriculum items assigned successfully',
        assignments: result,
        courseCaseId,
        curriculumsCount: curriculumIds.length
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message === 'One or more curriculum items not found') {
          reply.status(404).send({ error: 'One or more curriculum items not found' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /course-cases/bulk-assign-filters - Bulk assign filters to multiple cases
  fastify.post('/course-cases/bulk-assign-filters', async (request, reply) => {
    try {
      const { assignments } = bulkAssignFiltersSchema.parse(request.body)
      const result = await courseCaseService.bulkAssignFilters(assignments)
      reply.send({
        message: 'Bulk assignment completed successfully',
        result,
        processedCases: assignments.length
      })
    } catch (error) {
      if (error instanceof Error) {
        reply.status(400).send({ error: error.message })
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // DELETE /course-cases/:courseCaseId/specialties/:specialtyId - Remove specialty
  fastify.delete('/course-cases/:courseCaseId/specialties/:specialtyId', async (request, reply) => {
    try {
      const { courseCaseId, specialtyId } = specialtyRemoveParamsSchema.parse(request.params)
      const result = await courseCaseService.removeSpecialty(courseCaseId, specialtyId)
      reply.send(result)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message === 'Specialty assignment not found') {
          reply.status(404).send({ error: 'Specialty assignment not found' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // DELETE /course-cases/:courseCaseId/curriculums/:curriculumId - Remove curriculum
  fastify.delete('/course-cases/:courseCaseId/curriculums/:curriculumId', async (request, reply) => {
    try {
      const { courseCaseId, curriculumId } = curriculumRemoveParamsSchema.parse(request.params)
      const result = await courseCaseService.removeCurriculum(courseCaseId, curriculumId)
      reply.send(result)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message === 'Curriculum assignment not found') {
          reply.status(404).send({ error: 'Curriculum assignment not found' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // GET /course-cases/course/:courseId/filtering-stats - Get filtering statistics
  fastify.get('/course-cases/course/:courseId/filtering-stats', async (request, reply) => {
    try {
      const { courseId } = courseParamsSchema.parse(request.params)
      const stats = await courseCaseService.getFilteringStats(courseId)
      reply.send(stats)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // Helper endpoint for available filters
  fastify.get('/course-cases/course/:courseId/available-filters', async (request, reply) => {
    try {
      const { courseId } = courseParamsSchema.parse(request.params)
      
      // Get all specialties and curriculums used in this course
      const courseCases = await courseCaseService.findByCourse(courseId)
      
      const uniqueSpecialties = new Set()
      const uniqueCurriculums = new Set()
      const availableGenders = new Set()
      
      courseCases.forEach((courseCase: any) => {
        // Add patient gender
        availableGenders.add(courseCase.patientGender)
        
        // Add specialties
        if (courseCase.caseSpecialties) {
          courseCase.caseSpecialties.forEach((cs: any) => {
            uniqueSpecialties.add(JSON.stringify({
              id: cs.specialty.id,
              name: cs.specialty.name
            }))
          })
        }
        
        // Add curriculums
        if (courseCase.caseCurriculums) {
          courseCase.caseCurriculums.forEach((cc: any) => {
            uniqueCurriculums.add(JSON.stringify({
              id: cc.curriculum.id,
              name: cc.curriculum.name
            }))
          })
        }
      })
      
      reply.send({
        courseId,
        availableFilters: {
          specialties: Array.from(uniqueSpecialties).map((s: any) => JSON.parse(s)),
          curriculums: Array.from(uniqueCurriculums).map((c: any) => JSON.parse(c)),
          genders: Array.from(availableGenders),
          freeOptions: [true, false]
        }
      })
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // ===== NEW COMPLETE COURSE CASE ROUTES =====

  // POST /course-cases/create-complete - Create course case with all relations
  fastify.post('/course-cases/create-complete', async (request, reply) => {
    try {
      const data = createCompleteCourseCaseSchema.parse(request.body)
      const result = await courseCaseService.createCompleteCourseCase(data)
      
      reply.status(201).send({
        message: 'Course case created and configured successfully',
        ...result
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course not found') {
          reply.status(404).send({ error: 'Course not found' })
        } else if (error.message === 'Cases can only be added to RANDOM style courses') {
          reply.status(400).send({ error: 'Cases can only be added to RANDOM style courses' })
        } else if (error.message.includes('Display order') && error.message.includes('already taken')) {
          reply.status(400).send({ error: error.message })
        } else if (error.message.includes('not found')) {
          reply.status(404).send({ error: error.message })
        } else if (error.message === 'Warning time must be less than time limit') {
          reply.status(400).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid data: ' + error.message })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PUT /course-cases/update-complete - Update course case with all relations
  fastify.put('/course-cases/update-complete', async (request, reply) => {
    try {
      const data = updateCompleteCourseCaseSchema.parse(request.body)
      const result = await courseCaseService.updateCompleteCourseCase(data)
      
      reply.send({
        message: 'Course case updated successfully',
        ...result
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message.includes('Display order') && error.message.includes('already taken')) {
          reply.status(400).send({ error: error.message })
        } else if (error.message.includes('not found')) {
          reply.status(404).send({ error: error.message })
        } else if (error.message === 'Warning time must be less than time limit') {
          reply.status(400).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid data: ' + error.message })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // GET /course-cases/:id/complete - Get course case with all relations
  // GET /course-cases/:id/complete - Get course case with all relations
fastify.get('/course-cases/:id/complete', async (request, reply) => {
  try {
    const { id } = courseCaseParamsSchema.parse(request.params)
    
    // Fetch complete course case data with all relations
    const courseCase = await fastify.prisma.courseCase.findUnique({
      where: { id },
      include: {
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        },
        simulation: true,
        caseTabs: true,
        markingCriteria: {
          include: {
            markingDomain: true
          },
          orderBy: [
            { markingDomain: { name: 'asc' } },
            { displayOrder: 'asc' }
          ]
        },
        caseSpecialties: {
          include: {
            specialty: true
          }
        },
        caseCurriculums: {
          include: {
            curriculum: true
          }
        }
      }
    })
    
    if (!courseCase) {
      reply.status(404).send({ error: 'Course case not found' })
      return
    }
    
    // Format tabs response
    const tabsResponse: any = {}
    for (const tab of courseCase.caseTabs) {
      tabsResponse[tab.tabType] = {
        id: tab.id,
        content: tab.content,
        hasContent: tab.content.length > 0
      }
    }
    
    // Group marking criteria by domain
    const markingCriteriaGrouped = courseCase.markingCriteria.reduce((acc, criterion) => {
      const domainId = criterion.markingDomain.id
      const domainName = criterion.markingDomain.name
      
      let group = acc.find((g: any) => g.domainId === domainId)
      if (!group) {
        group = { domainId, domainName, criteria: [] }
        acc.push(group)
      }
      
      group.criteria.push({
        id: criterion.id,
        text: criterion.text,
        points: criterion.points,
        displayOrder: criterion.displayOrder
      })
      
      return acc
    }, [] as any[])
    
    // Extract specialties and curriculums
    const specialties = courseCase.caseSpecialties.map((cs: any) => cs.specialty)
    const curriculums = courseCase.caseCurriculums.map((cc: any) => cc.curriculum)
    
    reply.send({
      courseCase: {
        id: courseCase.id,
        courseId: courseCase.courseId,
        title: courseCase.title,
        diagnosis: courseCase.diagnosis,
        patientName: courseCase.patientName,
        patientAge: courseCase.patientAge,
        patientGender: courseCase.patientGender,
        description: courseCase.description,
        isFree: courseCase.isFree,
        displayOrder: courseCase.displayOrder,
        createdAt: courseCase.createdAt,
        updatedAt: courseCase.updatedAt
      },
      tabs: tabsResponse,
      markingCriteria: markingCriteriaGrouped,
      specialties,
      curriculums,
      simulation: courseCase.simulation,
      course: courseCase.course
    })
  } catch (error) {
    console.error('Error fetching complete course case:', error)
    reply.status(400).send({ error: 'Invalid request' })
  }
})
}


================================================
File: src/entities/course-case/course-case.schema.ts
================================================
import { z } from 'zod'
import { VoiceModelEnum } from '../simulation/simulation.schema'

// PatientGender enum
export const PatientGenderEnum = z.enum(['MALE', 'FEMALE', 'OTHER'])

// Create CourseCase Schema
export const createCourseCaseSchema = z.object({
  courseId: z.string().uuid('Invalid course ID'),
  title: z.string()
    .min(1, 'Title is required')
    .max(200, 'Title must be less than 200 characters')
    .trim(),
  diagnosis: z.string()
    .min(1, 'Diagnosis is required')
    .max(100000, 'Diagnosis must be less than 100000 characters')
    .trim(),
  patientName: z.string()
    .min(1, 'Patient name is required')
    .max(100, 'Patient name must be less than 100 characters')
    .trim(),
  patientAge: z.number()
    .int('Age must be a whole number')
    .min(0, 'Age cannot be negative')
    .max(150, 'Age must be realistic'),
  patientGender: PatientGenderEnum,
  description: z.string()
    .min(1, 'Description is required')
    .max(100000, 'Description must be less than 100000 characters')
    .trim(),
  isFree: z.boolean().default(false).optional(),
  displayOrder: z.number()
    .int('Display order must be a whole number')
    .min(1, 'Display order must be positive')
    .optional()
})

// Update CourseCase Schema
export const updateCourseCaseSchema = z.object({
  title: z.string()
    .min(1, 'Title is required')
    .max(200, 'Title must be less than 200 characters')
    .trim()
    .optional(),
  diagnosis: z.string()
    .min(1, 'Diagnosis is required')
    .max(100000, 'Diagnosis must be less than 100000 characters')
    .trim()
    .optional(),
  patientName: z.string()
    .min(1, 'Patient name is required')
    .max(100, 'Patient name must be less than 100 characters')
    .trim()
    .optional(),
  patientAge: z.number()
    .int('Age must be a whole number')
    .min(0, 'Age cannot be negative')
    .max(150, 'Age must be realistic')
    .optional(),
  patientGender: PatientGenderEnum.optional(),
  description: z.string()
    .min(1, 'Description is required')
    .max(100000, 'Description must be less than 100000 characters')
    .trim()
    .optional(),
  isFree: z.boolean().optional(),
  displayOrder: z.number()
    .int('Display order must be a whole number')
    .min(1, 'Display order must be positive')
    .optional()
})

// URL Params Schemas
export const courseCaseParamsSchema = z.object({
  id: z.string().uuid('Invalid course case ID')
})

export const courseCaseCourseParamsSchema = z.object({
  courseId: z.string().uuid('Invalid course ID')
})

// Reorder Schema
export const reorderCourseCaseSchema = z.object({
  newOrder: z.number()
    .int('Display order must be a whole number')
    .min(1, 'Display order must be positive')
})

// Response Schema
export const courseCaseResponseSchema = z.object({
  id: z.string(),
  courseId: z.string(),
  title: z.string(),
  diagnosis: z.string(),
  patientName: z.string(),
  patientAge: z.number(),
  patientGender: PatientGenderEnum,
  description: z.string(),
  isFree: z.boolean(),
  displayOrder: z.number(),
  createdAt: z.date(),
  updatedAt: z.date(),
  course: z.object({
    id: z.string(),
    title: z.string(),
    style: z.string(),
    isPublished: z.boolean(),
    exam: z.object({
      id: z.string(),
      title: z.string(),
      slug: z.string()
    })
  })
})

// Complete Course Case Schemas
export const createCompleteCourseCaseSchema = z.object({
  // Basic course case info
  courseCase: z.object({
    courseId: z.string().uuid('Invalid course ID'),
    title: z.string()
      .min(1, 'Title is required')
      .max(200, 'Title must be less than 200 characters')
      .trim(),
    diagnosis: z.string()
      .min(1, 'Diagnosis is required')
      .max(100000, 'Diagnosis must be less than 100000 characters')
      .trim(),
    patientName: z.string()
      .min(1, 'Patient name is required')
      .max(100, 'Patient name must be less than 100 characters')
      .trim(),
    patientAge: z.number()
      .int('Age must be a whole number')
      .min(0, 'Age cannot be negative')
      .max(150, 'Age must be realistic'),
    patientGender: PatientGenderEnum,
    description: z.string()
      .min(1, 'Description is required')
      .max(100000, 'Description must be less than 100000 characters')
      .trim(),
    isFree: z.boolean().default(false).optional(),
    displayOrder: z.number()
      .int('Display order must be a whole number')
      .min(1, 'Display order must be positive')
      .optional()
  }),
  
  // Tabs content - only 3 types now
  tabs: z.object({
    DOCTORS_NOTE: z.union([
      z.string(),
      z.array(z.string())
    ]).default('').transform(val => Array.isArray(val) ? val : [val]).optional(),
    PATIENT_SCRIPT: z.union([
      z.string(),
      z.array(z.string())
    ]).default('').transform(val => Array.isArray(val) ? val : [val]).optional(),
    MEDICAL_NOTES: z.union([
      z.string(),
      z.array(z.string())
    ]).default('').transform(val => Array.isArray(val) ? val : [val]).optional()
  }).optional(),
  
  // Marking criteria as separate entities
  markingCriteria: z.array(z.object({
    markingDomainId: z.string().uuid('Invalid marking domain ID'),
    text: z.string().min(1).max(500),
    points: z.number().int().min(0),
    displayOrder: z.number().int().min(0)
  })).optional(),
  
  // Existing entities (by ID)
  existing: z.object({
    specialtyIds: z.array(z.string().uuid('Invalid specialty ID')).default([]),
    curriculumIds: z.array(z.string().uuid('Invalid curriculum ID')).default([])
  }).optional(),
  
  // New entities to create
  new: z.object({
    specialties: z.array(z.object({
      name: z.string().min(1).max(100).trim()
    })).default([]),
    curriculums: z.array(z.object({
      name: z.string().min(1).max(100).trim()
    })).default([])
  }).optional(),
  
  // Simulation configuration
  simulation: z.object({
    casePrompt: z.string()
      .min(10, 'Case prompt must be at least 10 characters')
      .max(100000, 'Case prompt must be less than 100000 characters')
      .trim(),
    openingLine: z.string()
      .min(5, 'Opening line must be at least 5 characters')
      .max(500, 'Opening line must be less than 500 characters')
      .trim(),
    timeLimitMinutes: z.number()
      .int('Time limit must be a whole number')
      .min(1, 'Time limit must be at least 1 minute')
      .max(120, 'Time limit cannot exceed 120 minutes'),
    voiceModel: VoiceModelEnum,
    warningTimeMinutes: z.number()
      .int('Warning time must be a whole number')
      .min(1, 'Warning time must be at least 1 minute')
      .optional(),
    creditCost: z.number()
      .int('Credit cost must be a whole number')
      .min(1, 'Credit cost must be at least 1')
      .max(10, 'Credit cost cannot exceed 10')
      .default(1)
  }).optional()
})

// Update complete course case schema
export const updateCompleteCourseCaseSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  
  courseCase: z.object({
    title: z.string()
      .min(1, 'Title is required')
      .max(200, 'Title must be less than 200 characters')
      .trim()
      .optional(),
    diagnosis: z.string()
      .min(1, 'Diagnosis is required')
      .max(100000, 'Diagnosis must be less than 100000 characters')
      .trim()
      .optional(),
    patientName: z.string()
      .min(1, 'Patient name is required')
      .max(100, 'Patient name must be less than 100 characters')
      .trim()
      .optional(),
    patientAge: z.number()
      .int('Age must be a whole number')
      .min(0, 'Age cannot be negative')
      .max(150, 'Age must be realistic')
      .optional(),
    patientGender: PatientGenderEnum.optional(),
    description: z.string()
      .min(1, 'Description is required')
      .max(100000, 'Description must be less than 100000 characters')
      .trim()
      .optional(),
    isFree: z.boolean().optional(),
    displayOrder: z.number()
      .int('Display order must be a whole number')
      .min(1, 'Display order must be positive')
      .optional()
  }).optional(),
  
  // Tabs content - only 3 types
  tabs: z.object({
    DOCTORS_NOTE: z.union([
      z.string(),
      z.array(z.string())
    ]).transform(val => Array.isArray(val) ? val : [val]).optional(),
    PATIENT_SCRIPT: z.union([
      z.string(),
      z.array(z.string())
    ]).transform(val => Array.isArray(val) ? val : [val]).optional(),
    MEDICAL_NOTES: z.union([
      z.string(),
      z.array(z.string())
    ]).transform(val => Array.isArray(val) ? val : [val]).optional()
  }).optional(),
  
  // Marking criteria
  markingCriteria: z.array(z.object({
    id: z.string().uuid().optional(),
    markingDomainId: z.string().uuid(),
    text: z.string().min(1).max(500),
    points: z.number().int().min(0),
    displayOrder: z.number().int().min(0)
  })).optional(),
  
  existing: z.object({
    specialtyIds: z.array(z.string().uuid('Invalid specialty ID')).optional(),
    curriculumIds: z.array(z.string().uuid('Invalid curriculum ID')).optional()
  }).optional(),
  
  new: z.object({
    specialties: z.array(z.object({
      name: z.string().min(1).max(100).trim()
    })).optional(),
    curriculums: z.array(z.object({
      name: z.string().min(1).max(100).trim()
    })).optional()
  }).optional(),
  
  simulation: z.object({
    casePrompt: z.string()
      .min(10, 'Case prompt must be at least 10 characters')
      .max(100000, 'Case prompt must be less than 100000 characters')
      .trim()
      .optional(),
    openingLine: z.string()
      .min(5, 'Opening line must be at least 5 characters')
      .max(500, 'Opening line must be less than 500 characters')
      .trim()
      .optional(),
    timeLimitMinutes: z.number()
      .int('Time limit must be a whole number')
      .min(1, 'Time limit must be at least 1 minute')
      .max(120, 'Time limit cannot exceed 120 minutes')
      .optional(),
    voiceModel: VoiceModelEnum.optional(),
    warningTimeMinutes: z.number()
      .int('Warning time must be a whole number')
      .min(1, 'Warning time must be at least 1 minute')
      .optional(),
    creditCost: z.number()
      .int('Credit cost must be a whole number')
      .min(1, 'Credit cost must be at least 1')
      .max(10, 'Credit cost cannot exceed 10')
      .optional()
  }).optional()
})

// Response schema for complete course case
export const completeCourseCaseResponseSchema = z.object({
  courseCase: z.object({
    id: z.string(),
    courseId: z.string(),
    title: z.string(),
    diagnosis: z.string(),
    patientName: z.string(),
    patientAge: z.number(),
    patientGender: PatientGenderEnum,
    description: z.string(),
    isFree: z.boolean(),
    displayOrder: z.number()
  }),
  tabs: z.object({
    DOCTORS_NOTE: z.object({
      id: z.string(),
      content: z.array(z.string()),
      hasContent: z.boolean()
    }).optional(),
    PATIENT_SCRIPT: z.object({
      id: z.string(),
      content: z.array(z.string()),
      hasContent: z.boolean()
    }).optional(),
    MEDICAL_NOTES: z.object({
      id: z.string(),
      content: z.array(z.string()),
      hasContent: z.boolean()
    }).optional()
  }),
  markingCriteria: z.array(z.object({
    domainId: z.string(),
    domainName: z.string(),
    criteria: z.array(z.object({
      id: z.string(),
      text: z.string(),
      points: z.number(),
      displayOrder: z.number()
    }))
  })),
  created: z.object({
    specialties: z.array(z.object({
      id: z.string(),
      name: z.string()
    })),
    curriculums: z.array(z.object({
      id: z.string(),
      name: z.string()
    }))
  }),
  assigned: z.object({
    specialties: z.array(z.object({
      id: z.string(),
      name: z.string()
    })),
    curriculums: z.array(z.object({
      id: z.string(),
      name: z.string()
    }))
  }),
  simulation: z.object({
    id: z.string(),
    casePrompt: z.string(),
    openingLine: z.string(),
    timeLimitMinutes: z.number(),
    voiceModel: z.string(),
    warningTimeMinutes: z.number().nullable(),
    creditCost: z.number()
  }).nullable(),
  summary: z.object({
    totalSpecialties: z.number(),
    totalCurriculums: z.number(),
    newEntitiesCreated: z.number(),
    simulationCreated: z.boolean(),
    tabsCreated: z.number(),
    tabsUpdated: z.number(),
    markingCriteriaCreated: z.number()
  })
})

// Type exports
export type CreateCourseCaseInput = z.infer<typeof createCourseCaseSchema>
export type UpdateCourseCaseInput = z.infer<typeof updateCourseCaseSchema>
export type CourseCaseParams = z.infer<typeof courseCaseParamsSchema>
export type CourseCaseCourseParams = z.infer<typeof courseCaseCourseParamsSchema>
export type ReorderCourseCaseInput = z.infer<typeof reorderCourseCaseSchema>
export type CourseCaseResponse = z.infer<typeof courseCaseResponseSchema>
export type PatientGender = z.infer<typeof PatientGenderEnum>
export type CreateCompleteCourseCaseInput = z.infer<typeof createCompleteCourseCaseSchema>
export type UpdateCompleteCourseCaseInput = z.infer<typeof updateCompleteCourseCaseSchema>
export type CompleteCourseCaseResponse = z.infer<typeof completeCourseCaseResponseSchema>


================================================
File: src/entities/course-case/course-case.service.ts
================================================
// course-case.service.ts
import { PrismaClient, PatientGender, Prisma } from '@prisma/client'
import { CreateCourseCaseInput, UpdateCourseCaseInput, CreateCompleteCourseCaseInput, UpdateCompleteCourseCaseInput } from './course-case.schema'

// Define CaseTabType - should match your Prisma schema enum
type CaseTabType = 'DOCTORS_NOTE' | 'PATIENT_SCRIPT' | 'MEDICAL_NOTES'

// Filter input interface
interface FilterInput {
  specialtyIds?: string[]
  curriculumIds?: string[]
  isFree?: boolean
  patientGender?: PatientGender
}

// Bulk assignment interface
interface BulkAssignmentInput {
  courseCaseId: string
  specialtyIds?: string[]
  curriculumIds?: string[]
}

// Add type for marking criterion with domain
interface MarkingCriterionWithDomain {
  id: string
  courseCaseId: string
  markingDomainId: string
  text: string
  points: number
  displayOrder: number
  createdAt: Date
  markingDomain: {
    id: string
    name: string
  }
}

// Add type for grouped criteria
interface GroupedCriteria {
  domainId: string
  domainName: string
  criteria: {
    id: string
    text: string
    points: number
    displayOrder: number
  }[]
}

export class CourseCaseService {
  constructor(private prisma: PrismaClient) {}

  // Helper function to get standard include object for course cases
  private getStandardInclude() {
    return {
      course: {
        include: {
          exam: {
            select: {
              id: true,
              title: true,
              slug: true
            }
          }
        }
      },
      simulation: true,
      caseTabs: true,
      markingCriteria: {
        include: {
          markingDomain: true
        },
        orderBy: [
          { markingDomain: { name: Prisma.SortOrder.asc } },
          { displayOrder: Prisma.SortOrder.asc }
        ]
      },
      caseSpecialties: {
        include: {
          specialty: true
        }
      },
      caseCurriculums: {
        include: {
          curriculum: true
        }
      }
    }
  }

  // ===== BASIC CRUD OPERATIONS =====

  async create(data: CreateCourseCaseInput) {
    // Verify course exists and get course data
    const course = await this.prisma.course.findUnique({
      where: { id: data.courseId }
    })

    if (!course) {
      throw new Error('Course not found')
    }

    // Check if course style allows adding cases
    if (course.style !== 'RANDOM') {
      throw new Error('Cases can only be added to RANDOM style courses')
    }

    // Check if display order is already taken
    if (data.displayOrder) {
      const existingCase = await this.prisma.courseCase.findFirst({
        where: {
          courseId: data.courseId,
          displayOrder: data.displayOrder
        }
      })

      if (existingCase) {
        throw new Error(`Display order ${data.displayOrder} is already taken for this course`)
      }
    } else {
      // Auto-assign next display order
      const maxOrder = await this.prisma.courseCase.aggregate({
        where: { courseId: data.courseId },
        _max: { displayOrder: true }
      })
      data.displayOrder = (maxOrder._max.displayOrder || 0) + 1
    }

    return await this.prisma.courseCase.create({
      data: {
        courseId: data.courseId,
        title: data.title,
        diagnosis: data.diagnosis,
        patientName: data.patientName,
        patientAge: data.patientAge,
        patientGender: data.patientGender,
        description: data.description,
        isFree: data.isFree ?? false,
        displayOrder: data.displayOrder
      },
      include: this.getStandardInclude()
    })
  }

  async findAll() {
    return await this.prisma.courseCase.findMany({
      include: this.getStandardInclude(),
      orderBy: [
        { courseId: 'asc' },
        { displayOrder: 'asc' }
      ]
    })
  }

  async findById(id: string) {
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id },
      include: this.getStandardInclude()
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    return courseCase
  }

  async findByCourse(courseId: string) {
    // Verify course exists
    const course = await this.prisma.course.findUnique({
      where: { id: courseId }
    })

    if (!course) {
      throw new Error('Course not found')
    }

    return await this.prisma.courseCase.findMany({
      where: { courseId },
      include: this.getStandardInclude(),
      orderBy: {
        displayOrder: 'asc'
      }
    })
  }

  async findFreeCases(courseId: string) {
    return await this.prisma.courseCase.findMany({
      where: {
        courseId,
        isFree: true
      },
      include: this.getStandardInclude(),
      orderBy: {
        displayOrder: 'asc'
      }
    })
  }

  async findPaidCases(courseId: string) {
    return await this.prisma.courseCase.findMany({
      where: {
        courseId,
        isFree: false
      },
      include: this.getStandardInclude(),
      orderBy: {
        displayOrder: 'asc'
      }
    })
  }

  async findByGender(courseId: string, gender: PatientGender) {
    return await this.prisma.courseCase.findMany({
      where: {
        courseId,
        patientGender: gender
      },
      include: this.getStandardInclude(),
      orderBy: {
        displayOrder: 'asc'
      }
    })
  }

  async update(id: string, data: UpdateCourseCaseInput) {
    // Check if course case exists
    const existingCase = await this.findById(id)

    // If updating display order, check it's not taken by another case
    if (data.displayOrder && data.displayOrder !== existingCase.displayOrder) {
      const conflictingCase = await this.prisma.courseCase.findFirst({
        where: {
          courseId: existingCase.courseId,
          displayOrder: data.displayOrder,
          id: { not: id }
        }
      })

      if (conflictingCase) {
        throw new Error(`Display order ${data.displayOrder} is already taken for this course`)
      }
    }

    return await this.prisma.courseCase.update({
      where: { id },
      data,
      include: this.getStandardInclude()
    })
  }

  async delete(id: string) {
    // Check if course case exists
    await this.findById(id)

    return await this.prisma.courseCase.delete({
      where: { id }
    })
  }

  async toggleFree(id: string) {
    const courseCase = await this.findById(id)
    
    return await this.prisma.courseCase.update({
      where: { id },
      data: { isFree: !courseCase.isFree },
      include: this.getStandardInclude()
    })
  }

  async reorder(id: string, newOrder: number) {
    const courseCase = await this.findById(id)

    // Check if new order is taken by another case
    const conflictingCase = await this.prisma.courseCase.findFirst({
      where: {
        courseId: courseCase.courseId,
        displayOrder: newOrder,
        id: { not: id }
      }
    })

    if (conflictingCase) {
      throw new Error(`Display order ${newOrder} is already taken for this course`)
    }

    return await this.prisma.courseCase.update({
      where: { id },
      data: { displayOrder: newOrder },
      include: this.getStandardInclude()
    })
  }

  // ===== STATISTICS & ANALYTICS =====

  async getCaseStats(courseId: string) {
    const totalCases = await this.prisma.courseCase.count({
      where: { courseId }
    })

    const freeCases = await this.prisma.courseCase.count({
      where: { courseId, isFree: true }
    })

    const paidCases = await this.prisma.courseCase.count({
      where: { courseId, isFree: false }
    })

    const genderDistribution = await this.prisma.courseCase.groupBy({
      by: ['patientGender'],
      where: { courseId },
      _count: {
        patientGender: true
      }
    })

    const casesWithSimulations = await this.prisma.courseCase.count({
      where: {
        courseId,
        simulation: {
          isNot: null
        }
      }
    })

    return {
      courseId,
      totalCases,
      freeCases,
      paidCases,
      casesWithSimulations,
      genderDistribution: genderDistribution.map((item: { patientGender: PatientGender; _count: { patientGender: number } }) => ({
        gender: item.patientGender,
        count: item._count.patientGender
      }))
    }
  }

  async getAgeRange(courseId: string) {
    const ageStats = await this.prisma.courseCase.aggregate({
      where: { courseId },
      _min: { patientAge: true },
      _max: { patientAge: true },
      _avg: { patientAge: true }
    })

    return {
      courseId,
      minAge: ageStats._min.patientAge,
      maxAge: ageStats._max.patientAge,
      avgAge: ageStats._avg.patientAge ? Math.round(ageStats._avg.patientAge * 10) / 10 : null
    }
  }

  // ===== JUNCTION TABLE OPERATIONS =====

  async findByFilters(courseId: string, filters: FilterInput) {
    // Verify course exists
    const course = await this.prisma.course.findUnique({
      where: { id: courseId }
    })

    if (!course) {
      throw new Error('Course not found')
    }

    // Build the filter conditions
    const whereConditions: any = {
      courseId: courseId
    }

    // Add gender filter
    if (filters.patientGender) {
      whereConditions.patientGender = filters.patientGender
    }

    // Add free status filter
    if (filters.isFree !== undefined) {
      whereConditions.isFree = filters.isFree
    }

    // Add specialty filter (cases that have ALL specified specialties)
    if (filters.specialtyIds && filters.specialtyIds.length > 0) {
      whereConditions.caseSpecialties = {
        some: {
          specialtyId: { in: filters.specialtyIds }
        }
      }
    }

    // Add curriculum filter (cases that have ALL specified curriculums)
    if (filters.curriculumIds && filters.curriculumIds.length > 0) {
      whereConditions.caseCurriculums = {
        some: {
          curriculumId: { in: filters.curriculumIds }
        }
      }
    }

    const cases = await this.prisma.courseCase.findMany({
      where: whereConditions,
      include: this.getStandardInclude(),
      orderBy: {
        displayOrder: 'asc'
      }
    })

    // Transform the response to include specialties and curriculums directly
    return cases.map((caseItem: any) => ({
      id: caseItem.id,
      courseId: caseItem.courseId,
      title: caseItem.title,
      diagnosis: caseItem.diagnosis,
      patientName: caseItem.patientName,
      patientAge: caseItem.patientAge,
      patientGender: caseItem.patientGender,
      description: caseItem.description,
      isFree: caseItem.isFree,
      displayOrder: caseItem.displayOrder,
      createdAt: caseItem.createdAt,
      updatedAt: caseItem.updatedAt,
      specialties: caseItem.caseSpecialties.map((cs: any) => cs.specialty),
      curriculums: caseItem.caseCurriculums.map((cc: any) => cc.curriculum),
      course: caseItem.course,
      simulation: caseItem.simulation,
      caseTabs: caseItem.caseTabs
    }))
  }

  async assignSpecialties(courseCaseId: string, specialtyIds: string[]) {
    // Verify course case exists
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id: courseCaseId }
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    // Verify all specialties exist
    const specialties = await this.prisma.specialty.findMany({
      where: { id: { in: specialtyIds } }
    })

    if (specialties.length !== specialtyIds.length) {
      throw new Error('One or more specialties not found')
    }

    // Remove existing assignments
    await this.prisma.caseSpecialty.deleteMany({
      where: { courseCaseId }
    })

    // Create new assignments
    const assignments = await this.prisma.caseSpecialty.createMany({
      data: specialtyIds.map((specialtyId: string) => ({
        courseCaseId,
        specialtyId
      }))
    })

    return assignments
  }

  async assignCurriculums(courseCaseId: string, curriculumIds: string[]) {
    // Verify course case exists
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id: courseCaseId }
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    // Verify all curriculum items exist
    const curriculums = await this.prisma.curriculum.findMany({
      where: { id: { in: curriculumIds } }
    })

    if (curriculums.length !== curriculumIds.length) {
      throw new Error('One or more curriculum items not found')
    }

    // Remove existing assignments
    await this.prisma.caseCurriculum.deleteMany({
      where: { courseCaseId }
    })

    // Create new assignments
    const assignments = await this.prisma.caseCurriculum.createMany({
      data: curriculumIds.map((curriculumId: string) => ({
        courseCaseId,
        curriculumId
      }))
    })

    return assignments
  }

  async bulkAssignFilters(assignments: BulkAssignmentInput[]) {
    const results = []

    for (const assignment of assignments) {
      const operations = []

      if (assignment.specialtyIds && assignment.specialtyIds.length > 0) {
        operations.push(
          this.assignSpecialties(assignment.courseCaseId, assignment.specialtyIds)
        )
      }

      if (assignment.curriculumIds && assignment.curriculumIds.length > 0) {
        operations.push(
          this.assignCurriculums(assignment.courseCaseId, assignment.curriculumIds)
        )
      }

      if (operations.length > 0) {
        await Promise.all(operations)
        results.push({
          courseCaseId: assignment.courseCaseId,
          specialtiesAssigned: assignment.specialtyIds?.length || 0,
          curriculumsAssigned: assignment.curriculumIds?.length || 0
        })
      }
    }

    return results
  }

  // ===== RETRIEVAL OPERATIONS =====

  async getCaseSpecialties(courseCaseId: string) {
    // Verify course case exists
    await this.findById(courseCaseId)

    const caseSpecialties = await this.prisma.caseSpecialty.findMany({
      where: { courseCaseId },
      include: {
        specialty: true
      }
    })

    return caseSpecialties.map((cs:any) => cs.specialty)
  }

  async getCaseCurriculums(courseCaseId: string) {
    // Verify course case exists
    await this.findById(courseCaseId)

    const caseCurriculums = await this.prisma.caseCurriculum.findMany({
      where: { courseCaseId },
      include: {
        curriculum: true
      }
    })

    return caseCurriculums.map((cc: any) => cc.curriculum)
  }

  // ===== REMOVAL OPERATIONS =====

  async removeSpecialty(courseCaseId: string, specialtyId: string) {
    // Verify course case exists
    await this.findById(courseCaseId)

    const deleted = await this.prisma.caseSpecialty.deleteMany({
      where: { courseCaseId, specialtyId }
    })

    if (deleted.count === 0) {
      throw new Error('Specialty assignment not found')
    }

    return { message: 'Specialty removed successfully' }
  }

  async removeCurriculum(courseCaseId: string, curriculumId: string) {
    // Verify course case exists
    await this.findById(courseCaseId)

    const deleted = await this.prisma.caseCurriculum.deleteMany({
      where: { courseCaseId, curriculumId }
    })

    if (deleted.count === 0) {
      throw new Error('Curriculum assignment not found')
    }

    return { message: 'Curriculum removed successfully' }
  }

  // ===== FILTERING STATISTICS =====

  async getFilteringStats(courseId: string) {
    const totalCases = await this.prisma.courseCase.count({
      where: { courseId }
    })

    // Get specialty distribution
    const specialtyDistribution = await this.prisma.caseSpecialty.groupBy({
      by: ['specialtyId'],
      where: {
        courseCase: { courseId }
      },
      _count: {
        specialtyId: true
      }
    })

    // Get curriculum distribution
    const curriculumDistribution = await this.prisma.caseCurriculum.groupBy({
      by: ['curriculumId'],
      where: {
        courseCase: { courseId }
      },
      _count: {
        curriculumId: true
      }
    })

    // Enrich with specialty and curriculum details
    const enrichedSpecialtyDistribution = await Promise.all(
      specialtyDistribution.map(async (item: { specialtyId: string; _count: { specialtyId: number } }) => {
        const specialty = await this.prisma.specialty.findUnique({
          where: { id: item.specialtyId }
        })
        return {
          specialtyId: item.specialtyId,
          count: item._count.specialtyId,
          specialty: {
            id: specialty?.id || '',
            name: specialty?.name || ''
          }
        }
      })
    )

    const enrichedCurriculumDistribution = await Promise.all(
      curriculumDistribution.map(async (item: { curriculumId: string; _count: { curriculumId: number } }) => {
        const curriculum = await this.prisma.curriculum.findUnique({
          where: { id: item.curriculumId }
        })
        return {
          curriculumId: item.curriculumId,
          count: item._count.curriculumId,
          curriculum: {
            id: curriculum?.id || '',
            name: curriculum?.name || ''
          }
        }
      })
    )

    return {
      courseId,
      totalCases,
      specialtyDistribution: enrichedSpecialtyDistribution,
      curriculumDistribution: enrichedCurriculumDistribution
    }
  }

  // ===== COMPLETE COURSE CASE OPERATIONS =====

  async createCompleteCourseCase(data: CreateCompleteCourseCaseInput) {
    return await this.prisma.$transaction(async (tx) => {
      // Step 1: Verify course exists and get course data
      const course = await tx.course.findUnique({
        where: { id: data.courseCase.courseId }
      })
  
      if (!course) {
        throw new Error('Course not found')
      }
  
      if (course.style !== 'RANDOM') {
        throw new Error('Cases can only be added to RANDOM style courses')
      }
  
      if (!data.courseCase.displayOrder) {
        const maxOrder = await tx.courseCase.aggregate({
          where: { courseId: data.courseCase.courseId },
          _max: { displayOrder: true }
        })
        data.courseCase.displayOrder = (maxOrder._max.displayOrder || 0) + 1
      } else {
        const existingCase = await tx.courseCase.findFirst({
          where: {
            courseId: data.courseCase.courseId,
            displayOrder: data.courseCase.displayOrder
          }
        })
  
        if (existingCase) {
          throw new Error(`Display order ${data.courseCase.displayOrder} is already taken for this course`)
        }
      }
  
      // Step 2: Create the course case
      const courseCase = await tx.courseCase.create({
        data: {
          courseId: data.courseCase.courseId,
          title: data.courseCase.title,
          diagnosis: data.courseCase.diagnosis,
          patientName: data.courseCase.patientName,
          patientAge: data.courseCase.patientAge,
          patientGender: data.courseCase.patientGender,
          description: data.courseCase.description,
          isFree: data.courseCase.isFree ?? false,
          displayOrder: data.courseCase.displayOrder
        }
      })
  
      // Step 3: Create only 3 tabs
      const tabTypes: CaseTabType[] = ['DOCTORS_NOTE', 'PATIENT_SCRIPT', 'MEDICAL_NOTES']
      const createdTabs: any = {}
      
      for (const tabType of tabTypes) {
        const content = data.tabs?.[tabType] || []
        
        const tab = await tx.caseTab.create({
          data: {
            courseCaseId: courseCase.id,
            tabType,
            content
          }
        })
        
        createdTabs[tabType] = {
          id: tab.id,
          content: tab.content,
          hasContent: tab.content.length > 0
        }
      }
  
      // Step 4: Create marking criteria if provided
      let markingCriteriaResponse: GroupedCriteria[] = []
      if (data.markingCriteria && data.markingCriteria.length > 0) {
        const createdCriteria = await Promise.all(
          data.markingCriteria.map(criterion =>
            tx.markingCriterion.create({
              data: {
                courseCaseId: courseCase.id,
                markingDomainId: criterion.markingDomainId,
                text: criterion.text,
                points: criterion.points,
                displayOrder: criterion.displayOrder
              },
              include: {
                markingDomain: true
              }
            })
          )
        ) as MarkingCriterionWithDomain[]
        
        // Group by domain for response with proper typing
        markingCriteriaResponse = createdCriteria.reduce((acc: GroupedCriteria[], criterion: MarkingCriterionWithDomain) => {
          const domainId = criterion.markingDomain.id
          const domainName = criterion.markingDomain.name
          
          let group = acc.find(g => g.domainId === domainId)
          if (!group) {
            group = { domainId, domainName, criteria: [] }
            acc.push(group)
          }
          
          group.criteria.push({
            id: criterion.id,
            text: criterion.text,
            points: criterion.points,
            displayOrder: criterion.displayOrder
          })
          
          return acc
        }, [])
      }
  
      // Step 5: Create new entities
      const createdEntities = {
        specialties: [] as any[],
        curriculums: [] as any[]
      }
  
      if (data.new?.specialties && data.new.specialties.length > 0) {
        for (const specialty of data.new.specialties) {
          const existing = await tx.specialty.findFirst({
            where: { 
              name: {
                equals: specialty.name,
                mode: 'insensitive'
              }
            }
          })
          
          if (existing) {
            createdEntities.specialties.push(existing)
          } else {
            const created = await tx.specialty.create({
              data: { name: specialty.name }
            })
            createdEntities.specialties.push(created)
          }
        }
      }
  
      if (data.new?.curriculums && data.new.curriculums.length > 0) {
        for (const curriculum of data.new.curriculums) {
          const existing = await tx.curriculum.findFirst({
            where: { 
              name: {
                equals: curriculum.name,
                mode: 'insensitive'
              }
            }
          })
          
          if (existing) {
            createdEntities.curriculums.push(existing)
          } else {
            const created = await tx.curriculum.create({
              data: { name: curriculum.name }
            })
            createdEntities.curriculums.push(created)
          }
        }
      }
  
      // Step 6: Collect all IDs
      const allSpecialtyIds = [
        ...(data.existing?.specialtyIds || []),
        ...createdEntities.specialties.map(s => s.id)
      ]
  
      const allCurriculumIds = [
        ...(data.existing?.curriculumIds || []),
        ...createdEntities.curriculums.map(c => c.id)
      ]
  
      // Step 7: Verify existing entities
      if (data.existing?.specialtyIds && data.existing.specialtyIds.length > 0) {
        const count = await tx.specialty.count({
          where: { id: { in: data.existing.specialtyIds } }
        })
        if (count !== data.existing.specialtyIds.length) {
          throw new Error('One or more specialties not found')
        }
      }
  
      if (data.existing?.curriculumIds && data.existing.curriculumIds.length > 0) {
        const count = await tx.curriculum.count({
          where: { id: { in: data.existing.curriculumIds } }
        })
        if (count !== data.existing.curriculumIds.length) {
          throw new Error('One or more curriculums not found')
        }
      }
  
      // Step 8: Create junction table entries
      if (allSpecialtyIds.length > 0) {
        await tx.caseSpecialty.createMany({
          data: allSpecialtyIds.map(specialtyId => ({
            courseCaseId: courseCase.id,
            specialtyId
          }))
        })
      }
  
      if (allCurriculumIds.length > 0) {
        await tx.caseCurriculum.createMany({
          data: allCurriculumIds.map(curriculumId => ({
            courseCaseId: courseCase.id,
            curriculumId
          }))
        })
      }
  
      // Step 9: Create simulation if provided
      let simulation = null
      if (data.simulation) {
        if (data.simulation.warningTimeMinutes && 
            data.simulation.warningTimeMinutes >= data.simulation.timeLimitMinutes) {
          throw new Error('Warning time must be less than time limit')
        }
  
        simulation = await tx.simulation.create({
          data: {
            courseCaseId: courseCase.id,
            casePrompt: data.simulation.casePrompt,
            openingLine: data.simulation.openingLine,
            timeLimitMinutes: data.simulation.timeLimitMinutes,
            voiceModel: data.simulation.voiceModel,
            warningTimeMinutes: data.simulation.warningTimeMinutes,
            creditCost: data.simulation.creditCost
          }
        })
      }
  
      // Step 10: Fetch all assigned entities for response
      const assignedSpecialties = await tx.specialty.findMany({
        where: { id: { in: allSpecialtyIds } }
      })
  
      const assignedCurriculums = await tx.curriculum.findMany({
        where: { id: { in: allCurriculumIds } }
      })
  
      const newSpecialtiesCount = createdEntities.specialties.filter(s => 
        !data.existing?.specialtyIds?.includes(s.id) &&
        data.new?.specialties?.some(ns => ns.name === s.name)
      ).length
  
      const newCurriculumsCount = createdEntities.curriculums.filter(c => 
        !data.existing?.curriculumIds?.includes(c.id) &&
        data.new?.curriculums?.some(nc => nc.name === c.name)
      ).length
  
      return {
        courseCase,
        tabs: createdTabs,
        markingCriteria: markingCriteriaResponse,
        created: {
          specialties: createdEntities.specialties.filter(s => 
            data.new?.specialties?.some(ns => ns.name === s.name)
          ),
          curriculums: createdEntities.curriculums.filter(c => 
            data.new?.curriculums?.some(nc => nc.name === c.name)
          )
        },
        assigned: {
          specialties: assignedSpecialties,
          curriculums: assignedCurriculums
        },
        simulation,
        summary: {
          totalSpecialties: assignedSpecialties.length,
          totalCurriculums: assignedCurriculums.length,
          newEntitiesCreated: newSpecialtiesCount + newCurriculumsCount,
          simulationCreated: !!simulation,
          tabsCreated: 3,
          tabsUpdated: 0,
          markingCriteriaCreated: data.markingCriteria?.length || 0
        }
      }
    })
  }
  
  async updateCompleteCourseCase(data: UpdateCompleteCourseCaseInput) {
    return await this.prisma.$transaction(async (tx) => {
      // Step 1: Verify course case exists
      const existingCourseCase = await tx.courseCase.findUnique({
        where: { id: data.courseCaseId },
        include: {
          course: true,
          simulation: true,
          caseTabs: true
        }
      })
  
      if (!existingCourseCase) {
        throw new Error('Course case not found')
      }
  
      // Step 2: Update course case if data provided
      let updatedCourseCase = existingCourseCase
      if (data.courseCase) {
        if (data.courseCase.displayOrder && 
            data.courseCase.displayOrder !== existingCourseCase.displayOrder) {
          const conflictingCase = await tx.courseCase.findFirst({
            where: {
              courseId: existingCourseCase.courseId,
              displayOrder: data.courseCase.displayOrder,
              id: { not: data.courseCaseId }
            }
          })
  
          if (conflictingCase) {
            throw new Error(`Display order ${data.courseCase.displayOrder} is already taken`)
          }
        }
  
        updatedCourseCase = await tx.courseCase.update({
          where: { id: data.courseCaseId },
          data: data.courseCase,
          include: {
            course: true,
            simulation: true,
            caseTabs: true
          }
        })
      }
  
      // Step 3: Update tabs if provided
      const tabsResponse: any = {}
      let tabsUpdated = 0
      
      if (data.tabs) {
        const tabTypes: CaseTabType[] = ['DOCTORS_NOTE', 'PATIENT_SCRIPT', 'MEDICAL_NOTES']
        
        for (const tabType of tabTypes) {
          const existingTab = existingCourseCase.caseTabs.find(t => t.tabType === tabType)
          
          if (data.tabs[tabType] !== undefined) {
            if (existingTab) {
              const updatedTab = await tx.caseTab.update({
                where: { id: existingTab.id },
                data: { content: data.tabs[tabType] }
              })
              tabsResponse[tabType] = {
                id: updatedTab.id,
                content: updatedTab.content,
                hasContent: updatedTab.content.length > 0
              }
              tabsUpdated++
            } else {
              const newTab = await tx.caseTab.create({
                data: {
                  courseCaseId: data.courseCaseId,
                  tabType,
                  content: data.tabs[tabType]!
                }
              })
              tabsResponse[tabType] = {
                id: newTab.id,
                content: newTab.content,
                hasContent: newTab.content.length > 0
              }
            }
          } else if (existingTab) {
            tabsResponse[tabType] = {
              id: existingTab.id,
              content: existingTab.content,
              hasContent: existingTab.content.length > 0
            }
          }
        }
      } else {
        for (const tab of existingCourseCase.caseTabs) {
          tabsResponse[tab.tabType] = {
            id: tab.id,
            content: tab.content,
            hasContent: tab.content.length > 0
          }
        }
      }
  
      // Step 4: Handle marking criteria updates
      let markingCriteriaResponse: GroupedCriteria[] = []
      if (data.markingCriteria) {
        const existingCriteria = await tx.markingCriterion.findMany({
          where: { courseCaseId: data.courseCaseId }
        })
        const existingIds = existingCriteria.map(c => c.id)
        const incomingIds = data.markingCriteria.map((c: any) => c.id).filter(Boolean) as string[]
        
        // Delete removed criteria
        const idsToDelete = existingIds.filter(id => !incomingIds.includes(id))
        if (idsToDelete.length > 0) {
          await tx.markingCriterion.deleteMany({
            where: { id: { in: idsToDelete } }
          })
        }
        
        // Update/create criteria
        const updatedCriteria: MarkingCriterionWithDomain[] = []
        for (const item of data.markingCriteria) {
          if (item.id && existingIds.includes(item.id)) {
            const updated = await tx.markingCriterion.update({
              where: { id: item.id },
              data: {
                markingDomainId: item.markingDomainId,
                text: item.text,
                points: item.points,
                displayOrder: item.displayOrder
              },
              include: {
                markingDomain: true
              }
            }) as MarkingCriterionWithDomain
            updatedCriteria.push(updated)
          } else {
            const created = await tx.markingCriterion.create({
              data: {
                courseCaseId: data.courseCaseId,
                markingDomainId: item.markingDomainId,
                text: item.text,
                points: item.points,
                displayOrder: item.displayOrder
              },
              include: {
                markingDomain: true
              }
            }) as MarkingCriterionWithDomain
            updatedCriteria.push(created)
          }
        }
        
        // Group by domain for response with proper typing
        markingCriteriaResponse = updatedCriteria.reduce((acc: GroupedCriteria[], criterion: MarkingCriterionWithDomain) => {
          const domainId = criterion.markingDomain.id
          const domainName = criterion.markingDomain.name
          
          let group = acc.find(g => g.domainId === domainId)
          if (!group) {
            group = { domainId, domainName, criteria: [] }
            acc.push(group)
          }
          
          group.criteria.push({
            id: criterion.id,
            text: criterion.text,
            points: criterion.points,
            displayOrder: criterion.displayOrder
          })
          
          return acc
        }, [])
      } else {
        // Fetch existing marking criteria
        const existingCriteria = await tx.markingCriterion.findMany({
          where: { courseCaseId: data.courseCaseId },
          include: { markingDomain: true }
        }) as MarkingCriterionWithDomain[]
        
        markingCriteriaResponse = existingCriteria.reduce((acc: GroupedCriteria[], criterion: MarkingCriterionWithDomain) => {
          const domainId = criterion.markingDomain.id
          const domainName = criterion.markingDomain.name
          
          let group = acc.find(g => g.domainId === domainId)
          if (!group) {
            group = { domainId, domainName, criteria: [] }
            acc.push(group)
          }
          
          group.criteria.push({
            id: criterion.id,
            text: criterion.text,
            points: criterion.points,
            displayOrder: criterion.displayOrder
          })
          
          return acc
        }, [])
      }
  
      // Step 5: Handle specialties and curriculums
      const createdEntities = {
        specialties: [] as any[],
        curriculums: [] as any[]
      }
  
      if (data.new?.specialties && data.new.specialties.length > 0) {
        for (const specialty of data.new.specialties) {
          const existing = await tx.specialty.findFirst({
            where: { 
              name: {
                equals: specialty.name,
                mode: 'insensitive'
              }
            }
          })
          
          if (existing) {
            createdEntities.specialties.push(existing)
          } else {
            const created = await tx.specialty.create({
              data: { name: specialty.name }
            })
            createdEntities.specialties.push(created)
          }
        }
      }
  
      if (data.new?.curriculums && data.new.curriculums.length > 0) {
        for (const curriculum of data.new.curriculums) {
          const existing = await tx.curriculum.findFirst({
            where: { 
              name: {
                equals: curriculum.name,
                mode: 'insensitive'
              }
            }
          })
          
          if (existing) {
            createdEntities.curriculums.push(existing)
          } else {
            const created = await tx.curriculum.create({
              data: { name: curriculum.name }
            })
            createdEntities.curriculums.push(created)
          }
        }
      }
  
      if (data.existing?.specialtyIds !== undefined || createdEntities.specialties.length > 0) {
        await tx.caseSpecialty.deleteMany({
          where: { courseCaseId: data.courseCaseId }
        })
  
        const allSpecialtyIds = [
          ...(data.existing?.specialtyIds || []),
          ...createdEntities.specialties.map(s => s.id)
        ]
  
        if (allSpecialtyIds.length > 0) {
          await tx.caseSpecialty.createMany({
            data: allSpecialtyIds.map(specialtyId => ({
              courseCaseId: data.courseCaseId,
              specialtyId
            }))
          })
        }
      }
  
      if (data.existing?.curriculumIds !== undefined || createdEntities.curriculums.length > 0) {
        await tx.caseCurriculum.deleteMany({
          where: { courseCaseId: data.courseCaseId }
        })
  
        const allCurriculumIds = [
          ...(data.existing?.curriculumIds || []),
          ...createdEntities.curriculums.map(c => c.id)
        ]
  
        if (allCurriculumIds.length > 0) {
          await tx.caseCurriculum.createMany({
            data: allCurriculumIds.map(curriculumId => ({
              courseCaseId: data.courseCaseId,
              curriculumId
            }))
          })
        }
      }
  
      // Step 6: Update or create simulation
      let simulation = existingCourseCase.simulation
      if (data.simulation) {
        if (data.simulation.warningTimeMinutes && 
            data.simulation.timeLimitMinutes &&
            data.simulation.warningTimeMinutes >= data.simulation.timeLimitMinutes) {
          throw new Error('Warning time must be less than time limit')
        }
  
        if (simulation) {
          simulation = await tx.simulation.update({
            where: { id: simulation.id },
            data: data.simulation
          })
        } else {
          simulation = await tx.simulation.create({
            data: {
              courseCaseId: data.courseCaseId,
              casePrompt: data.simulation.casePrompt!,
              openingLine: data.simulation.openingLine!,
              timeLimitMinutes: data.simulation.timeLimitMinutes!,
              voiceModel: data.simulation.voiceModel!,
              warningTimeMinutes: data.simulation.warningTimeMinutes,
              creditCost: data.simulation.creditCost || 1
            }
          })
        }
      }
  
      // Step 7: Fetch all current relations for response
      const currentSpecialties = await tx.caseSpecialty.findMany({
        where: { courseCaseId: data.courseCaseId },
        include: { specialty: true }
      })
  
      const currentCurriculums = await tx.caseCurriculum.findMany({
        where: { courseCaseId: data.courseCaseId },
        include: { curriculum: true }
      })
  
      const newSpecialtiesCount = createdEntities.specialties.filter(s => 
        data.new?.specialties?.some(ns => ns.name === s.name)
      ).length
  
      const newCurriculumsCount = createdEntities.curriculums.filter(c => 
        data.new?.curriculums?.some(nc => nc.name === c.name)
      ).length
  
      return {
        courseCase: updatedCourseCase,
        tabs: tabsResponse,
        markingCriteria: markingCriteriaResponse,
        created: {
          specialties: createdEntities.specialties.filter(s => 
            data.new?.specialties?.some(ns => ns.name === s.name)
          ),
          curriculums: createdEntities.curriculums.filter(c => 
            data.new?.curriculums?.some(nc => nc.name === c.name)
          )
        },
        assigned: {
          specialties: currentSpecialties.map(cs => cs.specialty),
          curriculums: currentCurriculums.map(cc => cc.curriculum)
        },
        simulation,
        summary: {
          totalSpecialties: currentSpecialties.length,
          totalCurriculums: currentCurriculums.length,
          newEntitiesCreated: newSpecialtiesCount + newCurriculumsCount,
          simulationCreated: !existingCourseCase.simulation && !!simulation,
          tabsCreated: 0,
          tabsUpdated,
          markingCriteriaCreated: data.markingCriteria?.filter((c: any) => !c.id).length || 0
        }
      }
    })
  }
}


================================================
File: src/entities/curriculum/curriculum.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { CurriculumService } from './curriculum.service'
import { 
  createCurriculumSchema, 
  updateCurriculumSchema, 
  curriculumParamsSchema 
} from './curriculum.schema'

export default async function curriculumRoutes(fastify: FastifyInstance) {
  const curriculumService = new CurriculumService(fastify.prisma)

  // GET /curriculums - Get all curriculums
  fastify.get('/curriculums', async (request, reply) => {
    try {
      const curriculums = await curriculumService.findAll()
      reply.send(curriculums)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch curriculums' })
    }
  })

  // GET /curriculums/:id - Get curriculum by ID
  fastify.get('/curriculums/:id', async (request, reply) => {
    try {
      const { id } = curriculumParamsSchema.parse(request.params)
      const curriculum = await curriculumService.findById(id)
      reply.send(curriculum)
    } catch (error) {
      if (error instanceof Error && error.message === 'Curriculum not found') {
        reply.status(404).send({ error: 'Curriculum not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /curriculums - Create new curriculum
  fastify.post('/curriculums', async (request, reply) => {
    try {
      const data = createCurriculumSchema.parse(request.body)
      const curriculum = await curriculumService.create(data)
      reply.status(201).send(curriculum)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid data or curriculum already exists' })
    }
  })

  // PUT /curriculums/:id - Update curriculum
  fastify.put('/curriculums/:id', async (request, reply) => {
    try {
      const { id } = curriculumParamsSchema.parse(request.params)
      const data = updateCurriculumSchema.parse(request.body)
      const curriculum = await curriculumService.update(id, data)
      reply.send(curriculum)
    } catch (error) {
      if (error instanceof Error && error.message === 'Curriculum not found') {
        reply.status(404).send({ error: 'Curriculum not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // DELETE /curriculums/:id - Delete curriculum
  fastify.delete('/curriculums/:id', async (request, reply) => {
    try {
      const { id } = curriculumParamsSchema.parse(request.params)
      await curriculumService.delete(id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'Curriculum not found') {
        reply.status(404).send({ error: 'Curriculum not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })
}


================================================
File: src/entities/curriculum/curriculum.schema.ts
================================================
import { z } from 'zod'

// Create Curriculum Schema
export const createCurriculumSchema = z.object({
  name: z.string()
    .min(1, 'Name is required')
    .max(100, 'Name must be less than 100 characters')
    .trim()
})

// Update Curriculum Schema
export const updateCurriculumSchema = z.object({
  name: z.string()
    .min(1, 'Name is required')
    .max(100, 'Name must be less than 100 characters')
    .trim()
    .optional()
})

// URL Params Schema
export const curriculumParamsSchema = z.object({
  id: z.string().uuid('Invalid curriculum ID')
})

// Response Schema (what we send back)
export const curriculumResponseSchema = z.object({
  id: z.string(),
  name: z.string(),
  createdAt: z.date()
})

// Type exports for TypeScript
export type CreateCurriculumInput = z.infer<typeof createCurriculumSchema>
export type UpdateCurriculumInput = z.infer<typeof updateCurriculumSchema>
export type CurriculumParams = z.infer<typeof curriculumParamsSchema>
export type CurriculumResponse = z.infer<typeof curriculumResponseSchema>


================================================
File: src/entities/curriculum/curriculum.service.ts
================================================
import { PrismaClient } from '@prisma/client'
import { CreateCurriculumInput, UpdateCurriculumInput } from './curriculum.schema'

export class CurriculumService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateCurriculumInput) {
    return await this.prisma.curriculum.create({
      data: {
        name: data.name
      }
    })
  }

  async findAll() {
    return await this.prisma.curriculum.findMany({
      orderBy: {
        name: 'asc'
      }
    })
  }

  async findById(id: string) {
    const curriculum = await this.prisma.curriculum.findUnique({
      where: { id }
    })

    if (!curriculum) {
      throw new Error('Curriculum not found')
    }

    return curriculum
  }

  async update(id: string, data: UpdateCurriculumInput) {
    // Check if exists first
    await this.findById(id)

    return await this.prisma.curriculum.update({
      where: { id },
      data
    })
  }

  async delete(id: string) {
    // Check if exists first
    await this.findById(id)

    return await this.prisma.curriculum.delete({
      where: { id }
    })
  }
}


================================================
File: src/entities/exam/exam.routes.ts
================================================
// exam.routes.ts
import { FastifyInstance } from 'fastify'
import { ExamService } from './exam.service'
import { 
  createExamSchema, 
  updateExamSchema, 
  examParamsSchema,
  examInstructorParamsSchema,
  createCompleteExamSchema,
  updateCompleteExamSchema
} from './exam.schema'
import {
  assignExamSpecialtiesSchema,
  assignExamCurriculumsSchema,
  assignExamMarkingDomainsSchema,
  bulkConfigureExamSchema,
  examRemoveSpecialtyParamsSchema,
  examRemoveCurriculumParamsSchema,
  examRemoveMarkingDomainParamsSchema
} from '../../shared/junction-tables.schema'
import { z } from 'zod'

// Additional schema for examId parameter routes
const examIdParamsSchema = z.object({
  examId: z.string().uuid('Invalid exam ID')
})

// Note: Using type assertions for request.params to resolve TypeScript 'unknown' type issues
// This is safe because Fastify will populate params according to route definitions

export default async function examRoutes(fastify: FastifyInstance) {
  const examService = new ExamService(fastify.prisma)

  // ===== BASIC EXAM CRUD OPERATIONS =====

  // GET /exams - Get all exams
  fastify.get('/exams', async (request, reply) => {
    try {
      const exams = await examService.findAll()
      reply.send(exams)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch exams' })
    }
  })

  // GET /exams/active - Get only active exams
  fastify.get('/exams/active', async (request, reply) => {
    try {
      const exams = await examService.findActive()
      reply.send(exams)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch active exams' })
    }
  })

  // GET /exams/instructor/:instructorId - Get exams by instructor
  fastify.get('/exams/instructor/:instructorId', async (request, reply) => {
    try {
      const { instructorId } = examInstructorParamsSchema.parse(request.params)
      const exams = await examService.findByInstructor(instructorId)
      reply.send(exams)
    } catch (error) {
      if (error instanceof Error && error.message === 'Instructor not found') {
        reply.status(404).send({ error: 'Instructor not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /exams/slug/:slug - Get exam by slug (SEO-friendly URLs)
  fastify.get('/exams/slug/:slug', async (request, reply) => {
    try {
      const { slug } = request.params as { slug: string }
      const exam = await examService.findBySlug(slug)
      reply.send(exam)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /exams/:id - Get exam by ID
  fastify.get('/exams/:id', async (request, reply) => {
    try {
      const { id } = examParamsSchema.parse(request.params)
      const exam = await examService.findById(id)
      reply.send(exam)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /exams - Create new exam
  fastify.post('/exams', async (request, reply) => {
    try {
      const data = createExamSchema.parse(request.body)
      const exam = await examService.create(data)
      reply.status(201).send(exam)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Instructor not found') {
          reply.status(404).send({ error: 'Instructor not found' })
        } else if (error.message === 'Exam with this slug already exists') {
          reply.status(400).send({ error: 'Exam with this slug already exists' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /exams/create-complete - Create exam with all relations in one request
  fastify.post('/exams/create-complete', async (request, reply) => {
    try {
      const data = createCompleteExamSchema.parse(request.body)
      const result = await examService.createCompleteExam(data)
      
      reply.status(201).send({
        message: 'Exam created and configured successfully',
        ...result
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Instructor not found') {
          reply.status(404).send({ error: 'Instructor not found' })
        } else if (error.message === 'Exam with this slug already exists') {
          reply.status(400).send({ error: 'Exam with this slug already exists' })
        } else if (error.message.includes('not found')) {
          reply.status(404).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid data: ' + error.message })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PUT /exams/:id - Update exam
  fastify.put('/exams/:id', async (request, reply) => {
    try {
      const { id } = examParamsSchema.parse(request.params)
      const data = updateExamSchema.parse(request.body)
      const exam = await examService.update(id, data)
      reply.send(exam)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message === 'Exam with this slug already exists') {
          reply.status(400).send({ error: 'Exam with this slug already exists' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PUT /exams/update-complete - Update exam with all relations in one request (examId in body)
  fastify.put('/exams/update-complete', async (request, reply) => {
    try {
      const data = updateCompleteExamSchema.parse(request.body)
      const { examId, ...updateData } = data
      const result = await examService.updateCompleteExam(examId, updateData)
      
      reply.send({
        message: 'Exam updated and configured successfully',
        ...result
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message === 'Exam with this slug already exists') {
          reply.status(400).send({ error: 'Exam with this slug already exists' })
        } else if (error.message.includes('not found')) {
          reply.status(404).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid data: ' + error.message })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PATCH /exams/:id/toggle - Toggle exam active status
  fastify.patch('/exams/:id/toggle', async (request, reply) => {
    try {
      const { id } = examParamsSchema.parse(request.params)
      const exam = await examService.toggleActive(id)
      reply.send({
        message: `Exam ${exam.isActive ? 'activated' : 'deactivated'} successfully`,
        exam
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // DELETE /exams/:id - Delete exam
  fastify.delete('/exams/:id', async (request, reply) => {
    try {
      const { id } = examParamsSchema.parse(request.params)
      await examService.delete(id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // ===== EXAM CONFIGURATION & JUNCTION TABLE OPERATIONS =====

  // GET /exams/:examId/configuration - Get complete exam configuration
  fastify.get('/exams/:examId/configuration', async (request, reply) => {
    try {
      // Alternative approach using dedicated schema validation
      const { examId } = examIdParamsSchema.parse(request.params)
      const configuration = await examService.getExamConfiguration(examId)
      reply.send(configuration)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /exams/:examId/specialties - Get exam specialties
  fastify.get('/exams/:examId/specialties', async (request, reply) => {
    try {
      const { examId } = examIdParamsSchema.parse(request.params)
      const specialties = await examService.getExamSpecialties(examId)
      reply.send(specialties)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /exams/:examId/curriculums - Get exam curriculum items
  fastify.get('/exams/:examId/curriculums', async (request, reply) => {
    try {
      const { examId } = examIdParamsSchema.parse(request.params)
      const curriculums = await examService.getExamCurriculums(examId)
      reply.send(curriculums)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /exams/:examId/marking-domains - Get exam marking domains
  fastify.get('/exams/:examId/marking-domains', async (request, reply) => {
    try {
      const { examId } = examIdParamsSchema.parse(request.params)
      const markingDomains = await examService.getExamMarkingDomains(examId)
      reply.send(markingDomains)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /exams/:examId/usage-stats - Get exam usage statistics
  fastify.get('/exams/:examId/usage-stats', async (request, reply) => {
    try {
      const { examId } = examIdParamsSchema.parse(request.params)
      const stats = await examService.getExamUsageStats(examId)
      reply.send(stats)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // ===== ASSIGNMENT OPERATIONS =====

  // POST /exams/assign-specialties - Assign specialties to exam
  fastify.post('/exams/assign-specialties', async (request, reply) => {
    try {
      const { examId, specialtyIds } = assignExamSpecialtiesSchema.parse(request.body)
      const result = await examService.assignSpecialties(examId, specialtyIds)
      reply.send({
        message: 'Specialties assigned to exam successfully',
        assignments: result,
        examId,
        specialtiesCount: specialtyIds.length
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message === 'One or more specialties not found') {
          reply.status(404).send({ error: 'One or more specialties not found' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /exams/assign-curriculums - Assign curriculum items to exam
  fastify.post('/exams/assign-curriculums', async (request, reply) => {
    try {
      const { examId, curriculumIds } = assignExamCurriculumsSchema.parse(request.body)
      const result = await examService.assignCurriculums(examId, curriculumIds)
      reply.send({
        message: 'Curriculum items assigned to exam successfully',
        assignments: result,
        examId,
        curriculumsCount: curriculumIds.length
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message === 'One or more curriculum items not found') {
          reply.status(404).send({ error: 'One or more curriculum items not found' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /exams/assign-marking-domains - Assign marking domains to exam
  fastify.post('/exams/assign-marking-domains', async (request, reply) => {
    try {
      const { examId, markingDomainIds } = assignExamMarkingDomainsSchema.parse(request.body)
      const result = await examService.assignMarkingDomains(examId, markingDomainIds)
      reply.send({
        message: 'Marking domains assigned to exam successfully',
        assignments: result,
        examId,
        markingDomainsCount: markingDomainIds.length
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message === 'One or more marking domains not found') {
          reply.status(404).send({ error: 'One or more marking domains not found' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /exams/bulk-configure - Configure exam with all assignments at once
  fastify.post('/exams/bulk-configure', async (request, reply) => {
    try {
      const { examId, ...configuration } = bulkConfigureExamSchema.parse(request.body)
      const result = await examService.bulkConfigureExam(examId, configuration)
      reply.send(result)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message.includes('not found')) {
          reply.status(404).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // ===== REMOVAL OPERATIONS =====

  // DELETE /exams/:examId/specialties/:specialtyId - Remove specialty from exam
  fastify.delete('/exams/:examId/specialties/:specialtyId', async (request, reply) => {
    try {
      const { examId, specialtyId } = examRemoveSpecialtyParamsSchema.parse(request.params)
      const result = await examService.removeSpecialty(examId, specialtyId)
      reply.send(result)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message === 'Specialty assignment not found') {
          reply.status(404).send({ error: 'Specialty assignment not found' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // DELETE /exams/:examId/curriculums/:curriculumId - Remove curriculum from exam
  fastify.delete('/exams/:examId/curriculums/:curriculumId', async (request, reply) => {
    try {
      const { examId, curriculumId } = examRemoveCurriculumParamsSchema.parse(request.params)
      const result = await examService.removeCurriculum(examId, curriculumId)
      reply.send(result)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message === 'Curriculum assignment not found') {
          reply.status(404).send({ error: 'Curriculum assignment not found' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // DELETE /exams/:examId/marking-domains/:markingDomainId - Remove marking domain from exam
  fastify.delete('/exams/:examId/marking-domains/:markingDomainId', async (request, reply) => {
    try {
      const { examId, markingDomainId } = examRemoveMarkingDomainParamsSchema.parse(request.params)
      const result = await examService.removeMarkingDomain(examId, markingDomainId)
      reply.send(result)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Exam not found') {
          reply.status(404).send({ error: 'Exam not found' })
        } else if (error.message === 'Marking domain assignment not found') {
          reply.status(404).send({ error: 'Marking domain assignment not found' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // ===== ADDITIONAL UTILITY ROUTES =====

  // GET /exams/:examId/with-configuration - Get exam with all configuration details
  fastify.get('/exams/:examId/with-configuration', async (request, reply) => {
    try {
      const { examId } = examIdParamsSchema.parse(request.params)
      const examWithConfig = await examService.getExamWithConfiguration(examId)
      reply.send(examWithConfig)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /exams/:examId/clear-configuration - Clear all exam configurations
  fastify.post('/exams/:examId/clear-configuration', async (request, reply) => {
    try {
      const { examId } = examIdParamsSchema.parse(request.params)
      const result = await examService.clearExamConfiguration(examId)
      reply.send(result)
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /exams/:examId/is-configured - Check if exam is fully configured
  fastify.get('/exams/:examId/is-configured', async (request, reply) => {
    try {
      const { examId } = examIdParamsSchema.parse(request.params)
      const isConfigured = await examService.isExamFullyConfigured(examId)
      reply.send({ 
        examId, 
        isFullyConfigured: isConfigured 
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Exam not found') {
        reply.status(404).send({ error: 'Exam not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })
}


================================================
File: src/entities/exam/exam.schema.ts
================================================
import { z } from 'zod'

// Helper function to generate slug from title
const generateSlug = (title: string): string => {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
}

// Create Exam Schema
export const createExamSchema = z.object({
  instructorId: z.string().uuid('Invalid instructor ID'),
  title: z.string()
    .min(1, 'Title is required')
    .max(200, 'Title must be less than 200 characters')
    .trim(),
  slug: z.string()
    .min(1, 'Slug is required')
    .max(200, 'Slug must be less than 200 characters')
    .regex(/^[a-z0-9-]+$/, 'Slug must contain only lowercase letters, numbers, and hyphens')
    .optional(),
  description: z.string()
    .max(1000, 'Description must be less than 1000 characters')
    .optional(),
  isActive: z.boolean().default(true).optional()
}).transform((data) => ({
  ...data,
  // Auto-generate slug from title if not provided
  slug: data.slug || generateSlug(data.title)
}))

// Update Exam Schema
export const updateExamSchema = z.object({
  title: z.string()
    .min(1, 'Title is required')
    .max(200, 'Title must be less than 200 characters')
    .trim()
    .optional(),
  slug: z.string()
    .min(1, 'Slug is required')
    .max(200, 'Slug must be less than 200 characters')
    .regex(/^[a-z0-9-]+$/, 'Slug must contain only lowercase letters, numbers, and hyphens')
    .optional(),
  description: z.string()
    .max(1000, 'Description must be less than 1000 characters')
    .optional(),
  isActive: z.boolean().optional()
})

// URL Params Schema
export const examParamsSchema = z.object({
  id: z.string().uuid('Invalid exam ID')
})

// Instructor Params Schema (for instructor-specific queries)
export const examInstructorParamsSchema = z.object({
  instructorId: z.string().uuid('Invalid instructor ID')
})

// Basic Response Schema (without relations)
export const examResponseSchema = z.object({
  id: z.string(),
  instructorId: z.string(),
  title: z.string(),
  slug: z.string(),
  description: z.string().nullable(),
  isActive: z.boolean(),
  createdAt: z.date(),
  updatedAt: z.date(),
  instructor: z.object({
    id: z.string(),
    firstName: z.string(),
    lastName: z.string(),
    bio: z.string().nullable()
  })
})

// Comprehensive Response Schema (with all relations)
export const examWithRelationsResponseSchema = z.object({
  id: z.string(),
  instructorId: z.string(),
  title: z.string(),
  slug: z.string(),
  description: z.string().nullable(),
  isActive: z.boolean(),
  createdAt: z.date(),
  updatedAt: z.date(),
  instructor: z.object({
    id: z.string(),
    firstName: z.string(),
    lastName: z.string(),
    bio: z.string().nullable()
  }),
  specialties: z.array(z.object({
    id: z.string(),
    name: z.string(),
    createdAt: z.date()
  })),
  curriculums: z.array(z.object({
    id: z.string(),
    name: z.string(),
    createdAt: z.date()
  })),
  markingDomains: z.array(z.object({
    id: z.string(),
    name: z.string(),
    createdAt: z.date()
  })),
  _count: z.object({
    courses: z.number(),
    examSpecialties: z.number(),
    examCurriculums: z.number(),
    examMarkingDomains: z.number()
  }).optional()
})

// Schema for creating complete exam with all relations
export const createCompleteExamSchema = z.object({
  // Basic exam info
  exam: z.object({
    instructorId: z.string().uuid('Invalid instructor ID'),
    title: z.string()
      .min(1, 'Title is required')
      .max(200, 'Title must be less than 200 characters')
      .trim(),
    slug: z.string()
      .min(1, 'Slug is required')
      .max(200, 'Slug must be less than 200 characters')
      .regex(/^[a-z0-9-]+$/, 'Slug must contain only lowercase letters, numbers, and hyphens')
      .optional(),
    description: z.string()
      .max(1000, 'Description must be less than 1000 characters')
      .optional(),
    isActive: z.boolean().default(true).optional()
  }),
  
  // Existing entities (by ID)
  existing: z.object({
    specialtyIds: z.array(z.string().uuid('Invalid specialty ID')).default([]),
    curriculumIds: z.array(z.string().uuid('Invalid curriculum ID')).default([]),
    markingDomainIds: z.array(z.string().uuid('Invalid marking domain ID')).default([])
  }).optional(),
  
  // New entities to create
  new: z.object({
    specialties: z.array(z.object({
      name: z.string().min(1).max(100).trim()
    })).default([]),
    curriculums: z.array(z.object({
      name: z.string().min(1).max(100).trim()
    })).default([]),
    markingDomains: z.array(z.object({
      name: z.string().min(1).max(100).trim()
    })).default([])
  }).optional()
})

// Schema for updating complete exam with all relations - NOW INCLUDES examId
export const updateCompleteExamSchema = z.object({
  // Exam ID to update
  examId: z.string().uuid('Invalid exam ID'),
  
  // Basic exam info updates
  exam: z.object({
    title: z.string()
      .min(1, 'Title is required')
      .max(200, 'Title must be less than 200 characters')
      .trim()
      .optional(),
    slug: z.string()
      .min(1, 'Slug is required')
      .max(200, 'Slug must be less than 200 characters')
      .regex(/^[a-z0-9-]+$/, 'Slug must contain only lowercase letters, numbers, and hyphens')
      .optional(),
    description: z.string()
      .max(1000, 'Description must be less than 1000 characters')
      .optional(),
    isActive: z.boolean().optional()
  }).optional(),
  
  // Existing entities (by ID) - these will replace current assignments
  existing: z.object({
    specialtyIds: z.array(z.string().uuid('Invalid specialty ID')).default([]),
    curriculumIds: z.array(z.string().uuid('Invalid curriculum ID')).default([]),
    markingDomainIds: z.array(z.string().uuid('Invalid marking domain ID')).default([])
  }).optional(),
  
  // New entities to create
  new: z.object({
    specialties: z.array(z.object({
      name: z.string().min(1).max(100).trim()
    })).default([]),
    curriculums: z.array(z.object({
      name: z.string().min(1).max(100).trim()
    })).default([]),
    markingDomains: z.array(z.object({
      name: z.string().min(1).max(100).trim()
    })).default([])
  }).optional()
})

// Response schema for complete exam creation
export const completeExamResponseSchema = z.object({
  exam: z.object({
    id: z.string(),
    instructorId: z.string(),
    title: z.string(),
    slug: z.string(),
    description: z.string().nullable(),
    isActive: z.boolean()
  }),
  created: z.object({
    specialties: z.array(z.object({
      id: z.string(),
      name: z.string()
    })),
    curriculums: z.array(z.object({
      id: z.string(),
      name: z.string()
    })),
    markingDomains: z.array(z.object({
      id: z.string(),
      name: z.string()
    }))
  }),
  assigned: z.object({
    specialties: z.array(z.object({
      id: z.string(),
      name: z.string()
    })),
    curriculums: z.array(z.object({
      id: z.string(),
      name: z.string()
    })),
    markingDomains: z.array(z.object({
      id: z.string(),
      name: z.string()
    }))
  }),
  summary: z.object({
    totalSpecialties: z.number(),
    totalCurriculums: z.number(),
    totalMarkingDomains: z.number(),
    newEntitiesCreated: z.number()
  })
})


export const examMarkingDomainsDetailedResponseSchema = z.array(z.object({
  id: z.string(),
  name: z.string(),
  createdAt: z.date(),
  associatedAt: z.date(), // When the domain was linked to the exam
  
  // Statistics for this domain within this exam
  statistics: z.object({
    totalCriteria: z.number(),
    totalPoints: z.number(),
    uniqueCases: z.number(),
    uniqueCourses: z.number(),
    averagePointsPerCriterion: z.union([z.string(), z.number()])
  }),
  
  // All marking criteria (flat list with full relations)
  markingCriteria: z.array(z.object({
    id: z.string(),
    courseCaseId: z.string(),
    markingDomainId: z.string(),
    text: z.string(),
    points: z.number(),
    displayOrder: z.number(),
    createdAt: z.date(),
    courseCase: z.object({
      id: z.string(),
      title: z.string(),
      diagnosis: z.string(),
      patientName: z.string(),
      patientAge: z.number(),
      patientGender: z.enum(['MALE', 'FEMALE', 'OTHER']),
      displayOrder: z.number(),
      course: z.object({
        id: z.string(),
        title: z.string(),
        examId: z.string(),
        exam: z.object({
          id: z.string(),
          title: z.string(),
          slug: z.string()
        })
      })
    })
  })),
  
  // Organized by course and case for UI display
  criteriaByCase: z.array(z.object({
    courseId: z.string(),
    courseTitle: z.string(),
    caseId: z.string(),
    caseTitle: z.string(),
    caseDisplayOrder: z.number(),
    criteria: z.array(z.object({
      id: z.string(),
      text: z.string(),
      points: z.number(),
      displayOrder: z.number(),
      createdAt: z.date()
    })),
    totalPoints: z.number(),
    criteriaCount: z.number()
  })),
  
  // Total count (including from other exams)
  _count: z.object({
    markingCriteria: z.number()
  })
}))

// Type exports
export type CreateExamInput = z.infer<typeof createExamSchema>
export type UpdateExamInput = z.infer<typeof updateExamSchema>
export type ExamParams = z.infer<typeof examParamsSchema>
export type ExamInstructorParams = z.infer<typeof examInstructorParamsSchema>
export type ExamResponse = z.infer<typeof examResponseSchema>
export type ExamWithRelationsResponse = z.infer<typeof examWithRelationsResponseSchema>
export type CreateCompleteExamInput = z.infer<typeof createCompleteExamSchema>
export type UpdateCompleteExamInput = z.infer<typeof updateCompleteExamSchema>
export type CompleteExamResponse = z.infer<typeof completeExamResponseSchema>
export type ExamMarkingDomainsDetailedResponse = z.infer<typeof examMarkingDomainsDetailedResponseSchema>


================================================
File: src/entities/exam/exam.service.ts
================================================
// exam.service.ts
import { PrismaClient } from '@prisma/client'
import { CreateExamInput, UpdateExamInput, CreateCompleteExamInput, UpdateCompleteExamInput, ExamMarkingDomainsDetailedResponse } from './exam.schema'

export class ExamService {
  constructor(private prisma: PrismaClient) {}

  // ===== HELPER METHODS FOR FULL RELATIONS =====

  // Get the full include object for queries with all relations
  private getFullInclude() {
    return {
      instructor: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
          bio: true
        }
      },
      examSpecialties: {
        include: {
          specialty: true
        },
        orderBy: {
          specialty: {
            name: 'asc' as const
          }
        }
      },
      examCurriculums: {
        include: {
          curriculum: true
        },
        orderBy: {
          curriculum: {
            name: 'asc' as const
          }
        }
      },
      examMarkingDomains: {
        include: {
          markingDomain: true
        },
        orderBy: {
          markingDomain: {
            name: 'asc' as const
          }
        }
      },
      _count: {
        select: {
          courses: true,
          examSpecialties: true,
          examCurriculums: true,
          examMarkingDomains: true
        }
      }
    }
  }

  // Transform the exam response to include flattened relations
  private transformExamWithRelations(exam: any) {
    return {
      ...exam,
      specialties: exam.examSpecialties?.map((es: any) => es.specialty) || [],
      curriculums: exam.examCurriculums?.map((ec: any) => ec.curriculum) || [],
      markingDomains: exam.examMarkingDomains?.map((emd: any) => emd.markingDomain) || [],
      examSpecialties: undefined,
      examCurriculums: undefined,
      examMarkingDomains: undefined
    }
  }

  // ===== BASIC EXAM CRUD OPERATIONS =====

  async create(data: CreateExamInput) {
    // First, verify the instructor exists
    const instructor = await this.prisma.instructor.findUnique({
      where: { id: data.instructorId }
    })

    if (!instructor) {
      throw new Error('Instructor not found')
    }

    // Check if slug already exists
    const existingExam = await this.prisma.exam.findUnique({
      where: { slug: data.slug }
    })

    if (existingExam) {
      throw new Error('Exam with this slug already exists')
    }

    const exam = await this.prisma.exam.create({
      data: {
        instructorId: data.instructorId,
        title: data.title,
        slug: data.slug,
        description: data.description,
        isActive: data.isActive ?? true
      },
      include: this.getFullInclude()
    })

    return this.transformExamWithRelations(exam)
  }

  async findAll() {
    const exams = await this.prisma.exam.findMany({
      include: this.getFullInclude(),
      orderBy: {
        createdAt: 'desc'
      }
    })

    return exams.map(exam => this.transformExamWithRelations(exam))
  }

  async findActive() {
    const exams = await this.prisma.exam.findMany({
      where: { isActive: true },
      include: this.getFullInclude(),
      orderBy: {
        title: 'asc'
      }
    })

    return exams.map(exam => this.transformExamWithRelations(exam))
  }

  async findById(id: string) {
    const exam = await this.prisma.exam.findUnique({
      where: { id },
      include: this.getFullInclude()
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    return this.transformExamWithRelations(exam)
  }

  async findBySlug(slug: string) {
    const exam = await this.prisma.exam.findUnique({
      where: { slug },
      include: this.getFullInclude()
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    return this.transformExamWithRelations(exam)
  }

  async findByInstructor(instructorId: string) {
    // Verify instructor exists
    const instructor = await this.prisma.instructor.findUnique({
      where: { id: instructorId }
    })

    if (!instructor) {
      throw new Error('Instructor not found')
    }

    const exams = await this.prisma.exam.findMany({
      where: { instructorId },
      include: this.getFullInclude(),
      orderBy: {
        createdAt: 'desc'
      }
    })

    return exams.map(exam => this.transformExamWithRelations(exam))
  }

  async update(id: string, data: UpdateExamInput) {
    // Check if exam exists
    const existingExam = await this.prisma.exam.findUnique({
      where: { id }
    })

    if (!existingExam) {
      throw new Error('Exam not found')
    }

    // If updating slug, check it's unique
    if (data.slug) {
      const examWithSlug = await this.prisma.exam.findUnique({
        where: { slug: data.slug }
      })

      if (examWithSlug && examWithSlug.id !== id) {
        throw new Error('Exam with this slug already exists')
      }
    }

    const exam = await this.prisma.exam.update({
      where: { id },
      data,
      include: this.getFullInclude()
    })

    return this.transformExamWithRelations(exam)
  }

  async delete(id: string) {
    // Check if exam exists
    await this.findById(id)

    return await this.prisma.exam.delete({
      where: { id }
    })
  }

  async toggleActive(id: string) {
    const currentExam = await this.prisma.exam.findUnique({
      where: { id }
    })

    if (!currentExam) {
      throw new Error('Exam not found')
    }
    
    const exam = await this.prisma.exam.update({
      where: { id },
      data: { isActive: !currentExam.isActive },
      include: this.getFullInclude()
    })

    return this.transformExamWithRelations(exam)
  }

  // ===== JUNCTION TABLE OPERATIONS =====

  // Assign specialties to an exam (User Story #36)
  async assignSpecialties(examId: string, specialtyIds: string[]) {
    // Verify exam exists
    await this.findById(examId)

    // Verify all specialties exist
    const specialties = await this.prisma.specialty.findMany({
      where: { id: { in: specialtyIds } }
    })

    if (specialties.length !== specialtyIds.length) {
      throw new Error('One or more specialties not found')
    }

    // Remove existing assignments to prevent duplicates
    await this.prisma.examSpecialty.deleteMany({
      where: { examId }
    })

    // Create new assignments
    const assignments = await this.prisma.examSpecialty.createMany({
      data: specialtyIds.map(specialtyId => ({
        examId,
        specialtyId
      }))
    })

    return assignments
  }

  // Assign curriculum items to an exam (User Story #37)
  async assignCurriculums(examId: string, curriculumIds: string[]) {
    // Verify exam exists
    await this.findById(examId)

    // Verify all curriculum items exist
    const curriculums = await this.prisma.curriculum.findMany({
      where: { id: { in: curriculumIds } }
    })

    if (curriculums.length !== curriculumIds.length) {
      throw new Error('One or more curriculum items not found')
    }

    // Remove existing assignments to prevent duplicates
    await this.prisma.examCurriculum.deleteMany({
      where: { examId }
    })

    // Create new assignments
    const assignments = await this.prisma.examCurriculum.createMany({
      data: curriculumIds.map(curriculumId => ({
        examId,
        curriculumId
      }))
    })

    return assignments
  }

  // Assign marking domains to an exam (User Story #38)
  async assignMarkingDomains(examId: string, markingDomainIds: string[]) {
    // Verify exam exists
    await this.findById(examId)

    // Verify all marking domains exist
    const markingDomains = await this.prisma.markingDomain.findMany({
      where: { id: { in: markingDomainIds } }
    })

    if (markingDomains.length !== markingDomainIds.length) {
      throw new Error('One or more marking domains not found')
    }

    // Remove existing assignments to prevent duplicates
    await this.prisma.examMarkingDomain.deleteMany({
      where: { examId }
    })

    // Create new assignments
    const assignments = await this.prisma.examMarkingDomain.createMany({
      data: markingDomainIds.map(markingDomainId => ({
        examId,
        markingDomainId
      }))
    })

    return assignments
  }

  // ===== RETRIEVAL OPERATIONS =====

  // Get specialties assigned to an exam
  async getExamSpecialties(examId: string) {
    // Verify exam exists
    const exam = await this.prisma.exam.findUnique({
      where: { id: examId }
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    const examSpecialties = await this.prisma.examSpecialty.findMany({
      where: { examId },
      include: {
        specialty: true
      },
      orderBy: {
        specialty: {
          name: 'asc'
        }
      }
    })

    return examSpecialties.map(es => es.specialty)
  }

  // Get curriculum items assigned to an exam
  async getExamCurriculums(examId: string) {
    // Verify exam exists
    const exam = await this.prisma.exam.findUnique({
      where: { id: examId }
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    const examCurriculums = await this.prisma.examCurriculum.findMany({
      where: { examId },
      include: {
        curriculum: true
      },
      orderBy: {
        curriculum: {
          name: 'asc'
        }
      }
    })

    return examCurriculums.map(ec => ec.curriculum)
  }

  // Get marking domains assigned to an exam
  async getExamMarkingDomains(examId: string): Promise<ExamMarkingDomainsDetailedResponse> {
    // Verify exam exists
    const exam = await this.prisma.exam.findUnique({
      where: { id: examId }
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    const examMarkingDomains = await this.prisma.examMarkingDomain.findMany({
      where: { examId },
      include: {
        markingDomain: {
          include: {
            markingCriteria: {
              include: {
                courseCase: {
                  select: {
                    id: true,
                    title: true,
                    diagnosis: true,
                    patientName: true,
                    patientAge: true,
                    patientGender: true,
                    displayOrder: true,
                    course: {
                      select: {
                        id: true,
                        title: true,
                        examId: true,
                        exam: {
                          select: {
                            id: true,
                            title: true,
                            slug: true
                          }
                        }
                      }
                    }
                  }
                }
              },
              // Only include marking criteria from courses that belong to this exam
              where: {
                courseCase: {
                  course: {
                    examId: examId
                  }
                }
              },
              orderBy: [
                {
                  courseCase: {
                    course: {
                      title: 'asc' as const
                    }
                  }
                },
                {
                  courseCase: {
                    displayOrder: 'asc' as const
                  }
                },
                {
                  displayOrder: 'asc' as const
                }
              ]
            },
            _count: {
              select: {
                markingCriteria: true
              }
            }
          }
        }
      },
      orderBy: {
        markingDomain: {
          name: 'asc' as const
        }
      }
    })

    // Transform the response to include statistics and organized data
    return examMarkingDomains.map(emd => {
      // Group marking criteria by course and case for better organization
      const criteriaByCourseCaseMap = new Map<string, any[]>()
      
      emd.markingDomain.markingCriteria.forEach(criterion => {
        const key = `${criterion.courseCase.course.id}:${criterion.courseCase.id}`
        if (!criteriaByCourseCaseMap.has(key)) {
          criteriaByCourseCaseMap.set(key, [])
        }
        criteriaByCourseCaseMap.get(key)!.push(criterion)
      })

      // Convert map to structured array
      const criteriaByCase = Array.from(criteriaByCourseCaseMap.entries()).map(([key, criteria]) => {
        const [courseId, caseId] = key.split(':')
        const firstCriterion = criteria[0]
        return {
          courseId,
          courseTitle: firstCriterion.courseCase.course.title,
          caseId,
          caseTitle: firstCriterion.courseCase.title,
          caseDisplayOrder: firstCriterion.courseCase.displayOrder,
          criteria: criteria.map(c => ({
            id: c.id,
            text: c.text,
            points: c.points,
            displayOrder: c.displayOrder,
            createdAt: c.createdAt
          })),
          totalPoints: criteria.reduce((sum, c) => sum + c.points, 0),
          criteriaCount: criteria.length
        }
      })

      // Calculate domain statistics
      const totalPoints = emd.markingDomain.markingCriteria.reduce((sum, c) => sum + c.points, 0)
      const totalCriteria = emd.markingDomain.markingCriteria.length
      const uniqueCases = new Set(emd.markingDomain.markingCriteria.map(c => c.courseCaseId)).size
      const uniqueCourses = new Set(emd.markingDomain.markingCriteria.map(c => c.courseCase.course.id)).size

      return {
        id: emd.markingDomain.id,
        name: emd.markingDomain.name,
        createdAt: emd.markingDomain.createdAt,
        associatedAt: emd.createdAt, // When it was linked to this exam
        
        // Statistics for this domain within this exam
        statistics: {
          totalCriteria,
          totalPoints,
          uniqueCases,
          uniqueCourses,
          averagePointsPerCriterion: totalCriteria > 0 ? (totalPoints / totalCriteria).toFixed(2) : '0'
        },
        
        // All marking criteria (flat list)
        markingCriteria: emd.markingDomain.markingCriteria,
        
        // Organized by course and case for UI display
        criteriaByCase,
        
        // Count including criteria from other exams (total in the domain)
        _count: emd.markingDomain._count
      }
    })
  }

  // ===== REMOVAL OPERATIONS =====

  // Remove specialty from exam
  async removeSpecialty(examId: string, specialtyId: string) {
    // Verify exam exists
    const exam = await this.prisma.exam.findUnique({
      where: { id: examId }
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    const deleted = await this.prisma.examSpecialty.deleteMany({
      where: { examId, specialtyId }
    })

    if (deleted.count === 0) {
      throw new Error('Specialty assignment not found')
    }

    return { message: 'Specialty removed successfully' }
  }

  // Remove curriculum from exam
  async removeCurriculum(examId: string, curriculumId: string) {
    // Verify exam exists
    const exam = await this.prisma.exam.findUnique({
      where: { id: examId }
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    const deleted = await this.prisma.examCurriculum.deleteMany({
      where: { examId, curriculumId }
    })

    if (deleted.count === 0) {
      throw new Error('Curriculum assignment not found')
    }

    return { message: 'Curriculum removed successfully' }
  }

  // Remove marking domain from exam
  async removeMarkingDomain(examId: string, markingDomainId: string) {
    // Verify exam exists
    const exam = await this.prisma.exam.findUnique({
      where: { id: examId }
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    const deleted = await this.prisma.examMarkingDomain.deleteMany({
      where: { examId, markingDomainId }
    })

    if (deleted.count === 0) {
      throw new Error('Marking domain assignment not found')
    }

    return { message: 'Marking domain removed successfully' }
  }

  // ===== CONFIGURATION & STATISTICS =====

  // Get exam configuration summary
  async getExamConfiguration(examId: string) {
    const exam = await this.findById(examId)
    
    const specialties = await this.getExamSpecialties(examId)
    const curriculums = await this.getExamCurriculums(examId)
    const markingDomains = await this.getExamMarkingDomains(examId)

    return {
      exam: {
        id: exam.id,
        title: exam.title,
        slug: exam.slug,
        description: exam.description,
        isActive: exam.isActive
      },
      configuration: {
        specialties: specialties,
        curriculums: curriculums,
        markingDomains: markingDomains
      },
      summary: {
        specialtiesCount: specialties.length,
        curriculumsCount: curriculums.length,
        markingDomainsCount: markingDomains.length,
        isFullyConfigured: specialties.length > 0 && curriculums.length > 0 && markingDomains.length > 0
      }
    }
  }

  // Bulk configure exam (assign all at once)
  async bulkConfigureExam(examId: string, configuration: {
    specialtyIds?: string[]
    curriculumIds?: string[]
    markingDomainIds?: string[]
  }) {
    // Verify exam exists
    await this.findById(examId)

    const operations = []

    if (configuration.specialtyIds && configuration.specialtyIds.length > 0) {
      operations.push(
        this.assignSpecialties(examId, configuration.specialtyIds)
      )
    }

    if (configuration.curriculumIds && configuration.curriculumIds.length > 0) {
      operations.push(
        this.assignCurriculums(examId, configuration.curriculumIds)
      )
    }

    if (configuration.markingDomainIds && configuration.markingDomainIds.length > 0) {
      operations.push(
        this.assignMarkingDomains(examId, configuration.markingDomainIds)
      )
    }

    if (operations.length > 0) {
      await Promise.all(operations)
    }

    return {
      message: 'Exam configuration completed successfully',
      examId,
      configured: {
        specialties: configuration.specialtyIds?.length || 0,
        curriculums: configuration.curriculumIds?.length || 0,
        markingDomains: configuration.markingDomainIds?.length || 0
      }
    }
  }

  // Get exam statistics (how many courses/cases use this exam configuration)
  async getExamUsageStats(examId: string) {
    const exam = await this.findById(examId)

    // Get usage counts
    const coursesCount = await this.prisma.course.count({
      where: { examId }
    })

    const casesCount = await this.prisma.courseCase.count({
      where: { course: { examId } }
    })

    const simulationsCount = await this.prisma.simulation.count({
      where: { courseCase: { course: { examId } } }
    })

    // Get configuration counts by querying junction tables directly
    const specialtiesCount = await this.prisma.examSpecialty.count({
      where: { examId }
    })

    const curriculumsCount = await this.prisma.examCurriculum.count({
      where: { examId }
    })

    const markingDomainsCount = await this.prisma.examMarkingDomain.count({
      where: { examId }
    })

    return {
      examId,
      examTitle: exam.title,
      usage: {
        coursesCount,
        casesCount,
        simulationsCount
      },
      configuration: {
        specialtiesCount,
        curriculumsCount,
        markingDomainsCount
      }
    }
  }

  // ===== ADDITIONAL UTILITY METHODS =====

  // Check if exam is fully configured
  async isExamFullyConfigured(examId: string): Promise<boolean> {
    const specialtiesCount = await this.prisma.examSpecialty.count({
      where: { examId }
    })

    const curriculumsCount = await this.prisma.examCurriculum.count({
      where: { examId }
    })

    const markingDomainsCount = await this.prisma.examMarkingDomain.count({
      where: { examId }
    })

    return specialtiesCount > 0 && curriculumsCount > 0 && markingDomainsCount > 0
  }

  // Get exam with all configuration details (including junction data)
  async getExamWithConfiguration(examId: string) {
    const exam = await this.prisma.exam.findUnique({
      where: { id: examId },
      include: this.getFullInclude()
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    return this.transformExamWithRelations(exam)
  }

  // Clear all exam configurations
  async clearExamConfiguration(examId: string) {
    // Verify exam exists
    await this.findById(examId)

    await Promise.all([
      this.prisma.examSpecialty.deleteMany({ where: { examId } }),
      this.prisma.examCurriculum.deleteMany({ where: { examId } }),
      this.prisma.examMarkingDomain.deleteMany({ where: { examId } })
    ])

    return { message: 'Exam configuration cleared successfully' }
  }

  // ===== COMPLETE EXAM CREATION =====

  async createCompleteExam(data: CreateCompleteExamInput) {
    // Use transaction to ensure atomicity
    return await this.prisma.$transaction(async (tx) => {
      // Step 1: Verify instructor exists
      const instructor = await tx.instructor.findUnique({
        where: { id: data.exam.instructorId }
      })

      if (!instructor) {
        throw new Error('Instructor not found')
      }

      // Generate slug if not provided
      const slug = data.exam.slug || this.generateSlug(data.exam.title)

      // Check if slug already exists
      const existingExam = await tx.exam.findUnique({
        where: { slug }
      })

      if (existingExam) {
        throw new Error('Exam with this slug already exists')
      }

      // Step 2: Create the exam
      const exam = await tx.exam.create({
        data: {
          instructorId: data.exam.instructorId,
          title: data.exam.title,
          slug: slug,
          description: data.exam.description,
          isActive: data.exam.isActive ?? true
        }
      })

      // Step 3: Create new entities
      const createdEntities = {
        specialties: [] as any[],
        curriculums: [] as any[],
        markingDomains: [] as any[]
      }

      // Create new specialties
      if (data.new?.specialties && data.new.specialties.length > 0) {
        for (const specialty of data.new.specialties) {
          // Check if already exists (case-insensitive)
          const existing = await tx.specialty.findFirst({
            where: { 
              name: {
                equals: specialty.name,
                mode: 'insensitive'
              }
            }
          })
          
          if (existing) {
            createdEntities.specialties.push(existing)
          } else {
            const created = await tx.specialty.create({
              data: { name: specialty.name }
            })
            createdEntities.specialties.push(created)
          }
        }
      }

      // Create new curriculums
      if (data.new?.curriculums && data.new.curriculums.length > 0) {
        for (const curriculum of data.new.curriculums) {
          const existing = await tx.curriculum.findFirst({
            where: { 
              name: {
                equals: curriculum.name,
                mode: 'insensitive'
              }
            }
          })
          
          if (existing) {
            createdEntities.curriculums.push(existing)
          } else {
            const created = await tx.curriculum.create({
              data: { name: curriculum.name }
            })
            createdEntities.curriculums.push(created)
          }
        }
      }

      // Create new marking domains
      if (data.new?.markingDomains && data.new.markingDomains.length > 0) {
        for (const markingDomain of data.new.markingDomains) {
          const existing = await tx.markingDomain.findFirst({
            where: { 
              name: {
                equals: markingDomain.name,
                mode: 'insensitive'
              }
            }
          })
          
          if (existing) {
            createdEntities.markingDomains.push(existing)
          } else {
            const created = await tx.markingDomain.create({
              data: { name: markingDomain.name }
            })
            createdEntities.markingDomains.push(created)
          }
        }
      }

      // Step 4: Collect all IDs (existing + newly created)
      const allSpecialtyIds = [
        ...(data.existing?.specialtyIds || []),
        ...createdEntities.specialties.map(s => s.id)
      ]

      const allCurriculumIds = [
        ...(data.existing?.curriculumIds || []),
        ...createdEntities.curriculums.map(c => c.id)
      ]

      const allMarkingDomainIds = [
        ...(data.existing?.markingDomainIds || []),
        ...createdEntities.markingDomains.map(md => md.id)
      ]

      // Step 5: Verify existing entities exist
      if (data.existing?.specialtyIds && data.existing.specialtyIds.length > 0) {
        const count = await tx.specialty.count({
          where: { id: { in: data.existing.specialtyIds } }
        })
        if (count !== data.existing.specialtyIds.length) {
          throw new Error('One or more specialties not found')
        }
      }

      if (data.existing?.curriculumIds && data.existing.curriculumIds.length > 0) {
        const count = await tx.curriculum.count({
          where: { id: { in: data.existing.curriculumIds } }
        })
        if (count !== data.existing.curriculumIds.length) {
          throw new Error('One or more curriculums not found')
        }
      }

      if (data.existing?.markingDomainIds && data.existing.markingDomainIds.length > 0) {
        const count = await tx.markingDomain.count({
          where: { id: { in: data.existing.markingDomainIds } }
        })
        if (count !== data.existing.markingDomainIds.length) {
          throw new Error('One or more marking domains not found')
        }
      }

      // Step 6: Create all junction table entries
      if (allSpecialtyIds.length > 0) {
        await tx.examSpecialty.createMany({
          data: allSpecialtyIds.map(specialtyId => ({
            examId: exam.id,
            specialtyId
          }))
        })
      }

      if (allCurriculumIds.length > 0) {
        await tx.examCurriculum.createMany({
          data: allCurriculumIds.map(curriculumId => ({
            examId: exam.id,
            curriculumId
          }))
        })
      }

      if (allMarkingDomainIds.length > 0) {
        await tx.examMarkingDomain.createMany({
          data: allMarkingDomainIds.map(markingDomainId => ({
            examId: exam.id,
            markingDomainId
          }))
        })
      }

      // Step 7: Fetch all assigned entities for response
      const assignedSpecialties = await tx.specialty.findMany({
        where: { id: { in: allSpecialtyIds } }
      })

      const assignedCurriculums = await tx.curriculum.findMany({
        where: { id: { in: allCurriculumIds } }
      })

      const assignedMarkingDomains = await tx.markingDomain.findMany({
        where: { id: { in: allMarkingDomainIds } }
      })

      // Count truly new entities created (not including existing ones that were found)
      const newSpecialtiesCount = createdEntities.specialties.filter(s => 
        !data.existing?.specialtyIds?.includes(s.id) &&
        data.new?.specialties?.some(ns => ns.name === s.name)
      ).length

      const newCurriculumsCount = createdEntities.curriculums.filter(c => 
        !data.existing?.curriculumIds?.includes(c.id) &&
        data.new?.curriculums?.some(nc => nc.name === c.name)
      ).length

      const newMarkingDomainsCount = createdEntities.markingDomains.filter(md => 
        !data.existing?.markingDomainIds?.includes(md.id) &&
        data.new?.markingDomains?.some(nmd => nmd.name === md.name)
      ).length

      // Return comprehensive response
      return {
        exam,
        created: {
          specialties: createdEntities.specialties.filter(s => 
            data.new?.specialties?.some(ns => ns.name === s.name)
          ),
          curriculums: createdEntities.curriculums.filter(c => 
            data.new?.curriculums?.some(nc => nc.name === c.name)
          ),
          markingDomains: createdEntities.markingDomains.filter(md => 
            data.new?.markingDomains?.some(nmd => nmd.name === md.name)
          )
        },
        assigned: {
          specialties: assignedSpecialties,
          curriculums: assignedCurriculums,
          markingDomains: assignedMarkingDomains
        },
        summary: {
          totalSpecialties: assignedSpecialties.length,
          totalCurriculums: assignedCurriculums.length,
          totalMarkingDomains: assignedMarkingDomains.length,
          newEntitiesCreated: newSpecialtiesCount + newCurriculumsCount + newMarkingDomainsCount
        }
      }
    })
  }

  // ===== COMPLETE EXAM UPDATE =====

  async updateCompleteExam(examId: string, data: Omit<UpdateCompleteExamInput, 'examId'>) {
    // Use transaction to ensure atomicity
    return await this.prisma.$transaction(async (tx) => {
      // Step 1: Verify exam exists
      const existingExam = await tx.exam.findUnique({
        where: { id: examId }
      })

      if (!existingExam) {
        throw new Error('Exam not found')
      }

      // Step 2: Update exam basic info if provided
      let updatedExam = existingExam
      if (data.exam && Object.keys(data.exam).length > 0) {
        // If updating slug, check it's unique
        if (data.exam.slug) {
          const examWithSlug = await tx.exam.findUnique({
            where: { slug: data.exam.slug }
          })

          if (examWithSlug && examWithSlug.id !== examId) {
            throw new Error('Exam with this slug already exists')
          }
        }

        updatedExam = await tx.exam.update({
          where: { id: examId },
          data: data.exam
        })
      }

      // Step 3: Create new entities
      const createdEntities = {
        specialties: [] as any[],
        curriculums: [] as any[],
        markingDomains: [] as any[]
      }

      // Create new specialties
      if (data.new?.specialties && data.new.specialties.length > 0) {
        for (const specialty of data.new.specialties) {
          // Check if already exists (case-insensitive)
          const existing = await tx.specialty.findFirst({
            where: { 
              name: {
                equals: specialty.name,
                mode: 'insensitive'
              }
            }
          })
          
          if (existing) {
            createdEntities.specialties.push(existing)
          } else {
            const created = await tx.specialty.create({
              data: { name: specialty.name }
            })
            createdEntities.specialties.push(created)
          }
        }
      }

      // Create new curriculums
      if (data.new?.curriculums && data.new.curriculums.length > 0) {
        for (const curriculum of data.new.curriculums) {
          const existing = await tx.curriculum.findFirst({
            where: { 
              name: {
                equals: curriculum.name,
                mode: 'insensitive'
              }
            }
          })
          
          if (existing) {
            createdEntities.curriculums.push(existing)
          } else {
            const created = await tx.curriculum.create({
              data: { name: curriculum.name }
            })
            createdEntities.curriculums.push(created)
          }
        }
      }

      // Create new marking domains
      if (data.new?.markingDomains && data.new.markingDomains.length > 0) {
        for (const markingDomain of data.new.markingDomains) {
          const existing = await tx.markingDomain.findFirst({
            where: { 
              name: {
                equals: markingDomain.name,
                mode: 'insensitive'
              }
            }
          })
          
          if (existing) {
            createdEntities.markingDomains.push(existing)
          } else {
            const created = await tx.markingDomain.create({
              data: { name: markingDomain.name }
            })
            createdEntities.markingDomains.push(created)
          }
        }
      }

      // Step 4: Collect all IDs (existing + newly created)
      const allSpecialtyIds = [
        ...(data.existing?.specialtyIds || []),
        ...createdEntities.specialties.map(s => s.id)
      ]

      const allCurriculumIds = [
        ...(data.existing?.curriculumIds || []),
        ...createdEntities.curriculums.map(c => c.id)
      ]

      const allMarkingDomainIds = [
        ...(data.existing?.markingDomainIds || []),
        ...createdEntities.markingDomains.map(md => md.id)
      ]

      // Step 5: Verify existing entities exist
      if (data.existing?.specialtyIds && data.existing.specialtyIds.length > 0) {
        const count = await tx.specialty.count({
          where: { id: { in: data.existing.specialtyIds } }
        })
        if (count !== data.existing.specialtyIds.length) {
          throw new Error('One or more specialties not found')
        }
      }

      if (data.existing?.curriculumIds && data.existing.curriculumIds.length > 0) {
        const count = await tx.curriculum.count({
          where: { id: { in: data.existing.curriculumIds } }
        })
        if (count !== data.existing.curriculumIds.length) {
          throw new Error('One or more curriculums not found')
        }
      }

      if (data.existing?.markingDomainIds && data.existing.markingDomainIds.length > 0) {
        const count = await tx.markingDomain.count({
          where: { id: { in: data.existing.markingDomainIds } }
        })
        if (count !== data.existing.markingDomainIds.length) {
          throw new Error('One or more marking domains not found')
        }
      }

      // Step 6: Clear existing assignments and create new ones
      // Only update if new assignments are provided
      if (data.existing || data.new) {
        // Clear and reassign specialties
        if (allSpecialtyIds.length > 0 || (data.existing && 'specialtyIds' in data.existing)) {
          await tx.examSpecialty.deleteMany({ where: { examId } })
          if (allSpecialtyIds.length > 0) {
            await tx.examSpecialty.createMany({
              data: allSpecialtyIds.map(specialtyId => ({
                examId,
                specialtyId
              }))
            })
          }
        }

        // Clear and reassign curriculums
        if (allCurriculumIds.length > 0 || (data.existing && 'curriculumIds' in data.existing)) {
          await tx.examCurriculum.deleteMany({ where: { examId } })
          if (allCurriculumIds.length > 0) {
            await tx.examCurriculum.createMany({
              data: allCurriculumIds.map(curriculumId => ({
                examId,
                curriculumId
              }))
            })
          }
        }

        // Clear and reassign marking domains
        if (allMarkingDomainIds.length > 0 || (data.existing && 'markingDomainIds' in data.existing)) {
          await tx.examMarkingDomain.deleteMany({ where: { examId } })
          if (allMarkingDomainIds.length > 0) {
            await tx.examMarkingDomain.createMany({
              data: allMarkingDomainIds.map(markingDomainId => ({
                examId,
                markingDomainId
              }))
            })
          }
        }
      }

      // Step 7: Fetch all assigned entities for response
      const assignedSpecialties = await tx.specialty.findMany({
        where: { id: { in: allSpecialtyIds } }
      })

      const assignedCurriculums = await tx.curriculum.findMany({
        where: { id: { in: allCurriculumIds } }
      })

      const assignedMarkingDomains = await tx.markingDomain.findMany({
        where: { id: { in: allMarkingDomainIds } }
      })

      // Count truly new entities created (not including existing ones that were found)
      const newSpecialtiesCount = createdEntities.specialties.filter(s => 
        !data.existing?.specialtyIds?.includes(s.id) &&
        data.new?.specialties?.some(ns => ns.name === s.name)
      ).length

      const newCurriculumsCount = createdEntities.curriculums.filter(c => 
        !data.existing?.curriculumIds?.includes(c.id) &&
        data.new?.curriculums?.some(nc => nc.name === c.name)
      ).length

      const newMarkingDomainsCount = createdEntities.markingDomains.filter(md => 
        !data.existing?.markingDomainIds?.includes(md.id) &&
        data.new?.markingDomains?.some(nmd => nmd.name === md.name)
      ).length

      // Return comprehensive response
      return {
        exam: updatedExam,
        created: {
          specialties: createdEntities.specialties.filter(s => 
            data.new?.specialties?.some(ns => ns.name === s.name)
          ),
          curriculums: createdEntities.curriculums.filter(c => 
            data.new?.curriculums?.some(nc => nc.name === c.name)
          ),
          markingDomains: createdEntities.markingDomains.filter(md => 
            data.new?.markingDomains?.some(nmd => nmd.name === md.name)
          )
        },
        assigned: {
          specialties: assignedSpecialties,
          curriculums: assignedCurriculums,
          markingDomains: assignedMarkingDomains
        },
        summary: {
          totalSpecialties: assignedSpecialties.length,
          totalCurriculums: assignedCurriculums.length,
          totalMarkingDomains: assignedMarkingDomains.length,
          newEntitiesCreated: newSpecialtiesCount + newCurriculumsCount + newMarkingDomainsCount,
          examUpdated: data.exam && Object.keys(data.exam).length > 0
        }
      }
    })
  }

  

  // Helper method
  private generateSlug(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '')
  }


  
}


================================================
File: src/entities/instructor/instructor.routes.ts
================================================
import { z } from 'zod'
import { FastifyInstance } from 'fastify'
import { InstructorService } from './instructor.service'
import { 
  createInstructorSchema, 
  updateInstructorSchema 
} from './instructor.schema'

// Updated params schema for userId (integer)
const instructorUserParamsSchema = z.object({
  userId: z.string().transform(val => parseInt(val)).refine(val => !isNaN(val), 'Invalid user ID')
})

export default async function instructorRoutes(fastify: FastifyInstance) {
  const instructorService = new InstructorService(fastify.prisma)

  // GET /instructors - Get all instructors
  fastify.get('/instructors', async (request, reply) => {
    try {
      const instructors = await instructorService.findAll()
      reply.send(instructors)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch instructors' })
    }
  })

  // GET /instructors/:userId - Get instructor by User ID
  fastify.get('/instructors/:userId', async (request, reply) => {
    try {
      const { userId } = instructorUserParamsSchema.parse(request.params)
      const instructor = await instructorService.findByUserId(userId)
      reply.send(instructor)
    } catch (error) {
      if (error instanceof Error && error.message === 'Instructor not found') {
        reply.status(404).send({ error: 'Instructor not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /instructors - Create new instructor (creates User + Instructor)
  fastify.post('/instructors', async (request, reply) => {
    try {
      const data = createInstructorSchema.parse(request.body)
      const instructor = await instructorService.create(data)
      reply.status(201).send(instructor)
    } catch (error) {
      if (error instanceof Error && error.message.includes('Unique constraint failed')) {
        reply.status(400).send({ error: 'Email already exists' })
      } else {
        reply.status(400).send({ error: 'Invalid data' })
      }
    }
  })

  // PUT /instructors/:userId - Update instructor by User ID
  fastify.put('/instructors/:userId', async (request, reply) => {
    try {
      const { userId } = instructorUserParamsSchema.parse(request.params)
      const data = updateInstructorSchema.parse(request.body)
      
      // Get instructor by userId first to get the UUID for update
      const existingInstructor = await instructorService.findByUserId(userId)
      const instructor = await instructorService.update(existingInstructor.id, data)
      reply.send(instructor)
    } catch (error) {
      if (error instanceof Error && error.message === 'Instructor not found') {
        reply.status(404).send({ error: 'Instructor not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // DELETE /instructors/:userId - Delete instructor by User ID
  fastify.delete('/instructors/:userId', async (request, reply) => {
    try {
      const { userId } = instructorUserParamsSchema.parse(request.params)
      
      // Get instructor by userId first to get the UUID for deletion
      const existingInstructor = await instructorService.findByUserId(userId)
      await instructorService.delete(existingInstructor.id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'Instructor not found') {
        reply.status(404).send({ error: 'Instructor not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })
}


================================================
File: src/entities/instructor/instructor.schema.ts
================================================
import { z } from 'zod'

// Create Instructor Schema (includes User data)
export const createInstructorSchema = z.object({
  // User fields
  email: z.string().email('Invalid email format'),
  name: z.string().optional(),
  
  // Instructor fields
  firstName: z.string()
    .min(1, 'First name is required')
    .max(50, 'First name must be less than 50 characters')
    .trim(),
  lastName: z.string()
    .min(1, 'Last name is required')
    .max(50, 'Last name must be less than 50 characters')
    .trim(),
  bio: z.string()
    .max(500, 'Bio must be less than 500 characters')
    .optional()
})

// Update Instructor Schema
export const updateInstructorSchema = z.object({
  firstName: z.string()
    .min(1, 'First name is required')
    .max(50, 'First name must be less than 50 characters')
    .trim()
    .optional(),
  lastName: z.string()
    .min(1, 'Last name is required')
    .max(50, 'Last name must be less than 50 characters')
    .trim()
    .optional(),
  bio: z.string()
    .max(500, 'Bio must be less than 500 characters')
    .optional()
})

// URL Params Schema
export const instructorParamsSchema = z.object({
  id: z.string().uuid('Invalid instructor ID')
})

// Response Schema
export const instructorResponseSchema = z.object({
  id: z.string(),
  userId: z.number(),
  firstName: z.string(),
  lastName: z.string(),
  bio: z.string().nullable(),
  createdAt: z.date(),
  updatedAt: z.date(),
  user: z.object({
    id: z.number(),
    email: z.string(),
    name: z.string().nullable()
  })
})

// Type exports
export type CreateInstructorInput = z.infer<typeof createInstructorSchema>
export type UpdateInstructorInput = z.infer<typeof updateInstructorSchema>
export type InstructorParams = z.infer<typeof instructorParamsSchema>
export type InstructorResponse = z.infer<typeof instructorResponseSchema>


================================================
File: src/entities/instructor/instructor.service.ts
================================================
import { PrismaClient, Prisma } from '@prisma/client'
import { CreateInstructorInput, UpdateInstructorInput } from './instructor.schema'

export class InstructorService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateInstructorInput) {
    // Create User and Instructor in a transaction
    return await this.prisma.$transaction(async (tx: Prisma.TransactionClient) => {
      // First, create the User
      const user = await tx.user.create({
        data: {
          email: data.email,
          name: data.name
        }
      })

      // Then, create the Instructor linked to the User
      const instructor = await tx.instructor.create({
        data: {
          userId: user.id,
          firstName: data.firstName,
          lastName: data.lastName,
          bio: data.bio
        },
        include: {
          user: true
        }
      })

      return instructor
    })
  }

  async findAll() {
    return await this.prisma.instructor.findMany({
      include: {
        user: true
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async findById(id: string) {
    const instructor = await this.prisma.instructor.findUnique({
      where: { id },
      include: {
        user: true
      }
    })

    if (!instructor) {
      throw new Error('Instructor not found')
    }

    return instructor
  }

  async findByUserId(userId: number) {
    const instructor = await this.prisma.instructor.findUnique({
      where: { userId },
      include: {
        user: true
      }
    })

    if (!instructor) {
      throw new Error('Instructor not found')
    }

    return instructor
  }

  async update(id: string, data: UpdateInstructorInput) {
    // Check if exists first
    await this.findById(id)

    return await this.prisma.instructor.update({
      where: { id },
      data,
      include: {
        user: true
      }
    })
  }

  async delete(id: string) {
    // Check if exists first
    const instructor = await this.findById(id)

    // Delete in transaction (Instructor first, then User)
    return await this.prisma.$transaction(async (tx: Prisma.TransactionClient) => {
      await tx.instructor.delete({
        where: { id }
      })

      await tx.user.delete({
        where: { id: instructor.userId }
      })
    })
  }
}


================================================
File: src/entities/marking-criterion/marking-criterion.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { MarkingCriterionService } from './marking-criterion.service'
import {
  createMarkingCriterionSchema,
  updateMarkingCriterionSchema,
  bulkUpdateMarkingCriteriaSchema,
  markingCriterionParamsSchema,
  courseCaseParamsSchema
} from './marking-criterion.schema'

export default async function markingCriterionRoutes(fastify: FastifyInstance) {
  const service = new MarkingCriterionService(fastify.prisma)

  // GET /marking-criteria/case/:courseCaseId - Get all criteria for a case, grouped by domain
  fastify.get('/marking-criteria/case/:courseCaseId', async (request, reply) => {
    try {
      const { courseCaseId } = courseCaseParamsSchema.parse(request.params)
      const groupedCriteria = await service.findAllByCourseCase(courseCaseId)
      reply.send(groupedCriteria)
    } catch (error) {
      if (error instanceof Error && error.message === 'Course case not found') {
        reply.status(404).send({ error: 'Course case not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /marking-criteria/case/:courseCaseId/stats - Get stats for a case's marking criteria
  fastify.get('/marking-criteria/case/:courseCaseId/stats', async (request, reply) => {
    try {
      const { courseCaseId } = courseCaseParamsSchema.parse(request.params)
      const stats = await service.getCaseStats(courseCaseId)
      reply.send(stats)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /marking-criteria/:id - Get a single criterion
  fastify.get('/marking-criteria/:id', async (request, reply) => {
    try {
      const { id } = markingCriterionParamsSchema.parse(request.params)
      const criterion = await service.findById(id)
      reply.send(criterion)
    } catch (error) {
      if (error instanceof Error && error.message === 'Marking criterion not found') {
        reply.status(404).send({ error: 'Marking criterion not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /marking-criteria - Create a single new criterion
  fastify.post('/marking-criteria', async (request, reply) => {
    try {
      const data = createMarkingCriterionSchema.parse(request.body)
      const criterion = await service.create(data)
      reply.status(201).send(criterion)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message.includes('not found')) {
          reply.status(404).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PUT /marking-criteria/case/bulk - Bulk create/update/delete criteria for a case
  fastify.put('/marking-criteria/case/bulk', async (request, reply) => {
    try {
      const data = bulkUpdateMarkingCriteriaSchema.parse(request.body)
      const updatedCriteria = await service.bulkUpdate(data)
      reply.send({
        message: 'Marking criteria updated successfully',
        count: updatedCriteria.length,
        criteria: updatedCriteria
      })
    } catch (error) {
      reply.status(400).send({ error: 'Invalid data' })
    }
  })

  // PUT /marking-criteria/:id - Update a single criterion
  fastify.put('/marking-criteria/:id', async (request, reply) => {
    try {
      const { id } = markingCriterionParamsSchema.parse(request.params)
      const data = updateMarkingCriterionSchema.parse(request.body)
      const criterion = await service.update(id, data)
      reply.send(criterion)
    } catch (error) {
      if (error instanceof Error && error.message === 'Marking criterion not found') {
        reply.status(404).send({ error: 'Marking criterion not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // DELETE /marking-criteria/:id - Delete a single criterion
  fastify.delete('/marking-criteria/:id', async (request, reply) => {
    try {
      const { id } = markingCriterionParamsSchema.parse(request.params)
      await service.delete(id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'Marking criterion not found') {
        reply.status(404).send({ error: 'Marking criterion not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })
}


================================================
File: src/entities/marking-criterion/marking-criterion.schema.ts
================================================
// src/entities/marking-criterion/marking-criterion.schema.ts
import { z } from 'zod'

// Create Marking Criterion Schema
export const createMarkingCriterionSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  markingDomainId: z.string().uuid('Invalid marking domain ID'),
  text: z.string()
    .min(1, 'Text is required')
    .max(500, 'Text must be less than 500 characters')
    .trim(),
  points: z.number()
    .int('Points must be a whole number')
    .min(0, 'Points cannot be negative')
    .max(100, 'Points cannot exceed 100'),
  displayOrder: z.number()
    .int('Display order must be a whole number')
    .min(0, 'Display order cannot be negative')
})

// Update Marking Criterion Schema
export const updateMarkingCriterionSchema = z.object({
  markingDomainId: z.string().uuid('Invalid marking domain ID').optional(),
  text: z.string()
    .min(1, 'Text is required')
    .max(500, 'Text must be less than 500 characters')
    .trim()
    .optional(),
  points: z.number()
    .int('Points must be a whole number')
    .min(0, 'Points cannot be negative')
    .max(100, 'Points cannot exceed 100')
    .optional(),
  displayOrder: z.number()
    .int('Display order must be a whole number')
    .min(0, 'Display order cannot be negative')
    .optional()
})

// Bulk Update Schema
export const bulkUpdateMarkingCriteriaSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  criteria: z.array(z.object({
    id: z.string().uuid().optional(),
    markingDomainId: z.string().uuid('Invalid marking domain ID'),
    text: z.string()
      .min(1, 'Text is required')
      .max(500, 'Text must be less than 500 characters')
      .trim(),
    points: z.number()
      .int('Points must be a whole number')
      .min(0, 'Points cannot be negative')
      .max(100, 'Points cannot exceed 100'),
    displayOrder: z.number()
      .int('Display order must be a whole number')
      .min(0, 'Display order cannot be negative')
  }))
})

// Params Schema
export const markingCriterionParamsSchema = z.object({
  id: z.string().uuid('Invalid marking criterion ID')
})

export const markingCriterionCourseCaseParamsSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID')
})


// Type exports
export type CreateMarkingCriterionInput = z.infer<typeof createMarkingCriterionSchema>
export type UpdateMarkingCriterionInput = z.infer<typeof updateMarkingCriterionSchema>
export type BulkUpdateMarkingCriteriaInput = z.infer<typeof bulkUpdateMarkingCriteriaSchema>
export type MarkingCriterionParams = z.infer<typeof markingCriterionParamsSchema>
export type MarkingCriterionCourseCaseParams = z.infer<typeof markingCriterionCourseCaseParamsSchema>
export const courseCaseParamsSchema = markingCriterionCourseCaseParamsSchema


================================================
File: src/entities/marking-criterion/marking-criterion.service.ts
================================================
import { PrismaClient } from '@prisma/client'
import { CreateMarkingCriterionInput, UpdateMarkingCriterionInput, BulkUpdateMarkingCriteriaInput } from './marking-criterion.schema'

export class MarkingCriterionService {
  constructor(private prisma: PrismaClient) {}

  private getStandardInclude() {
    return {
      markingDomain: {
        select: { id: true, name: true }
      }
    }
  }
  
  async create(data: CreateMarkingCriterionInput) {
    // Verify foreign keys exist
    await this.prisma.courseCase.findUniqueOrThrow({ where: { id: data.courseCaseId } })
    await this.prisma.markingDomain.findUniqueOrThrow({ where: { id: data.markingDomainId } })

    return this.prisma.markingCriterion.create({
      data,
      include: this.getStandardInclude()
    })
  }

  async findById(id: string) {
    const criterion = await this.prisma.markingCriterion.findUnique({
      where: { id },
      include: this.getStandardInclude()
    })
    if (!criterion) throw new Error('Marking criterion not found')
    return criterion
  }

  async findAllByCourseCase(courseCaseId: string) {
    const criteria = await this.prisma.markingCriterion.findMany({
      where: { courseCaseId },
      include: {
        markingDomain: true  // Include full markingDomain object
      },
      orderBy: [{ markingDomain: { name: 'asc' } }, { displayOrder: 'asc' }]
    })
  
    // Group criteria by marking domain but keep ALL fields
    const grouped = criteria.reduce((acc, criterion) => {
      const domainId = criterion.markingDomain.id
      const domainName = criterion.markingDomain.name
      
      let group = acc.find(g => g.domainId === domainId)
      if (!group) {
        group = { domainId, domainName, criteria: [] }
        acc.push(group)
      }
      
      // Push the ENTIRE criterion object (all fields included)
      group.criteria.push({
        id: criterion.id,
        courseCaseId: criterion.courseCaseId,
        markingDomainId: criterion.markingDomainId,
        text: criterion.text,
        points: criterion.points,
        displayOrder: criterion.displayOrder,
        createdAt: criterion.createdAt
      })
      
      return acc
    }, [] as { domainId: string, domainName: string, criteria: any[] }[])
  
    return grouped
  }

  async update(id: string, data: UpdateMarkingCriterionInput) {
    await this.findById(id) // Ensure it exists
    return this.prisma.markingCriterion.update({
      where: { id },
      data,
      include: this.getStandardInclude()
    })
  }
  
  async delete(id: string) {
    await this.findById(id) // Ensure it exists
    return this.prisma.markingCriterion.delete({ where: { id } })
  }

  async bulkUpdate(data: BulkUpdateMarkingCriteriaInput) {
    const { courseCaseId, criteria } = data

    return this.prisma.$transaction(async (tx) => {
      // Get existing criteria for this case
      const existingCriteria = await tx.markingCriterion.findMany({
        where: { courseCaseId }
      })
      const existingIds = existingCriteria.map(c => c.id)
      const incomingIds = criteria.map(c => c.id).filter(Boolean) as string[]

      // IDs to delete: exist in DB but not in incoming array
      const idsToDelete = existingIds.filter(id => !incomingIds.includes(id))
      if (idsToDelete.length > 0) {
        await tx.markingCriterion.deleteMany({
          where: { id: { in: idsToDelete } }
        })
      }

      // Update existing and create new criteria
      const results = []
      for (const item of criteria) {
        if (item.id && existingIds.includes(item.id)) {
          // Update
          const updated = await tx.markingCriterion.update({
            where: { id: item.id },
            data: {
              markingDomainId: item.markingDomainId,
              text: item.text,
              points: item.points,
              displayOrder: item.displayOrder
            },
            include: this.getStandardInclude()
          })
          results.push(updated)
        } else {
          // Create
          const created = await tx.markingCriterion.create({
            data: {
              courseCaseId,
              markingDomainId: item.markingDomainId,
              text: item.text,
              points: item.points,
              displayOrder: item.displayOrder
            },
            include: this.getStandardInclude()
          })
          results.push(created)
        }
      }
      return results
    })
  }

  async getCaseStats(courseCaseId: string) {
    const criteria = await this.prisma.markingCriterion.findMany({
      where: { courseCaseId },
      include: { markingDomain: true }
    })

    const totalPoints = criteria.reduce((sum, c) => sum + c.points, 0)
    const domainStats = criteria.reduce((acc, criterion) => {
      const domainName = criterion.markingDomain.name
      if (!acc[domainName]) {
        acc[domainName] = { count: 0, points: 0 }
      }
      acc[domainName].count++
      acc[domainName].points += criterion.points
      return acc
    }, {} as Record<string, { count: number, points: number }>)

    return {
      totalCriteria: criteria.length,
      totalPoints,
      domainStats
    }
  }
}


================================================
File: src/entities/marking-domain/marking-domain.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { MarkingDomainService } from './marking-domain.service'
import { 
  createMarkingDomainSchema, 
  updateMarkingDomainSchema, 
  markingDomainParamsSchema 
} from './marking-domain.schema'

export default async function markingDomainRoutes(fastify: FastifyInstance) {
  const markingDomainService = new MarkingDomainService(fastify.prisma)

  // GET /marking-domains - Get all marking domains
  fastify.get('/marking-domains', async (request, reply) => {
    try {
      const markingDomains = await markingDomainService.findAll()
      reply.send(markingDomains)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch marking domains' })
    }
  })

  // GET /marking-domains/:id - Get marking domain by ID
  fastify.get('/marking-domains/:id', async (request, reply) => {
    try {
      const { id } = markingDomainParamsSchema.parse(request.params)
      const markingDomain = await markingDomainService.findById(id)
      reply.send(markingDomain)
    } catch (error) {
      if (error instanceof Error && error.message === 'MarkingDomain not found') {
        reply.status(404).send({ error: 'MarkingDomain not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /marking-domains/:id/marking-criteria - Get all marking criteria for a domain
  fastify.get('/marking-domains/:id/marking-criteria', async (request, reply) => {
    try {
      const { id } = markingDomainParamsSchema.parse(request.params)
      const markingCriteria = await markingDomainService.getMarkingCriteria(id)
      reply.send(markingCriteria)
    } catch (error) {
      if (error instanceof Error && error.message === 'MarkingDomain not found') {
        reply.status(404).send({ error: 'MarkingDomain not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /marking-domains/:id/usage-stats - Get usage statistics for a marking domain
  fastify.get('/marking-domains/:id/usage-stats', async (request, reply) => {
    try {
      const { id } = markingDomainParamsSchema.parse(request.params)
      const stats = await markingDomainService.getUsageStats(id)
      reply.send(stats)
    } catch (error) {
      if (error instanceof Error && error.message === 'MarkingDomain not found') {
        reply.status(404).send({ error: 'MarkingDomain not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /marking-domains - Create new marking domain
  fastify.post('/marking-domains', async (request, reply) => {
    try {
      const data = createMarkingDomainSchema.parse(request.body)
      const markingDomain = await markingDomainService.create(data)
      reply.status(201).send(markingDomain)
    } catch (error) {
      if (error instanceof Error && error.message.includes('already exists')) {
        reply.status(409).send({ error: 'Marking domain with this name already exists' })
      } else {
        reply.status(400).send({ error: 'Invalid data' })
      }
    }
  })

  // PUT /marking-domains/:id - Update marking domain
  fastify.put('/marking-domains/:id', async (request, reply) => {
    try {
      const { id } = markingDomainParamsSchema.parse(request.params)
      const data = updateMarkingDomainSchema.parse(request.body)
      const markingDomain = await markingDomainService.update(id, data)
      reply.send(markingDomain)
    } catch (error) {
      if (error instanceof Error && error.message === 'MarkingDomain not found') {
        reply.status(404).send({ error: 'MarkingDomain not found' })
      } else if (error instanceof Error && error.message.includes('already exists')) {
        reply.status(409).send({ error: 'Marking domain with this name already exists' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // DELETE /marking-domains/:id - Delete marking domain
  fastify.delete('/marking-domains/:id', async (request, reply) => {
    try {
      const { id } = markingDomainParamsSchema.parse(request.params)
      await markingDomainService.delete(id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'MarkingDomain not found') {
        reply.status(404).send({ error: 'MarkingDomain not found' })
      } else if (error instanceof Error && error.message.includes('Cannot delete')) {
        reply.status(409).send({ error: error.message })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })
}


================================================
File: src/entities/marking-domain/marking-domain.schema.ts
================================================
import { z } from 'zod'

// Create MarkingDomain Schema
export const createMarkingDomainSchema = z.object({
  name: z.string()
    .min(1, 'Name is required')
    .max(100, 'Name must be less than 100 characters')
    .trim()
})

// Update MarkingDomain Schema
export const updateMarkingDomainSchema = z.object({
  name: z.string()
    .min(1, 'Name is required')
    .max(100, 'Name must be less than 100 characters')
    .trim()
    .optional()
})

// URL Params Schema
export const markingDomainParamsSchema = z.object({
  id: z.string().uuid('Invalid marking domain ID')
})

// Response Schema
export const markingDomainResponseSchema = z.object({
  id: z.string(),
  name: z.string(),
  createdAt: z.date(),
  markingCriteria: z.array(z.object({
    id: z.string(),
    courseCaseId: z.string(),
    text: z.string(),
    points: z.number(),
    displayOrder: z.number(),
    createdAt: z.date()
  })).optional()
})

// Usage stats response schema
export const markingDomainUsageStatsSchema = z.object({
  id: z.string(),
  name: z.string(),
  totalCriteria: z.number(),
  totalCases: z.number(),
  totalPoints: z.number(),
  caseBreakdown: z.array(z.object({
    courseCaseId: z.string(),
    courseCaseTitle: z.string(),
    criteriaCount: z.number(),
    totalPoints: z.number()
  }))
})

// Type exports
export type CreateMarkingDomainInput = z.infer<typeof createMarkingDomainSchema>
export type UpdateMarkingDomainInput = z.infer<typeof updateMarkingDomainSchema>
export type MarkingDomainParams = z.infer<typeof markingDomainParamsSchema>
export type MarkingDomainResponse = z.infer<typeof markingDomainResponseSchema>
export type MarkingDomainUsageStats = z.infer<typeof markingDomainUsageStatsSchema>


================================================
File: src/entities/marking-domain/marking-domain.service.ts
================================================
import { PrismaClient } from '@prisma/client'
import { CreateMarkingDomainInput, UpdateMarkingDomainInput } from './marking-domain.schema'

export class MarkingDomainService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateMarkingDomainInput) {
    // Check if a marking domain with this name already exists
    const existing = await this.prisma.markingDomain.findFirst({
      where: { 
        name: {
          equals: data.name,
          mode: 'insensitive'
        }
      }
    })

    if (existing) {
      throw new Error('Marking domain with this name already exists')
    }

    return await this.prisma.markingDomain.create({
      data: {
        name: data.name
      },
      include: {
        markingCriteria: true
      }
    })
  }

  async findAll() {
    return await this.prisma.markingDomain.findMany({
      include: {
        markingCriteria: {
          select: {
            id: true,
            courseCaseId: true,
            text: true,
            points: true,
            displayOrder: true,
            createdAt: true
          }
        }
      },
      orderBy: {
        name: 'asc'
      }
    })
  }

  async findById(id: string) {
    const markingDomain = await this.prisma.markingDomain.findUnique({
      where: { id },
      include: {
        markingCriteria: {
          select: {
            id: true,
            courseCaseId: true,
            text: true,
            points: true,
            displayOrder: true,
            createdAt: true
          },
          orderBy: {
            displayOrder: 'asc'
          }
        }
      }
    })

    if (!markingDomain) {
      throw new Error('MarkingDomain not found')
    }

    return markingDomain
  }

  async update(id: string, data: UpdateMarkingDomainInput) {
    // Check if exists first
    await this.findById(id)

    // If updating name, check for duplicates
    if (data.name) {
      const existing = await this.prisma.markingDomain.findFirst({
        where: { 
          name: {
            equals: data.name,
            mode: 'insensitive'
          },
          id: { not: id }
        }
      })

      if (existing) {
        throw new Error('Marking domain with this name already exists')
      }
    }

    return await this.prisma.markingDomain.update({
      where: { id },
      data,
      include: {
        markingCriteria: true
      }
    })
  }

  async delete(id: string) {
    // Check if exists first
    await this.findById(id)

    // Check if this domain has any marking criteria
    const criteriaCount = await this.prisma.markingCriterion.count({
      where: { markingDomainId: id }
    })

    if (criteriaCount > 0) {
      throw new Error(`Cannot delete marking domain: ${criteriaCount} marking criteria are still using this domain`)
    }

    // Check if this domain is assigned to any exams
    const examCount = await this.prisma.examMarkingDomain.count({
      where: { markingDomainId: id }
    })

    if (examCount > 0) {
      throw new Error(`Cannot delete marking domain: ${examCount} exams are still using this domain`)
    }

    return await this.prisma.markingDomain.delete({
      where: { id }
    })
  }

  // Get all marking criteria for a specific domain
  async getMarkingCriteria(id: string) {
    // Verify domain exists
    await this.findById(id)

    return await this.prisma.markingCriterion.findMany({
      where: { markingDomainId: id },
      include: {
        courseCase: {
          select: {
            id: true,
            title: true,
            courseId: true,
            course: {
              select: {
                id: true,
                title: true,
                examId: true,
                exam: {
                  select: {
                    id: true,
                    title: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: [
        { courseCase: { displayOrder: 'asc' } },
        { displayOrder: 'asc' }
      ]
    })
  }

  // Get usage statistics for a marking domain
  async getUsageStats(id: string) {
    const markingDomain = await this.findById(id)

    // Get all marking criteria grouped by course case
    const criteria = await this.prisma.markingCriterion.findMany({
      where: { markingDomainId: id },
      include: {
        courseCase: {
          select: {
            id: true,
            title: true
          }
        }
      }
    })

    // Group by course case
    const caseBreakdown = criteria.reduce((acc, criterion) => {
      const caseId = criterion.courseCase.id
      const existing = acc.find(c => c.courseCaseId === caseId)
      
      if (existing) {
        existing.criteriaCount++
        existing.totalPoints += criterion.points
      } else {
        acc.push({
          courseCaseId: caseId,
          courseCaseTitle: criterion.courseCase.title,
          criteriaCount: 1,
          totalPoints: criterion.points
        })
      }
      
      return acc
    }, [] as Array<{
      courseCaseId: string
      courseCaseTitle: string
      criteriaCount: number
      totalPoints: number
    }>)

    return {
      id: markingDomain.id,
      name: markingDomain.name,
      totalCriteria: criteria.length,
      totalCases: caseBreakdown.length,
      totalPoints: criteria.reduce((sum, c) => sum + c.points, 0),
      caseBreakdown
    }
  }
}


================================================
File: src/entities/payment/payment.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { PaymentService } from './payment.service'
import { 
  initiatePaymentSchema, 
  confirmPaymentSchema,
  paymentParamsSchema 
} from './payment.schema'
import { requireAuth, getCurrentStudentId } from '../../middleware/auth.middleware'

export default async function paymentRoutes(fastify: FastifyInstance) {
  const paymentService = new PaymentService(fastify.prisma)

  // POST /payments/initiate - Initiate a payment (student only)
  fastify.post('/payments/initiate', {
    preHandler: requireAuth('student')
  }, async (request, reply) => {
    try {
      const studentId = getCurrentStudentId(request)!
      const data = initiatePaymentSchema.parse(request.body)
      
      // Ensure student is initiating payment for themselves
      if (data.studentId !== studentId) {
        reply.status(403).send({ error: 'You can only initiate payments for yourself' })
        return
      }
      
      const paymentSession = await paymentService.initiatePayment(data)
      
      reply.status(200).send({
        message: 'Payment initiated successfully',
        ...paymentSession
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Student not found') {
          reply.status(404).send({ error: 'Student not found' })
        } else if (error.message === 'Course not found') {
          reply.status(404).send({ error: 'Course not found' })
        } else if (error.message === 'Course is not published') {
          reply.status(400).send({ error: 'Course is not published' })
        } else if (error.message === 'Active subscription already exists') {
          reply.status(400).send({ error: 'You already have an active subscription to this course' })
        } else {
          reply.status(400).send({ error: error.message })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /payments/confirm - Confirm a payment (mock Stripe webhook)
  fastify.post('/payments/confirm', async (request, reply) => {
    try {
      const data = confirmPaymentSchema.parse(request.body)
      const payment = await paymentService.confirmPayment(data)
      
      reply.send({
        message: 'Payment confirmed successfully',
        payment
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Payment not found') {
          reply.status(404).send({ error: 'Payment not found' })
        } else if (error.message === 'Payment is not in pending status') {
          reply.status(400).send({ error: 'Payment is not in pending status' })
        } else if (error.message === 'Invalid payment intent ID') {
          reply.status(400).send({ error: 'Invalid payment intent ID' })
        } else {
          reply.status(400).send({ error: error.message })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // GET /payments/:id - Get payment details
  fastify.get('/payments/:id', {
    preHandler: requireAuth()
  }, async (request, reply) => {
    try {
      const { id } = paymentParamsSchema.parse(request.params)
      const payment = await paymentService.findById(id)
      
      // Check authorization - students can only see their own payments
      const user = request.user as any;
      if (user?.role === 'student' && payment.studentId !== getCurrentStudentId(request)) {
        reply.status(403).send({ error: 'Access denied' })
        return
      }
      
      reply.send(payment)
    } catch (error) {
      if (error instanceof Error && error.message === 'Payment not found') {
        reply.status(404).send({ error: 'Payment not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /payments/mock-checkout - Mock Stripe checkout page (for testing)
  fastify.get('/payments/mock-checkout', async (request, reply) => {
    const { payment_intent } = request.query as { payment_intent: string }
    
    if (!payment_intent) {
      reply.status(400).send({ error: 'Missing payment_intent parameter' })
      return
    }
    
    // In real implementation, this would redirect to Stripe
    // For mock, we'll return a simple HTML form
    reply.type('text/html').send(`
      <!DOCTYPE html>
      <html>
      <head>
        <title>Mock Stripe Checkout</title>
        <style>
          body { font-family: Arial, sans-serif; max-width: 400px; margin: 50px auto; padding: 20px; }
          .form-group { margin-bottom: 15px; }
          label { display: block; margin-bottom: 5px; }
          input { width: 100%; padding: 8px; }
          button { background: #5469d4; color: white; padding: 10px 20px; border: none; cursor: pointer; }
          button:hover { background: #4259c3; }
        </style>
      </head>
      <body>
        <h2>Mock Stripe Payment</h2>
        <p>Payment Intent: ${payment_intent}</p>
        <form id="paymentForm">
          <div class="form-group">
            <label>Card Number</label>
            <input type="text" value="4242 4242 4242 4242" readonly>
          </div>
          <div class="form-group">
            <label>Expiry</label>
            <input type="text" value="12/25" readonly>
          </div>
          <div class="form-group">
            <label>CVC</label>
            <input type="text" value="123" readonly>
          </div>
          <button type="submit">Complete Payment</button>
        </form>
        <script>
          document.getElementById('paymentForm').onsubmit = async (e) => {
            e.preventDefault();
            alert('Payment completed! This is a mock payment.');
            // In real implementation, this would handle Stripe payment
            // and redirect back to your application
            window.close();
          };
        </script>
      </body>
      </html>
    `)
  })
}


================================================
File: src/entities/payment/payment.schema.ts
================================================
import { z } from 'zod'

// Initiate Payment Schema (for subscriptions)
export const initiatePaymentSchema = z.object({
  studentId: z.string().uuid('Invalid student ID'),
  courseId: z.string().uuid('Invalid course ID'),
  durationMonths: z.enum(['3', '6', '12']).transform(val => parseInt(val)),
  paymentType: z.literal('SUBSCRIPTION')
})

// Confirm Payment Schema (mock Stripe webhook)
export const confirmPaymentSchema = z.object({
  paymentId: z.string().uuid('Invalid payment ID'),
  stripePaymentIntentId: z.string() // Mock Stripe payment intent
})

// URL Params Schema
export const paymentParamsSchema = z.object({
  id: z.string().uuid('Invalid payment ID')
})

// Type exports
export type InitiatePaymentInput = z.infer<typeof initiatePaymentSchema>
export type ConfirmPaymentInput = z.infer<typeof confirmPaymentSchema>
export type PaymentParams = z.infer<typeof paymentParamsSchema>


================================================
File: src/entities/payment/payment.service.ts
================================================
import { PrismaClient, PaymentStatus, PaymentType } from '@prisma/client'
import { InitiatePaymentInput, ConfirmPaymentInput } from './payment.schema'

export class PaymentService {
  constructor(private prisma: PrismaClient) {}

  // Initiate a payment (creates pending payment record)
  async initiatePayment(data: InitiatePaymentInput) {
    // Verify student exists
    const student = await this.prisma.student.findUnique({
      where: { id: data.studentId }
    })

    if (!student) {
      throw new Error('Student not found')
    }

    // Verify course exists and get pricing
    const course = await this.prisma.course.findUnique({
      where: { id: data.courseId }
    })

    if (!course) {
      throw new Error('Course not found')
    }

    if (!course.isPublished) {
      throw new Error('Course is not published')
    }

    // Check if student already has active subscription
    const existingSubscription = await this.prisma.subscription.findFirst({
      where: {
        studentId: data.studentId,
        courseId: data.courseId,
        endDate: { gte: new Date() }
      }
    })

    if (existingSubscription) {
      throw new Error('Active subscription already exists')
    }

    // Get pricing based on duration
    const amount = this.getSubscriptionPrice(course, data.durationMonths)
    
    // Generate mock Stripe payment intent ID
    const mockStripePaymentId = `pi_mock_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

    // Create pending payment
    const payment = await this.prisma.payment.create({
      data: {
        studentId: data.studentId,
        stripePaymentId: mockStripePaymentId,
        amount,
        currency: 'USD',
        paymentType: PaymentType.SUBSCRIPTION,
        paymentStatus: PaymentStatus.PENDING,
        courseId: data.courseId,
        subscriptionDuration: data.durationMonths
      }
    })

    // Return payment info with mock Stripe session
    return {
      paymentId: payment.id,
      stripePaymentIntentId: mockStripePaymentId,
      amount: payment.amount,
      currency: payment.currency,
      // Mock Stripe checkout URL
      checkoutUrl: `/mock-stripe-checkout?payment_intent=${mockStripePaymentId}`
    }
  }

  // Confirm a payment (mock Stripe webhook)
  async confirmPayment(data: ConfirmPaymentInput) {
    // Find the pending payment
    const payment = await this.prisma.payment.findUnique({
      where: { id: data.paymentId }
    })

    if (!payment) {
      throw new Error('Payment not found')
    }

    if (payment.paymentStatus !== PaymentStatus.PENDING) {
      throw new Error('Payment is not in pending status')
    }

    if (payment.stripePaymentId !== data.stripePaymentIntentId) {
      throw new Error('Invalid payment intent ID')
    }

    // Update payment to completed
    const updatedPayment = await this.prisma.payment.update({
      where: { id: data.paymentId },
      data: {
        paymentStatus: PaymentStatus.COMPLETED
      }
    })

    return updatedPayment
  }

  // Get payment by ID
  async findById(id: string) {
    const payment = await this.prisma.payment.findUnique({
      where: { id },
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true
          }
        }
      }
    })

    if (!payment) {
      throw new Error('Payment not found')
    }

    return payment
  }

  // Helper method to get subscription price
  private getSubscriptionPrice(course: any, durationMonths: number): number {
    switch (durationMonths) {
      case 3:
        return Number(course.price3Months)
      case 6:
        return Number(course.price6Months)
      case 12:
        return Number(course.price12Months)
      default:
        throw new Error('Invalid subscription duration')
    }
  }
}


================================================
File: src/entities/simulation/simulation.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { z } from 'zod'
import { SimulationService } from './simulation.service'
import { 
  createSimulationSchema, 
  updateSimulationSchema, 
  simulationParamsSchema,
  simulationCourseCaseParamsSchema,
  VoiceModelEnum
} from './simulation.schema'

// Additional schemas for business operations
const creditCostUpdateSchema = z.object({
  creditCost: z.number().int().min(1).max(10)
})

const timeLimitUpdateSchema = z.object({
  timeLimitMinutes: z.number().int().min(1).max(120),
  warningTimeMinutes: z.number().int().min(1).optional()
})

const voiceModelParamsSchema = z.object({
  voiceModel: VoiceModelEnum
})

const creditCostParamsSchema = z.object({
  creditCost: z.string().transform(val => parseInt(val)).refine(val => val >= 1 && val <= 10, 'Invalid credit cost')
})

const courseIdParamsSchema = z.object({
  courseId: z.string().uuid('Invalid course ID')
})

export default async function simulationRoutes(fastify: FastifyInstance) {
  const simulationService = new SimulationService(fastify.prisma)

  // GET /simulations - Get all simulations
  fastify.get('/simulations', async (request, reply) => {
    try {
      const simulations = await simulationService.findAll()
      reply.send(simulations)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch simulations' })
    }
  })

  // GET /simulations/course-case/:courseCaseId - Get simulation by course case
  fastify.get('/simulations/course-case/:courseCaseId', async (request, reply) => {
    try {
      const { courseCaseId } = simulationCourseCaseParamsSchema.parse(request.params)
      const simulation = await simulationService.findByCourseCaseId(courseCaseId)
      reply.send(simulation)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message === 'No simulation configured for this course case') {
          reply.status(404).send({ error: 'No simulation configured for this course case' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // GET /simulations/course/:courseId - Get simulations by course
  fastify.get('/simulations/course/:courseId', async (request, reply) => {
    try {
      const { courseId } = courseIdParamsSchema.parse(request.params)
      const simulations = await simulationService.findByCourse(courseId)
      reply.send(simulations)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /simulations/voice-model/:voiceModel - Get simulations by voice model
  fastify.get('/simulations/voice-model/:voiceModel', async (request, reply) => {
    try {
      const { voiceModel } = voiceModelParamsSchema.parse(request.params)
      const simulations = await simulationService.findByVoiceModel(voiceModel)
      reply.send(simulations)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid voice model' })
    }
  })

  // GET /simulations/credit-cost/:creditCost - Get simulations by credit cost
  fastify.get('/simulations/credit-cost/:creditCost', async (request, reply) => {
    try {
      const { creditCost } = creditCostParamsSchema.parse(request.params)
      const simulations = await simulationService.findByCreditCost(creditCost)
      reply.send(simulations)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid credit cost' })
    }
  })

  // GET /simulations/stats - Get simulation statistics (all courses)
  fastify.get('/simulations/stats', async (request, reply) => {
    try {
      const stats = await simulationService.getSimulationStats()
      reply.send(stats)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch simulation statistics' })
    }
  })

  // GET /simulations/stats/course/:courseId - Get simulation statistics for specific course
  fastify.get('/simulations/stats/course/:courseId', async (request, reply) => {
    try {
      const { courseId } = courseIdParamsSchema.parse(request.params)
      const stats = await simulationService.getSimulationStats(courseId)
      reply.send(stats)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /simulations/:id - Get simulation by ID
  fastify.get('/simulations/:id', async (request, reply) => {
    try {
      const { id } = simulationParamsSchema.parse(request.params)
      const simulation = await simulationService.findById(id)
      reply.send(simulation)
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation not found') {
        reply.status(404).send({ error: 'Simulation not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /simulations - Create new simulation
  fastify.post('/simulations', async (request, reply) => {
    try {
      const data = createSimulationSchema.parse(request.body)
      const simulation = await simulationService.create(data)
      reply.status(201).send(simulation)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message === 'This course case already has a simulation configured') {
          reply.status(400).send({ error: 'This course case already has a simulation configured' })
        } else {
          reply.status(400).send({ error: 'Invalid data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PUT /simulations/:id - Update simulation
  fastify.put('/simulations/:id', async (request, reply) => {
    try {
      const { id } = simulationParamsSchema.parse(request.params)
      const data = updateSimulationSchema.parse(request.body)
      const simulation = await simulationService.update(id, data)
      reply.send(simulation)
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation not found') {
        reply.status(404).send({ error: 'Simulation not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // PATCH /simulations/:id/credit-cost - Update simulation credit cost
  fastify.patch('/simulations/:id/credit-cost', async (request, reply) => {
    try {
      const { id } = simulationParamsSchema.parse(request.params)
      const { creditCost } = creditCostUpdateSchema.parse(request.body)
      const simulation = await simulationService.updateCreditCost(id, creditCost)
      reply.send({
        message: `Credit cost updated to ${creditCost} successfully`,
        simulation
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Simulation not found') {
          reply.status(404).send({ error: 'Simulation not found' })
        } else if (error.message.includes('Credit cost must be')) {
          reply.status(400).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PATCH /simulations/:id/time-limit - Update simulation time limit
  fastify.patch('/simulations/:id/time-limit', async (request, reply) => {
    try {
      const { id } = simulationParamsSchema.parse(request.params)
      const { timeLimitMinutes, warningTimeMinutes } = timeLimitUpdateSchema.parse(request.body)
      const simulation = await simulationService.updateTimeLimit(id, timeLimitMinutes, warningTimeMinutes)
      reply.send({
        message: `Time limit updated to ${timeLimitMinutes} minutes successfully`,
        simulation
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Simulation not found') {
          reply.status(404).send({ error: 'Simulation not found' })
        } else if (error.message.includes('Time limit must be') || error.message.includes('Warning time must be')) {
          reply.status(400).send({ error: error.message })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // DELETE /simulations/:id - Delete simulation
  fastify.delete('/simulations/:id', async (request, reply) => {
    try {
      const { id } = simulationParamsSchema.parse(request.params)
      await simulationService.delete(id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Simulation not found') {
          reply.status(404).send({ error: 'Simulation not found' })
        } else if (error.message === 'Cannot delete simulation with existing student attempts') {
          reply.status(400).send({ error: 'Cannot delete simulation with existing student attempts' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })
}


================================================
File: src/entities/simulation/simulation.schema.ts
================================================
import { z } from 'zod'

// VoiceModel enum
export const VoiceModelEnum = z.enum(['VOICE_1', 'VOICE_2'])

// Create Simulation Schema
export const createSimulationSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  casePrompt: z.string()
    .min(10, 'Case prompt must be at least 10 characters')
    .max(100000, 'Case prompt must be less than 100,000 characters') // Increased to 100k characters
    .trim(),
  openingLine: z.string()
    .min(5, 'Opening line must be at least 5 characters')
    .max(500, 'Opening line must be less than 500 characters')
    .trim(),
  timeLimitMinutes: z.number()
    .int('Time limit must be a whole number')
    .min(1, 'Time limit must be at least 1 minute')
    .max(120, 'Time limit cannot exceed 120 minutes'),
  voiceModel: VoiceModelEnum,
  warningTimeMinutes: z.number()
    .int('Warning time must be a whole number')
    .min(1, 'Warning time must be at least 1 minute')
    .optional(),
  creditCost: z.number()
    .int('Credit cost must be a whole number')
    .min(1, 'Credit cost must be at least 1')
    .max(10, 'Credit cost cannot exceed 10')
    .default(1)
}).refine((data) => {
  // Business rule: Warning time should be less than total time limit
  if (data.warningTimeMinutes && data.warningTimeMinutes >= data.timeLimitMinutes) {
    return false
  }
  return true
}, {
  message: 'Warning time must be less than time limit',
  path: ['warningTimeMinutes']
})

// Update Simulation Schema
export const updateSimulationSchema = z.object({
  casePrompt: z.string()
    .min(10, 'Case prompt must be at least 10 characters')
    .max(100000, 'Case prompt must be less than 100,000 characters') // Increased to 100k characters
    .trim()
    .optional(),
  openingLine: z.string()
    .min(5, 'Opening line must be at least 5 characters')
    .max(500, 'Opening line must be less than 500 characters')
    .trim()
    .optional(),
  timeLimitMinutes: z.number()
    .int('Time limit must be a whole number')
    .min(1, 'Time limit must be at least 1 minute')
    .max(120, 'Time limit cannot exceed 120 minutes')
    .optional(),
  voiceModel: VoiceModelEnum.optional(),
  warningTimeMinutes: z.number()
    .int('Warning time must be a whole number')
    .min(1, 'Warning time must be at least 1 minute')
    .optional(),
  creditCost: z.number()
    .int('Credit cost must be a whole number')
    .min(1, 'Credit cost must be at least 1')
    .max(10, 'Credit cost cannot exceed 10')
    .optional()
})

// URL Params Schemas
export const simulationParamsSchema = z.object({
  id: z.string().uuid('Invalid simulation ID')
})

export const simulationCourseCaseParamsSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID')
})

// Response Schema
export const simulationResponseSchema = z.object({
  id: z.string(),
  courseCaseId: z.string(),
  casePrompt: z.string(),
  openingLine: z.string(),
  timeLimitMinutes: z.number(),
  voiceModel: VoiceModelEnum,
  warningTimeMinutes: z.number().nullable(),
  creditCost: z.number(),
  createdAt: z.date(),
  updatedAt: z.date(),
  courseCase: z.object({
    id: z.string(),
    title: z.string(),
    diagnosis: z.string(),
    patientName: z.string(),
    patientAge: z.number(),
    patientGender: z.string(),
    description: z.string(),
    course: z.object({
      id: z.string(),
      title: z.string(),
      exam: z.object({
        id: z.string(),
        title: z.string(),
        slug: z.string()
      })
    })
  })
})

// Type exports
export type CreateSimulationInput = z.infer<typeof createSimulationSchema>
export type UpdateSimulationInput = z.infer<typeof updateSimulationSchema>
export type SimulationParams = z.infer<typeof simulationParamsSchema>
export type SimulationCourseCaseParams = z.infer<typeof simulationCourseCaseParamsSchema>
export type SimulationResponse = z.infer<typeof simulationResponseSchema>
export type VoiceModel = z.infer<typeof VoiceModelEnum>


================================================
File: src/entities/simulation/simulation.service.ts
================================================
import { PrismaClient } from '@prisma/client'
import { CreateSimulationInput, UpdateSimulationInput, VoiceModel } from './simulation.schema'

export class SimulationService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateSimulationInput) {
    // Verify the course case exists
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id: data.courseCaseId },
      include: {
        course: {
          include: { exam: true }
        }
      }
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    // Check if this course case already has a simulation
    const existingSimulation = await this.prisma.simulation.findUnique({
      where: { courseCaseId: data.courseCaseId }
    })

    if (existingSimulation) {
      throw new Error('This course case already has a simulation configured')
    }

    return await this.prisma.simulation.create({
      data: {
        courseCaseId: data.courseCaseId,
        casePrompt: data.casePrompt,
        openingLine: data.openingLine,
        timeLimitMinutes: data.timeLimitMinutes,
        voiceModel: data.voiceModel,
        warningTimeMinutes: data.warningTimeMinutes,
        creditCost: data.creditCost
      },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  async findAll() {
    return await this.prisma.simulation.findMany({
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async findById(id: string) {
    const simulation = await this.prisma.simulation.findUnique({
      where: { id },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!simulation) {
      throw new Error('Simulation not found')
    }

    return simulation
  }

  async findByCourseCaseId(courseCaseId: string) {
    // Verify course case exists
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id: courseCaseId }
    })

    if (!courseCase) {
      throw new Error('Course case not found')
    }

    const simulation = await this.prisma.simulation.findUnique({
      where: { courseCaseId },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!simulation) {
      throw new Error('No simulation configured for this course case')
    }

    return simulation
  }

  async findByCourse(courseId: string) {
    return await this.prisma.simulation.findMany({
      where: {
        courseCase: {
          courseId: courseId
        }
      },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: {
        courseCase: {
          displayOrder: 'asc'
        }
      }
    })
  }

  async findByVoiceModel(voiceModel: VoiceModel) {
    return await this.prisma.simulation.findMany({
      where: { voiceModel },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async findByCreditCost(creditCost: number) {
    return await this.prisma.simulation.findMany({
      where: { creditCost },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async update(id: string, data: UpdateSimulationInput) {
    // Check if simulation exists
    await this.findById(id)

    return await this.prisma.simulation.update({
      where: { id },
      data,
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  async delete(id: string) {
    // Check if simulation exists
    await this.findById(id)

    // Check if there are any simulation attempts
    const attemptCount = await this.prisma.simulationAttempt.count({
      where: { simulationId: id }
    })

    if (attemptCount > 0) {
      throw new Error('Cannot delete simulation with existing student attempts')
    }

    return await this.prisma.simulation.delete({
      where: { id }
    })
  }

  // BUSINESS LOGIC METHODS

  async updateCreditCost(id: string, creditCost: number) {
    if (creditCost < 1 || creditCost > 10) {
      throw new Error('Credit cost must be between 1 and 10')
    }

    const simulation = await this.findById(id)
    
    return await this.prisma.simulation.update({
      where: { id },
      data: { creditCost },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  async updateTimeLimit(id: string, timeLimitMinutes: number, warningTimeMinutes?: number) {
    if (timeLimitMinutes < 1 || timeLimitMinutes > 120) {
      throw new Error('Time limit must be between 1 and 120 minutes')
    }

    if (warningTimeMinutes && warningTimeMinutes >= timeLimitMinutes) {
      throw new Error('Warning time must be less than time limit')
    }

    const simulation = await this.findById(id)
    
    return await this.prisma.simulation.update({
      where: { id },
      data: { 
        timeLimitMinutes,
        warningTimeMinutes
      },
      include: {
        courseCase: {
          include: {
            course: {
              include: {
                exam: {
                  select: {
                    id: true,
                    title: true,
                    slug: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  async getSimulationStats(courseId?: string) {
    const whereClause = courseId ? {
      courseCase: { courseId }
    } : {}

    const totalSimulations = await this.prisma.simulation.count({
      where: whereClause
    })

    const voiceModelStats = await this.prisma.simulation.groupBy({
      by: ['voiceModel'],
      where: whereClause,
      _count: { voiceModel: true }
    })

    const creditCostStats = await this.prisma.simulation.groupBy({
      by: ['creditCost'],
      where: whereClause,
      _count: { creditCost: true }
    })

    const timeLimitStats = await this.prisma.simulation.aggregate({
      where: whereClause,
      _min: { timeLimitMinutes: true },
      _max: { timeLimitMinutes: true },
      _avg: { timeLimitMinutes: true }
    })

    return {
      courseId: courseId || 'all',
      totalSimulations,
      voiceModelDistribution: voiceModelStats.map((stat: { voiceModel: string; _count: { voiceModel: number } }) => ({
        voiceModel: stat.voiceModel,
        count: stat._count.voiceModel
      })),
      creditCostDistribution: creditCostStats.map((stat: { creditCost: number; _count: { creditCost: number } }) => ({
        creditCost: stat.creditCost,
        count: stat._count.creditCost
      })),
      timeLimitRange: {
        min: timeLimitStats._min.timeLimitMinutes,
        max: timeLimitStats._max.timeLimitMinutes,
        avg: timeLimitStats._avg.timeLimitMinutes ? Math.round(timeLimitStats._avg.timeLimitMinutes) : null
      }
    }
  }
}


================================================
File: src/entities/simulation-attempt/ai-feedback.service.ts
================================================
import OpenAI from 'openai';
import { TranscriptClean } from '../../shared/types';

interface CaseInfo {
  patientName: string;
  diagnosis: string;
  caseTitle: string;
  patientAge?: number;
  patientGender?: string;
}

interface CaseTabs {
  doctorsNote: string[];
  patientScript: string[];
  medicalNotes: string[];
}

interface MarkingCriterionResult {
  criterionId: string;
  criterionText: string;
  points: number; // Now included
  met: boolean;
  transcriptReferences: string[];
  feedback: string;
}

interface MarkingDomainResult {
  domainId: string;
  domainName: string;
  totalPossiblePoints: number; // Now included
  achievedPoints: number; // Now included
  percentageScore: number; // Now included
  criteria: MarkingCriterionResult[];
}

// Performance classification enum
enum PerformanceClassification {
  CLEAR_PASS = 'CLEAR_PASS',
  BORDERLINE_PASS = 'BORDERLINE_PASS',
  BORDERLINE_FAIL = 'BORDERLINE_FAIL',
  CLEAR_FAIL = 'CLEAR_FAIL'
}

interface OverallResult {
  classification: PerformanceClassification;
  classificationLabel: string;
  percentageMet: number;
  totalCriteria: number;
  criteriaMet: number;
  criteriaNotMet: number;
  description: string;
}

interface AIFeedbackResponse {
  overallFeedback: string;
  overallResult: OverallResult;
  markingDomains: MarkingDomainResult[];
}

interface MarkingDomainWithCriteria {
  domainId: string;
  domainName: string;
  criteria: {
    id: string;
    text: string;
    points: number;
    displayOrder: number;
  }[];
}

export class AIFeedbackService {
  private openai: OpenAI;

  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }

  private calculatePerformanceClassification(percentageMet: number): {
    classification: PerformanceClassification;
    label: string;
    description: string;
  } {
    if (percentageMet > 75) {
      return {
        classification: PerformanceClassification.CLEAR_PASS,
        label: 'Clear Pass',
        description: 'More than 75% of checklist items met'
      };
    } else if (percentageMet >= 50) {
      return {
        classification: PerformanceClassification.BORDERLINE_PASS,
        label: 'Borderline Pass',
        description: '50% - 75% of checklist items met'
      };
    } else if (percentageMet >= 25) {
      return {
        classification: PerformanceClassification.BORDERLINE_FAIL,
        label: 'Borderline Fail',
        description: '25% - 50% of checklist items met'
      };
    } else {
      return {
        classification: PerformanceClassification.CLEAR_FAIL,
        label: 'Clear Fail',
        description: 'Less than 25% of checklist items met'
      };
    }
  }

  async generateFeedback(
    transcript: TranscriptClean,
    caseInfo: CaseInfo,
    caseTabs: CaseTabs,
    sessionDuration: number,
    markingDomainsWithCriteria: MarkingDomainWithCriteria[]
  ): Promise<{ 
    feedback: AIFeedbackResponse; 
    score: number; 
    prompts: { systemPrompt: string; userPrompt: string; };
    markingStructure: MarkingDomainWithCriteria[]; // Added to return original structure
  }> {
  
    const systemPrompt = this.buildSystemPrompt(caseInfo, caseTabs, markingDomainsWithCriteria);
    const userPrompt = this.buildUserPrompt(transcript, caseInfo, sessionDuration);
  
    try {
      const completion = await this.openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt }
        ],
        temperature: 0.3,
        max_tokens: 4000,
        response_format: { type: "json_object" }
      });
  
      const responseContent = completion.choices[0]?.message?.content;
      if (!responseContent) {
        throw new Error('No response content from OpenAI');
      }
  
      const rawResponse = JSON.parse(responseContent);
      
      // Calculate overall statistics from the raw response
      let totalCriteria = 0;
      let criteriaMet = 0;
      let totalPossiblePoints = 0;
      let totalAchievedPoints = 0;
      
      // Keep the full structure with points
      const fullDomains: MarkingDomainResult[] = rawResponse.markingDomains.map((domain: any) => {
        let domainAchievedPoints = 0;
        let domainTotalPoints = 0;
        
        const fullCriteria: MarkingCriterionResult[] = domain.criteria.map((criterion: any) => {
          totalCriteria++;
          totalPossiblePoints += criterion.points;
          domainTotalPoints += criterion.points;
          
          if (criterion.met) {
            criteriaMet++;
            totalAchievedPoints += criterion.points;
            domainAchievedPoints += criterion.points;
          }
          
          // Keep all fields including points
          return {
            criterionId: criterion.criterionId,
            criterionText: criterion.criterionText,
            points: criterion.points,
            met: criterion.met,
            transcriptReferences: criterion.transcriptReferences,
            feedback: criterion.feedback
          };
        });
        
        // Return full domain with scoring fields
        return {
          domainId: domain.domainId,
          domainName: domain.domainName,
          totalPossiblePoints: domainTotalPoints,
          achievedPoints: domainAchievedPoints,
          percentageScore: domainTotalPoints > 0 
            ? Math.round((domainAchievedPoints / domainTotalPoints) * 100) 
            : 0,
          criteria: fullCriteria
        };
      });
      
      const percentageMet = totalCriteria > 0 ? (criteriaMet / totalCriteria) * 100 : 0;
      const classification = this.calculatePerformanceClassification(percentageMet);
      
      // Build the full response with all details
      const aiResponse: AIFeedbackResponse = {
        overallFeedback: rawResponse.overallFeedback,
        overallResult: {
          classification: classification.classification,
          classificationLabel: classification.label,
          percentageMet: Math.round(percentageMet * 10) / 10,
          totalCriteria,
          criteriaMet,
          criteriaNotMet: totalCriteria - criteriaMet,
          description: classification.description
        },
        markingDomains: fullDomains
      };
      
      // Calculate overall score
      const score = totalPossiblePoints > 0 
        ? Math.round((totalAchievedPoints / totalPossiblePoints) * 100)
        : 0;
  
      return {
        feedback: aiResponse,
        score: score,
        prompts: {
          systemPrompt,
          userPrompt
        },
        markingStructure: markingDomainsWithCriteria // Return original structure too
      };
  
    } catch (error) {
      console.error('Error generating AI feedback:', error);
      throw new Error('Failed to generate AI feedback');
    }
  }
  
  private buildSystemPrompt(
    caseInfo: CaseInfo,
    caseTabs: CaseTabs,
    markingDomainsWithCriteria: MarkingDomainWithCriteria[]
  ): string {
    
    const totalPossiblePoints = markingDomainsWithCriteria.reduce((sum, domain) => 
      sum + domain.criteria.reduce((domainSum, criterion) => domainSum + criterion.points, 0), 0
    );
    
    const totalCriteria = markingDomainsWithCriteria.reduce((sum, domain) => 
      sum + domain.criteria.length, 0
    );

    return `You are an expert medical examiner evaluating a medical student's performance during a simulated patient consultation.

PATIENT CASE CONTEXT:
- Patient Name: ${caseInfo.patientName}
- Case Title: ${caseInfo.caseTitle}
- Diagnosis: ${caseInfo.diagnosis}
${caseInfo.patientAge ? `- Patient Age: ${caseInfo.patientAge}` : ''}
${caseInfo.patientGender ? `- Patient Gender: ${caseInfo.patientGender}` : ''}

================================
CASE PREPARATION MATERIALS:
================================

DOCTOR'S NOTES (What the examiner expects):
${caseTabs.doctorsNote.length > 0 ? caseTabs.doctorsNote.map((note, i) => `${i + 1}. ${note}`).join('\n') : 'No specific doctor notes provided'}

PATIENT SCRIPT (How the patient should present):
${caseTabs.patientScript.length > 0 ? caseTabs.patientScript.map((script, i) => `${i + 1}. ${script}`).join('\n') : 'No specific patient script provided'}

MEDICAL NOTES (Key medical information):
${caseTabs.medicalNotes.length > 0 ? caseTabs.medicalNotes.map((note, i) => `${i + 1}. ${note}`).join('\n') : 'No specific medical notes provided'}

================================
MARKING CRITERIA:
================================
Total Possible Points: ${totalPossiblePoints}
Total Criteria to Evaluate: ${totalCriteria}

${markingDomainsWithCriteria.map((domain, index) => {
  const domainPoints = domain.criteria.reduce((sum, c) => sum + c.points, 0);
  return `
DOMAIN ${index + 1}: ${domain.domainName}
Domain ID: ${domain.domainId}
Total Points in Domain: ${domainPoints}
Number of Criteria: ${domain.criteria.length}
Criteria to Evaluate:
${domain.criteria.map((criterion, cIndex) => `
  ${cIndex + 1}. [ID: ${criterion.id}] ${criterion.text}
     Points: ${criterion.points}
     Evaluate if MET or NOT MET based on the transcript AND case materials.`).join('')}`;
}).join('\n')}

================================
PERFORMANCE CLASSIFICATION RULES:
================================
Based on the percentage of criteria MET:
- Clear Pass: More than 75% of criteria met
- Borderline Pass: 50% - 75% of criteria met  
- Borderline Fail: 25% - 50% of criteria met
- Clear Fail: Less than 25% of criteria met

EVALUATION INSTRUCTIONS:
1. Use the DOCTOR'S NOTES to understand what the examiner expects from the student
2. Use the PATIENT SCRIPT to assess if the student elicited the correct information
3. Use the MEDICAL NOTES to verify the student's clinical knowledge and approach
4. For EACH criterion:
   - Determine if it was MET (demonstrated) or NOT MET (not/partially demonstrated)
   - Provide 1-3 EXACT quotes from the transcript supporting your decision
   - Consider the case materials when making your determination
   - Provide feedback explaining your decision

5. Criteria are binary - either MET (full points) or NOT MET (0 points)
6. Be strict but fair - the student must demonstrate competency based on the expected standards
7. Count the total number of criteria MET vs NOT MET for classification

RESPONSE FORMAT:
You must respond with a valid JSON object in this exact structure:
{
  "overallFeedback": "2-3 sentence summary comparing performance to case expectations",
  "markingDomains": [
${markingDomainsWithCriteria.map(domain => {
  const domainPoints = domain.criteria.reduce((sum, c) => sum + c.points, 0);
  return `    {
      "domainId": "${domain.domainId}",
      "domainName": "${domain.domainName}",
      "totalPossiblePoints": ${domainPoints},
      "achievedPoints": sum_of_met_criteria_points,
      "percentageScore": domain_percentage,
      "criteria": [
${domain.criteria.map(criterion => `        {
          "criterionId": "${criterion.id}",
          "criterionText": "${criterion.text}",
          "points": ${criterion.points},
          "met": true_or_false,
          "transcriptReferences": ["exact quote 1", "exact quote 2"],
          "feedback": "Explanation referencing case materials where relevant"
        }`).join(',\n')}
      ]
    }`}).join(',\n')}
  ]
}`;
  }

  private buildUserPrompt(
    transcript: TranscriptClean,
    caseInfo: CaseInfo,
    sessionDuration: number
  ): string {
    
    const conversationText = transcript.messages
      .map(msg => {
        const speaker = msg.speaker.toLowerCase().includes('student') || msg.speaker.toLowerCase().includes('doctor') 
          ? 'STUDENT' 
          : 'PATIENT';
        return `[${msg.timestamp}] ${speaker}: ${msg.message}`;
      })
      .join('\n');

    return `Please evaluate this medical student's consultation performance:

CONSULTATION TRANSCRIPT:
${conversationText}

SESSION DETAILS:
- Total Duration: ${Math.floor(sessionDuration / 60)} minutes ${sessionDuration % 60} seconds
- Total Messages: ${transcript.totalMessages}
- Case: ${caseInfo.caseTitle}

CRITICAL INSTRUCTIONS:
1. Compare the student's performance against the DOCTOR'S NOTES expectations
2. Check if the student elicited information mentioned in the PATIENT SCRIPT
3. Verify the student's approach aligns with the MEDICAL NOTES
4. Evaluate EACH criterion as either MET or NOT MET (binary decision)
5. Provide 1-3 EXACT quotes from the transcript for each criterion
6. Reference the case materials in your feedback where relevant
7. Calculate points: MET = full points, NOT MET = 0 points
8. Be aware that the overall classification depends on the percentage of criteria MET

Remember:
- Clear Pass requires >75% of criteria MET
- Borderline Pass requires 50-75% of criteria MET
- Borderline Fail requires 25-50% of criteria MET
- Clear Fail is <25% of criteria MET

Please provide your evaluation in the required JSON format.`;
  }
}

export const aiFeedbackService = new AIFeedbackService();


================================================
File: src/entities/simulation-attempt/simulation-attempt.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { SimulationAttemptService } from './simulation-attempt.service'
import { aiFeedbackService } from './ai-feedback.service'
import { 
  createSimulationAttemptSchema, 
  completeSimulationAttemptSchema,
  updateSimulationAttemptSchema,
  simulationAttemptParamsSchema,
  simulationAttemptStudentParamsSchema,
  simulationAttemptSimulationParamsSchema,
  simulationAttemptQuerySchema,
  simulationAttemptStudentCaseParamsSchema
} from './simulation-attempt.schema'

export default async function simulationAttemptRoutes(fastify: FastifyInstance) {
  const simulationAttemptService = new SimulationAttemptService(fastify.prisma)

  // GET /simulation-attempts - Get all simulation attempts (with query filters)
  fastify.get('/simulation-attempts', async (request, reply) => {
    try {
      const query = simulationAttemptQuerySchema.parse(request.query)
      const attempts = await simulationAttemptService.findAll(query)
      reply.send(attempts)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch simulation attempts' })
    }
  })

  // GET /simulation-attempts/student/:studentId - Get attempts by student
  fastify.get('/simulation-attempts/student/:studentId', async (request, reply) => {
    try {
      const { studentId } = simulationAttemptStudentParamsSchema.parse(request.params)
      const query = simulationAttemptQuerySchema.parse(request.query)
      const attempts = await simulationAttemptService.findByStudent(studentId, query)
      reply.send(attempts)
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  fastify.get('/simulation-attempts/student/:studentId/case/:caseId', async (request, reply) => {
    try {
      const { studentId, caseId } = simulationAttemptStudentCaseParamsSchema.parse(request.params)
      const query = simulationAttemptQuerySchema.parse(request.query)
      const attempts = await simulationAttemptService.findByStudentAndCase(studentId, caseId, query)
      reply.send(attempts)
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Student not found') {
          reply.status(404).send({ error: 'Student not found' })
        } else if (error.message === 'Course case not found') {
          reply.status(404).send({ error: 'Course case not found' })
        } else if (error.message === 'No simulation exists for this case') {
          reply.status(404).send({ error: 'No simulation exists for this case' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // GET /simulation-attempts/simulation/:simulationId - Get attempts by simulation
  fastify.get('/simulation-attempts/simulation/:simulationId', async (request, reply) => {
    try {
      const { simulationId } = simulationAttemptSimulationParamsSchema.parse(request.params)
      const query = simulationAttemptQuerySchema.parse(request.query)
      const attempts = await simulationAttemptService.findBySimulation(simulationId, query)
      reply.send(attempts)
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation not found') {
        reply.status(404).send({ error: 'Simulation not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /simulation-attempts/student/:studentId/stats - Get student performance statistics
  fastify.get('/simulation-attempts/student/:studentId/stats', async (request, reply) => {
    try {
      const { studentId } = simulationAttemptStudentParamsSchema.parse(request.params)
      const stats = await simulationAttemptService.getStudentStats(studentId)
      reply.send(stats)
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /simulation-attempts/simulation/:simulationId/stats - Get simulation usage statistics
  fastify.get('/simulation-attempts/simulation/:simulationId/stats', async (request, reply) => {
    try {
      const { simulationId } = simulationAttemptSimulationParamsSchema.parse(request.params)
      const stats = await simulationAttemptService.getSimulationStats(simulationId)
      reply.send(stats)
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation not found') {
        reply.status(404).send({ error: 'Simulation not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /simulation-attempts/:id - Get simulation attempt by ID
  fastify.get('/simulation-attempts/:id', async (request, reply) => {
    try {
      const { id } = simulationAttemptParamsSchema.parse(request.params)
      const attempt = await simulationAttemptService.findById(id)
      reply.send(attempt)
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation attempt not found') {
        reply.status(404).send({ error: 'Simulation attempt not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /simulation-attempts/correlation/:token - Get attempt by correlation token
  fastify.get('/simulation-attempts/correlation/:token', async (request, reply) => {
    try {
      const { token } = request.params as { token: string }
      const attempt = await simulationAttemptService.findByCorrelationToken(token)
      reply.send(attempt)
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation attempt not found') {
        reply.status(404).send({ error: 'Simulation attempt not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

// POST /simulation-attempts - Start new simulation attempt (NO upfront credit deduction)
fastify.post('/simulation-attempts', async (request, reply) => {
  try {
    const data = createSimulationAttemptSchema.parse(request.body)
    const attempt = await simulationAttemptService.create(data)
    
    // Build voice assistant configuration
    const voiceAssistantConfig = {
      token: attempt.voiceToken,
      correlationToken: attempt.correlationToken,
      wsEndpoint: process.env.VOICE_ASSISTANT_WS_URL || 'ws://localhost:8000/ws/conversation',
      sessionConfig: {
        stt_provider: 'deepgram',
        llm_provider: 'deepinfra',
        tts_provider: 'deepinfra',
        system_prompt: `You are a patient named ${attempt.simulation.courseCase.patientName}. 
          Age: ${attempt.simulation.courseCase.patientAge} years old.
          Gender: ${attempt.simulation.courseCase.patientGender}.
          Diagnosis: ${attempt.simulation.courseCase.diagnosis}. 
          ${attempt.simulation.casePrompt}
          
          Important: Stay in character as the patient. Only provide information that a patient would realistically know about their condition. Do not diagnose yourself or provide medical explanations beyond what a typical patient might understand from their doctor.`
      }
    }
    
    reply.status(201).send({
      message: 'Simulation attempt started successfully. Credits will be charged per minute during conversation.',
      attempt,
      billingInfo: {
        creditsWillBeCharged: 'per_minute',
        currentBalance: attempt.student.creditBalance,
        chargeRate: '1 credit per minute',
        minimumRequired: 1
      },
      voiceAssistantConfig
    })
  } catch (error) {
    if (error instanceof Error) {
      if (error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else if (error.message === 'Simulation not found') {
        reply.status(404).send({ error: 'Simulation not found' })
      } else if (error.message.includes('Insufficient credits')) {
        reply.status(400).send({ 
          error: error.message,
          minimumRequired: 1
        })
      } else {
        console.error('Validation error:', error)
        reply.status(400).send({ 
          error: 'Invalid data',
          details: error.message
        })
      }
    } else {
      reply.status(500).send({ error: 'Internal server error' })
    }
  }
})

  // PATCH /simulation-attempts/:id/complete - Complete simulation attempt (add feedback & score)
  fastify.patch('/simulation-attempts/:id/complete', async (request, reply) => {
    try {
      const { id } = simulationAttemptParamsSchema.parse(request.params)
      const data = completeSimulationAttemptSchema.parse(request.body)
      const attempt = await simulationAttemptService.complete(id, data)
      reply.send({
        message: 'Simulation attempt completed successfully',
        attempt,
        duration: `${Math.floor(attempt.durationSeconds! / 60)}:${String(attempt.durationSeconds! % 60).padStart(2, '0')}`,
        score: attempt.score,
        feedbackGenerated: !!attempt.aiFeedback
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Simulation attempt not found') {
          reply.status(404).send({ error: 'Simulation attempt not found' })
        } else if (error.message === 'Simulation attempt is already completed') {
          reply.status(400).send({ error: 'Simulation attempt is already completed' })
        } else {
          reply.status(400).send({ error: 'Invalid request' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // PUT /simulation-attempts/:id - Update simulation attempt (admin only)
  fastify.put('/simulation-attempts/:id', async (request, reply) => {
    try {
      const { id } = simulationAttemptParamsSchema.parse(request.params)
      const data = updateSimulationAttemptSchema.parse(request.body)
      const attempt = await simulationAttemptService.update(id, data)
      reply.send({
        message: 'Simulation attempt updated successfully',
        attempt
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation attempt not found') {
        reply.status(404).send({ error: 'Simulation attempt not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // DELETE /simulation-attempts/:id - Delete simulation attempt (refunds credits if incomplete)
  fastify.delete('/simulation-attempts/:id', async (request, reply) => {
    try {
      const { id } = simulationAttemptParamsSchema.parse(request.params)
      
      // Get attempt details before deletion for response
      const attempt = await simulationAttemptService.findById(id)
      const wasIncomplete = !attempt.isCompleted
      const creditsToRefund = wasIncomplete ? attempt.simulation.creditCost : 0
      
      await simulationAttemptService.delete(id)
      
      reply.send({
        message: 'Simulation attempt deleted successfully',
        creditsRefunded: creditsToRefund,
        wasIncomplete
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation attempt not found') {
        reply.status(404).send({ error: 'Simulation attempt not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /simulation-attempts/:id/transcript - Get detailed transcript for an attempt
  fastify.get('/simulation-attempts/:id/transcript', async (request, reply) => {
    try {
      const { id } = simulationAttemptParamsSchema.parse(request.params)
      const attempt = await simulationAttemptService.findById(id)
      
      if (!attempt.transcript) {
        reply.status(404).send({ error: 'No transcript available for this attempt' })
        return
      }
      
      reply.send({
        attemptId: attempt.id,
        studentName: `${attempt.student.firstName} ${attempt.student.lastName}`,
        caseTitle: attempt.simulation.courseCase.title,
        startedAt: attempt.startedAt,
        endedAt: attempt.endedAt,
        isCompleted: attempt.isCompleted,
        transcript: attempt.transcript
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation attempt not found') {
        reply.status(404).send({ error: 'Simulation attempt not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /simulation-attempts/:id/feedback - Get detailed AI feedback for an attempt
  fastify.get('/simulation-attempts/:id/feedback', async (request, reply) => {
    try {
      const { id } = simulationAttemptParamsSchema.parse(request.params)
      const attempt = await simulationAttemptService.findById(id)
      
      if (!attempt.aiFeedback) {
        reply.status(404).send({ error: 'No AI feedback available for this attempt' })
        return
      }
      
      reply.send({
        attemptId: attempt.id,
        studentName: `${attempt.student.firstName} ${attempt.student.lastName}`,
        caseTitle: attempt.simulation.courseCase.title,
        score: attempt.score,
        isCompleted: attempt.isCompleted,
        feedback: attempt.aiFeedback
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Simulation attempt not found') {
        reply.status(404).send({ error: 'Simulation attempt not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

// PATCH /simulation-attempts/:id/complete-with-transcript - Complete with automatic transcript fetch and AI feedback generation
fastify.patch('/simulation-attempts/:id/complete-with-transcript', async (request, reply) => {
  try {
    const { id } = simulationAttemptParamsSchema.parse(request.params)
    
    const existingAttempt = await simulationAttemptService.findById(id)
    
    if (!existingAttempt.correlationToken) {
      reply.status(400).send({ 
        error: 'No correlation token found for this attempt. Cannot retrieve transcript.' 
      })
      return
    }
    
    const attempt = await simulationAttemptService.completeWithTranscript(
      id, 
      existingAttempt.correlationToken
    )
    
    const aiFeedback = attempt.aiFeedback as any;
    const aiAnalysisSuccessful = aiFeedback?.analysisStatus !== 'failed';
    
    reply.send({
      message: aiAnalysisSuccessful 
        ? 'Simulation completed successfully with AI-generated feedback' 
        : 'Simulation completed with transcript, but AI analysis failed',
      attempt: {
        ...attempt,
        // Ensure the marking domains are visible in the response
        aiFeedback: aiFeedback ? {
          ...aiFeedback,
          // The markingDomains should now include all details
        } : null
      },
      duration: `${Math.floor(attempt.durationSeconds! / 60)}:${String(attempt.durationSeconds! % 60).padStart(2, '0')}`,
      score: attempt.score,
      transcriptCaptured: !!attempt.transcript,
      aiAnalysisStatus: aiAnalysisSuccessful ? 'success' : 'failed',
      feedbackGenerated: aiAnalysisSuccessful,
      messagesCount: attempt.transcript ? (attempt.transcript as any).messages?.length : 0,
      // Include marking summary
      markingSummary: aiFeedback?.markingStructure ? {
        totalDomains: aiFeedback.markingStructure.length,
        totalCriteria: aiFeedback.overallResult?.totalCriteria,
        criteriaMet: aiFeedback.overallResult?.criteriaMet,
        criteriaNotMet: aiFeedback.overallResult?.criteriaNotMet,
        classification: aiFeedback.overallResult?.classificationLabel
      } : null,
      processingSteps: {
        transcriptRetrieved: !!attempt.transcript,
        aiModelCalled: true,
        feedbackGenerated: aiAnalysisSuccessful,
        scoreCalculated: attempt.score !== null
      }
    })
  } catch (error) {
    console.error('Error completing simulation with transcript:', error)
    
    if (error instanceof Error) {
      if (error.message === 'Simulation attempt not found') {
        reply.status(404).send({ error: 'Simulation attempt not found' })
      } else if (error.message === 'Simulation attempt is already completed') {
        reply.status(400).send({ error: 'Simulation attempt is already completed' })
      } else if (error.message.includes('Failed to retrieve transcript')) {
        reply.status(502).send({ 
          error: 'Failed to retrieve transcript from voice assistant service',
          details: 'The voice assistant API is not responding or returned an error'
        })
      } else if (error.message.includes('Correlation token is required')) {
        reply.status(400).send({ error: 'Correlation token is required for transcript retrieval' })
      } else {
        reply.status(400).send({ error: 'Invalid request', details: error.message })
      }
    } else {
      reply.status(500).send({ error: 'Internal server error' })
    }
  }
})


// POST /simulation-attempts/test-ai-feedback - Test AI feedback generation
fastify.post('/simulation-attempts/test-ai-feedback', async (request, reply) => {
  try {
    // Sample test data
    const testTranscript = {
      messages: [
        {
          timestamp: "00:00:05",
          speaker: "student" as const,
          message: "Hello, I'm Dr. Smith. Thank you for coming in today. What brings you to see me?"
        },
        {
          timestamp: "00:00:12",
          speaker: "ai_patient" as const,
          message: "Hello doctor. I've been having chest pain for the past few days and I'm quite worried about it."
        },
        // ... rest of messages
      ],
      duration: 180,
      totalMessages: 9
    };

    const testCaseInfo = {
      patientName: "Sarah Johnson",
      diagnosis: "Pleuritic chest pain - possible pulmonary embolism",
      caseTitle: "Young adult with acute chest pain post-travel",
      patientAge: 28,
      patientGender: "Female"
    };

    // Sample case tabs
    const testCaseTabs = {
      doctorsNote: [
        "Patient presents with acute chest pain",
        "Recent long-haul flight history",
        "Consider PE in differential"
      ],
      patientScript: [
        "I have sharp chest pain that started 3 days ago",
        "The pain gets worse when I breathe deeply",
        "I flew from Europe last week"
      ],
      medicalNotes: [
        "Risk factors: Recent travel, OCP use",
        "Wells criteria assessment indicated",
        "Consider D-dimer and CTPA if indicated"
      ]
    };

    // Sample marking domains with criteria
    const testMarkingDomainsWithCriteria = [
      {
        domainId: "domain-1",
        domainName: "Communication Skills",
        criteria: [
          {
            id: "crit-1",
            text: "Introduces self appropriately",
            points: 5,
            displayOrder: 1
          },
          {
            id: "crit-2",
            text: "Uses open-ended questions",
            points: 5,
            displayOrder: 2
          }
        ]
      },
      {
        domainId: "domain-2",
        domainName: "Clinical History Taking",
        criteria: [
          {
            id: "crit-3",
            text: "Asks about recent travel history",
            points: 10,
            displayOrder: 1
          },
          {
            id: "crit-4",
            text: "Explores pain characteristics",
            points: 8,
            displayOrder: 2
          }
        ]
      }
    ];

    // Call with correct parameter order
    const result = await aiFeedbackService.generateFeedback(
      testTranscript,
      testCaseInfo,
      testCaseTabs,  // CaseTabs object (3rd parameter)
      180,  // duration in seconds (4th parameter)
      testMarkingDomainsWithCriteria  // marking domains (5th parameter)
    );

    reply.send({
      message: 'Enhanced AI feedback generated successfully',
      result: result,
      testData: {
        transcript: testTranscript,
        caseInfo: testCaseInfo,
        caseTabs: testCaseTabs,
        markingDomainsWithCriteria: testMarkingDomainsWithCriteria,
        enhancedFeatures: {
          domainsUsed: testMarkingDomainsWithCriteria.length,
          totalPossiblePoints: testMarkingDomainsWithCriteria.reduce((sum, domain) => 
            sum + domain.criteria.reduce((cSum, c) => cSum + c.points, 0), 0
          ),
          structureImprovement: "Now using structured marking criteria grouped by domain"
        }
      }
    });

  } catch (error) {
    console.error('Error testing enhanced AI feedback:', error);
    reply.status(500).send({ 
      error: 'Failed to generate test AI feedback',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});
}


================================================
File: src/entities/simulation-attempt/simulation-attempt.schema.ts
================================================
import { z } from 'zod'

// Create SimulationAttempt Schema (start session)
export const createSimulationAttemptSchema = z.object({
  studentId: z.string().uuid('Invalid student ID'),
  simulationId: z.string().uuid('Invalid simulation ID')
  // startedAt will be auto-set to now()
  // endedAt, score, feedback will be set when session completes
})

// Complete SimulationAttempt Schema (end session)
export const completeSimulationAttemptSchema = z.object({
  score: z.number()
    .min(0, 'Score cannot be negative')
    .max(100, 'Score cannot exceed 100')
    .optional(),
  aiFeedback: z.object({
    overallFeedback: z.string(),
    strengths: z.array(z.string()),
    improvements: z.array(z.string()),
    score: z.number().min(0).max(100).optional(),
    markingDomains: z.array(z.object({
      domain: z.string(),
      score: z.number().min(0).max(100),
      feedback: z.string()
    })).optional()
  }).optional(),
  transcript: z.object({
    messages: z.array(z.object({
      timestamp: z.string(),
      speaker: z.enum(['student', 'ai_patient']),
      message: z.string()
    })),
    duration: z.number(),
    totalMessages: z.number()
  }).optional()
})

// Update SimulationAttempt Schema (for admin edits)
export const updateSimulationAttemptSchema = z.object({
  score: z.number()
    .min(0, 'Score cannot be negative')
    .max(100, 'Score cannot exceed 100')
    .optional(),
  aiFeedback: z.object({
    overallFeedback: z.string(),
    strengths: z.array(z.string()),
    improvements: z.array(z.string()),
    score: z.number().min(0).max(100).optional(),
    markingDomains: z.array(z.object({
      domain: z.string(),
      score: z.number().min(0).max(100),
      feedback: z.string()
    })).optional()
  }).optional(),
  transcript: z.object({
    messages: z.array(z.object({
      timestamp: z.string(),
      speaker: z.enum(['student', 'ai_patient']),
      message: z.string()
    })),
    duration: z.number(),
    totalMessages: z.number()
  }).optional()
})

// URL Params Schemas
export const simulationAttemptParamsSchema = z.object({
  id: z.string().uuid('Invalid simulation attempt ID')
})

export const simulationAttemptStudentParamsSchema = z.object({
  studentId: z.string().uuid('Invalid student ID')
})

export const simulationAttemptSimulationParamsSchema = z.object({
  simulationId: z.string().uuid('Invalid simulation ID')
})

// Query Params Schemas
export const simulationAttemptQuerySchema = z.object({
  completed: z.string().transform(val => val === 'true').optional(),
  limit: z.string().transform(val => parseInt(val)).refine(val => val > 0 && val <= 100, 'Limit must be between 1 and 100').optional(),
  offset: z.string().transform(val => parseInt(val)).refine(val => val >= 0, 'Offset must be non-negative').optional()
})

// Response Schema
export const simulationAttemptResponseSchema = z.object({
  id: z.string(),
  studentId: z.string(),
  simulationId: z.string(),
  startedAt: z.date(),
  endedAt: z.date().nullable(),
  durationSeconds: z.number().nullable(),
  isCompleted: z.boolean(),
  score: z.number().nullable(),
  aiFeedback: z.any().nullable(), // JSON field
  aiPrompt: z.any().nullable(), 
  transcript: z.any().nullable(), // JSON field
  correlationToken: z.string().nullable(),
  createdAt: z.date(),
  student: z.object({
    id: z.string(),
    firstName: z.string(),
    lastName: z.string(),
    creditBalance: z.number()
  }),
  simulation: z.object({
    id: z.string(),
    timeLimitMinutes: z.number(),
    creditCost: z.number(),
    voiceModel: z.string(),
    courseCase: z.object({
      id: z.string(),
      title: z.string(),
      diagnosis: z.string(),
      patientName: z.string(),
      course: z.object({
        id: z.string(),
        title: z.string()
      })
    })
  })
})

export const simulationAttemptWithTokenResponseSchema = simulationAttemptResponseSchema.extend({
  voiceAssistantConfig: z.object({
    correlationToken: z.string(),
    wsEndpoint: z.string(),
    sessionConfig: z.object({
      stt_provider: z.string().optional(),
      llm_provider: z.string().optional(),
      tts_provider: z.string().optional(),
      system_prompt: z.string().optional()
    }).optional()
  }).optional()
})

export const simulationAttemptStudentCaseParamsSchema = z.object({
  studentId: z.string().uuid('Invalid student ID'),
  caseId: z.string().uuid('Invalid case ID')
})



// Type exports
export type CreateSimulationAttemptInput = z.infer<typeof createSimulationAttemptSchema>
export type CompleteSimulationAttemptInput = z.infer<typeof completeSimulationAttemptSchema>
export type UpdateSimulationAttemptInput = z.infer<typeof updateSimulationAttemptSchema>
export type SimulationAttemptParams = z.infer<typeof simulationAttemptParamsSchema>
export type SimulationAttemptStudentParams = z.infer<typeof simulationAttemptStudentParamsSchema>
export type SimulationAttemptSimulationParams = z.infer<typeof simulationAttemptSimulationParamsSchema>
export type SimulationAttemptQuery = z.infer<typeof simulationAttemptQuerySchema>
export type SimulationAttemptResponse = z.infer<typeof simulationAttemptResponseSchema>
export type SimulationAttemptWithTokenResponse = z.infer<typeof simulationAttemptWithTokenResponseSchema>
export type SimulationAttemptStudentCaseParams = z.infer<typeof simulationAttemptStudentCaseParamsSchema>




================================================
File: src/entities/simulation-attempt/simulation-attempt.service.ts
================================================
import { PrismaClient, Prisma } from '@prisma/client'
import { CreateSimulationAttemptInput, CompleteSimulationAttemptInput, UpdateSimulationAttemptInput } from './simulation-attempt.schema'
import { randomBytes } from 'crypto'
import {
  VoiceAssistantTranscriptApi,
  TranscriptClean,
  } from '../../shared/types';
import { aiFeedbackService } from './ai-feedback.service' 
import { voiceTokenService } from '../../services/voice-token.service';

export class SimulationAttemptService {
  constructor(private prisma: PrismaClient) {}

  private generateCorrelationToken(): string {
    // Generate a URL-safe token
    return `sim_${randomBytes(16).toString('hex')}_${Date.now()}`
  }

async create(data: CreateSimulationAttemptInput) {
  // Verify the student exists
  const student = await this.prisma.student.findUnique({
    where: { id: data.studentId }
  })

  if (!student) {
    throw new Error('Student not found')
  }

  // Verify the simulation exists
  const simulation = await this.prisma.simulation.findUnique({
    where: { id: data.simulationId },
    include: {
      courseCase: {
        include: {
          course: true
        }
      }
    }
  })

  if (!simulation) {
    throw new Error('Simulation not found')
  }

  // Check if student has at least 1 credit to start
  // (Will be charged per-minute during conversation)
  if (student.creditBalance < 1) {
    throw new Error(`Insufficient credits. You need at least 1 credit to start. Current balance: ${student.creditBalance}`)
  }

  const correlationToken = this.generateCorrelationToken()

  // Create attempt WITHOUT deducting credits
  // Credits will be deducted per-minute by the billing webhook
  const attempt = await this.prisma.simulationAttempt.create({
    data: {
      studentId: data.studentId,
      simulationId: data.simulationId,
      startedAt: new Date(),
      correlationToken: correlationToken
    },
    include: {
      student: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
          creditBalance: true
        }
      },
      simulation: {
        include: {
          courseCase: {
            include: {
              course: {
                select: {
                  id: true,
                  title: true
                }
              }
            }
          }
        }
      }
    }
  })

  const voiceToken = voiceTokenService.generateToken({
    attemptId: attempt.id,
    studentId: attempt.studentId,
    correlationToken: attempt.correlationToken || ''
  });

  // Log the attempt creation for billing tracking
  console.log(`[BILLING] Simulation attempt created without upfront charge. ID: ${attempt.id}, Token: ${correlationToken}`);

  return {
    ...attempt,
    voiceToken
  }
}

  async complete(id: string, data: CompleteSimulationAttemptInput) {
    // Check if attempt exists and is not already completed
    const attempt = await this.prisma.simulationAttempt.findUnique({
      where: { id },
      include: {
        simulation: true
      }
    })

    if (!attempt) {
      throw new Error('Simulation attempt not found')
    }

    if (attempt.isCompleted) {
      throw new Error('Simulation attempt is already completed')
    }

    const endTime = new Date()
    const durationSeconds = Math.floor((endTime.getTime() - attempt.startedAt.getTime()) / 1000)

    return await this.prisma.simulationAttempt.update({
      where: { id },
      data: {
        endedAt: endTime,
        durationSeconds: durationSeconds,
        isCompleted: true,
        score: data.score,
        aiFeedback: data.aiFeedback,
        transcript: data.transcript
      },
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            creditBalance: true
          }
        },
        simulation: {
          include: {
            courseCase: {
              include: {
                course: {
                  select: {
                    id: true,
                    title: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  async findAll(query?: { completed?: boolean; limit?: number; offset?: number }) {
    const where: any = {}
    if (query?.completed !== undefined) {
      where.isCompleted = query.completed
    }

    return await this.prisma.simulationAttempt.findMany({
      where,
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            creditBalance: true
          }
        },
        simulation: {
          include: {
            courseCase: {
              include: {
                course: {
                  select: {
                    id: true,
                    title: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: {
        startedAt: 'desc'
      },
      take: query?.limit || 50,
      skip: query?.offset || 0
    })
  }

  async findById(id: string) {
    const attempt = await this.prisma.simulationAttempt.findUnique({
      where: { id },
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            creditBalance: true
          }
        },
        simulation: {
          include: {
            courseCase: {
              include: {
                course: {
                  select: {
                    id: true,
                    title: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!attempt) {
      throw new Error('Simulation attempt not found')
    }

    return attempt
  }

  async findByCorrelationToken(correlationToken: string) {
    const attempt = await this.prisma.simulationAttempt.findUnique({
      where: { correlationToken },
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            creditBalance: true
          }
        },
        simulation: {
          include: {
            courseCase: {
              include: {
                course: {
                  select: {
                    id: true,
                    title: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!attempt) {
      throw new Error('Simulation attempt not found')
    }

    return attempt
  }

  async findByStudent(studentId: string, query?: { completed?: boolean; limit?: number; offset?: number }) {
    // Verify student exists
    const student = await this.prisma.student.findUnique({
      where: { id: studentId }
    })

    if (!student) {
      throw new Error('Student not found')
    }

    const where: any = { studentId }
    if (query?.completed !== undefined) {
      where.isCompleted = query.completed
    }

    return await this.prisma.simulationAttempt.findMany({
      where,
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            creditBalance: true
          }
        },
        simulation: {
          include: {
            courseCase: {
              include: {
                course: {
                  select: {
                    id: true,
                    title: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: {
        startedAt: 'desc'
      },
      take: query?.limit || 50,
      skip: query?.offset || 0
    })
  }

  async findBySimulation(simulationId: string, query?: { completed?: boolean; limit?: number; offset?: number }) {
    // Verify simulation exists
    const simulation = await this.prisma.simulation.findUnique({
      where: { id: simulationId }
    })

    if (!simulation) {
      throw new Error('Simulation not found')
    }

    const where: any = { simulationId }
    if (query?.completed !== undefined) {
      where.isCompleted = query.completed
    }

    return await this.prisma.simulationAttempt.findMany({
      where,
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            creditBalance: true
          }
        },
        simulation: {
          include: {
            courseCase: {
              include: {
                course: {
                  select: {
                    id: true,
                    title: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: {
        startedAt: 'desc'
      },
      take: query?.limit || 50,
      skip: query?.offset || 0
    })
  }

  async update(id: string, data: UpdateSimulationAttemptInput) {
    // Check if attempt exists
    await this.findById(id)

    return await this.prisma.simulationAttempt.update({
      where: { id },
      data,
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            creditBalance: true
          }
        },
        simulation: {
          include: {
            courseCase: {
              include: {
                course: {
                  select: {
                    id: true,
                    title: true
                  }
                }
              }
            }
          }
        }
      }
    })
  }

  async delete(id: string) {
    // Check if attempt exists
    const attempt = await this.findById(id)

    // If attempt was not completed, refund credits to student
    if (!attempt.isCompleted) {
      await this.prisma.$transaction(async (tx: Prisma.TransactionClient) => {
        // Get current student credit balance
        const student = await tx.student.findUnique({
          where: { id: attempt.studentId }
        })

        if (student) {
          // Refund credits
          await tx.student.update({
            where: { id: attempt.studentId },
            data: {
              creditBalance: student.creditBalance + attempt.simulation.creditCost
            }
          })
        }

        // Delete the attempt
        await tx.simulationAttempt.delete({
          where: { id }
        })
      })
    } else {
      // Just delete if completed (no refund)
      await this.prisma.simulationAttempt.delete({
        where: { id }
      })
    }
  }

  // BUSINESS LOGIC METHODS

  async getStudentStats(studentId: string) {
    const student = await this.prisma.student.findUnique({
      where: { id: studentId }
    })

    if (!student) {
      throw new Error('Student not found')
    }

    const totalAttempts = await this.prisma.simulationAttempt.count({
      where: { studentId }
    })

    const completedAttempts = await this.prisma.simulationAttempt.count({
      where: { studentId, isCompleted: true }
    })

    const incompleteAttempts = totalAttempts - completedAttempts

    const scoreStats = await this.prisma.simulationAttempt.aggregate({
      where: { studentId, isCompleted: true, score: { not: null } },
      _avg: { score: true },
      _min: { score: true },
      _max: { score: true }
    })

    const durationStats = await this.prisma.simulationAttempt.aggregate({
      where: { studentId, isCompleted: true },
      _avg: { durationSeconds: true },
      _min: { durationSeconds: true },
      _max: { durationSeconds: true }
    })

    return {
      studentId,
      studentName: `${student.firstName} ${student.lastName}`,
      currentCreditBalance: student.creditBalance,
      totalAttempts,
      completedAttempts,
      incompleteAttempts,
      completionRate: totalAttempts > 0 ? Math.round((completedAttempts / totalAttempts) * 100) : 0,
      scoreStats: {
        average: scoreStats._avg.score ? Number(scoreStats._avg.score.toFixed(1)) : null,
        minimum: scoreStats._min.score ? Number(scoreStats._min.score) : null,
        maximum: scoreStats._max.score ? Number(scoreStats._max.score) : null
      },
      durationStats: {
        averageSeconds: durationStats._avg.durationSeconds ? Math.round(durationStats._avg.durationSeconds) : null,
        minimumSeconds: durationStats._min.durationSeconds,
        maximumSeconds: durationStats._max.durationSeconds
      }
    }
  }

  async getSimulationStats(simulationId: string) {
    const simulation = await this.prisma.simulation.findUnique({
      where: { id: simulationId },
      include: {
        courseCase: true
      }
    })

    if (!simulation) {
      throw new Error('Simulation not found')
    }

    const totalAttempts = await this.prisma.simulationAttempt.count({
      where: { simulationId }
    })

    const completedAttempts = await this.prisma.simulationAttempt.count({
      where: { simulationId, isCompleted: true }
    })

    const uniqueStudents = await this.prisma.simulationAttempt.findMany({
      where: { simulationId },
      select: { studentId: true },
      distinct: ['studentId']
    })

    const scoreStats = await this.prisma.simulationAttempt.aggregate({
      where: { simulationId, isCompleted: true, score: { not: null } },
      _avg: { score: true },
      _min: { score: true },
      _max: { score: true }
    })

    return {
      simulationId,
      caseTitle: simulation.courseCase.title,
      totalAttempts,
      completedAttempts,
      incompleteAttempts: totalAttempts - completedAttempts,
      uniqueStudents: uniqueStudents.length,
      completionRate: totalAttempts > 0 ? Math.round((completedAttempts / totalAttempts) * 100) : 0,
      scoreStats: {
        average: scoreStats._avg.score ? Number(scoreStats._avg.score.toFixed(1)) : null,
        minimum: scoreStats._min.score ? Number(scoreStats._min.score) : null,
        maximum: scoreStats._max.score ? Number(scoreStats._max.score) : null
      }
    }
  }
  private transformTranscript = (
    api: VoiceAssistantTranscriptApi,
  ): TranscriptClean => ({
    messages: api.messages.map(({ timestamp, speaker, message }) => ({
      timestamp,
      speaker: speaker === 'participant' ? 'student' : 'ai_patient', // Map speakers properly
      message,
    })),
    duration: api.duration_seconds ?? 0,
    totalMessages: api.total_messages,
  });
  

  async completeWithTranscript(
    attemptId: string, 
    correlationToken: string
  ): Promise<any> {
    // Fetch attempt with all necessary relations
    const existingAttempt = await this.prisma.simulationAttempt.findUnique({
      where: { id: attemptId },
      include: {
        student: true,
        simulation: {
          include: {
            courseCase: {
              include: {
                course: {
                  include: {
                    exam: true
                  }
                },
                // Include ALL case tabs (not just MARKING_CRITERIA)
                caseTabs: true,
                // Include the new separate marking criteria
                markingCriteria: {
                  include: {
                    markingDomain: true
                  },
                  orderBy: [
                    { markingDomain: { name: 'asc' } },
                    { displayOrder: 'asc' }
                  ]
                }
              }
            }
          }
        }
      }
    });
  
    if (!existingAttempt) {
      throw new Error('Simulation attempt not found');
    }
  
    if (existingAttempt.isCompleted) {
      throw new Error('Simulation attempt is already completed');
    }
  
    try {
      // 1. Fetch transcript from voice assistant API
      const transcriptResponse = await fetch(
        `${process.env.VOICE_ASSISTANT_API_URL}/api/transcripts/correlation/${correlationToken}`,
        {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json'
          }
        }
      );
  
      if (!transcriptResponse.ok) {
        throw new Error(`Failed to retrieve transcript: ${transcriptResponse.statusText}`);
      }
  
      const apiResponse = await transcriptResponse.json() as VoiceAssistantTranscriptApi;
      const transcriptData: TranscriptClean = this.transformTranscript(apiResponse);
      
      const endTime = new Date();
      const durationSeconds = Math.floor((endTime.getTime() - new Date(existingAttempt.startedAt).getTime()) / 1000);
  
      // 2. Extract case tabs (doctor's notes, patient script, medical notes)
      interface CaseTabs {
        doctorsNote: string[];
        patientScript: string[];
        medicalNotes: string[];
      }
  
      const caseTabs: CaseTabs = {
        doctorsNote: [],
        patientScript: [],
        medicalNotes: []
      };
  
      existingAttempt.simulation.courseCase.caseTabs.forEach(tab => {
        switch(tab.tabType) {
          case 'DOCTORS_NOTE':
            caseTabs.doctorsNote = tab.content;
            break;
          case 'PATIENT_SCRIPT':
            caseTabs.patientScript = tab.content;
            break;
          case 'MEDICAL_NOTES':
            caseTabs.medicalNotes = tab.content;
            break;
        }
      });
  
      // 3. Group marking criteria by domain
      interface MarkingDomainWithCriteria {
        domainId: string;
        domainName: string;
        criteria: {
          id: string;
          text: string;
          points: number;
          displayOrder: number;
        }[];
      }
  
      const domainsMap = new Map<string, MarkingDomainWithCriteria>();
      
      existingAttempt.simulation.courseCase.markingCriteria.forEach(criterion => {
        const domainId = criterion.markingDomain.id;
        
        if (!domainsMap.has(domainId)) {
          domainsMap.set(domainId, {
            domainId: criterion.markingDomain.id,
            domainName: criterion.markingDomain.name,
            criteria: []
          });
        }
        
        domainsMap.get(domainId)!.criteria.push({
          id: criterion.id,
          text: criterion.text,
          points: criterion.points,
          displayOrder: criterion.displayOrder
        });
      });
  
      const markingDomainsWithCriteria = Array.from(domainsMap.values());
  
      // 4. Prepare case info
      const caseInfo = {
        patientName: existingAttempt.simulation.courseCase.patientName,
        diagnosis: existingAttempt.simulation.courseCase.diagnosis,
        caseTitle: existingAttempt.simulation.courseCase.title,
        patientAge: existingAttempt.simulation.courseCase.patientAge,
        patientGender: existingAttempt.simulation.courseCase.patientGender
      };
  
      let aiFeedback: Prisma.InputJsonValue | null = null;
      let score: number | null = null;
      let aiPrompt: Prisma.InputJsonValue | null = null;
    
      try {
        // Generate AI feedback with the new structure
        const { 
          feedback, 
          score: calculatedScore, 
          prompts,
          markingStructure 
        } = await aiFeedbackService.generateFeedback(
          transcriptData,
          caseInfo,
          caseTabs,
          durationSeconds,
          markingDomainsWithCriteria
        );
    
        // Include full marking structure in the feedback
        aiFeedback = {
          ...feedback,
          analysisStatus: 'success',
          generatedAt: new Date().toISOString(),
          caseTabsProvided: {
            doctorsNote: caseTabs.doctorsNote.length > 0,
            patientScript: caseTabs.patientScript.length > 0,
            medicalNotes: caseTabs.medicalNotes.length > 0
          },
          totalMarkingCriteria: existingAttempt.simulation.courseCase.markingCriteria.length,
          markingDomainsCount: markingDomainsWithCriteria.length,
          markingStructure: markingStructure // Include the original structure
        } as unknown as Prisma.InputJsonValue;
        
        score = calculatedScore;
        aiPrompt = prompts as unknown as Prisma.InputJsonValue;
        
      } catch (aiError) {
        console.error('AI feedback generation failed:', aiError);
        aiFeedback = {
          analysisStatus: 'failed',
          error: aiError instanceof Error ? aiError.message : 'Unknown AI error',
          generatedAt: new Date().toISOString(),
          markingStructure: markingDomainsWithCriteria // Include even on failure
        } as unknown as Prisma.InputJsonValue;
      }
  
      // 6. Update the simulation attempt
      const updatedAttempt = await this.prisma.simulationAttempt.update({
        where: { id: attemptId },
        data: {
          endedAt: endTime,
          durationSeconds,
          isCompleted: true,
          transcript: transcriptData as unknown as Prisma.InputJsonValue,
          aiFeedback,
          aiPrompt: aiPrompt || undefined,
          score
        },
        include: {
          student: true,
          simulation: {
            include: {
              courseCase: {
                include: {
                  course: true
                }
              }
            }
          }
        }
      });
  
      return updatedAttempt;
  
    } catch (error) {
      console.error('Error in completeWithTranscript:', error);
      throw error;
    }
  }
  
  // Helper method for fallback feedback when AI model fails
  private generateFallbackFeedback() {
    return {
      overallFeedback: "Technical issue occurred during AI analysis. Please contact support for manual review.",
      strengths: [
        "Session completed successfully",
        "Transcript captured for review"
      ],
      improvements: [
        "AI analysis temporarily unavailable",
        "Manual review may be provided"
      ],
      score: null,
      markingDomains: [
        {
          domain: "Communication Skills",
          score: 0,
          feedback: "Analysis pending due to technical issue"
        },
        {
          domain: "Clinical Assessment", 
          score: 0,
          feedback: "Analysis pending due to technical issue"
        },
        {
          domain: "Professionalism",
          score: 0,
          feedback: "Analysis pending due to technical issue"
        }
      ],
      analysisStatus: "failed" // Flag to indicate AI analysis failed
    };
  }

  async findByStudentAndCase(
    studentId: string, 
    caseId: string, 
    query?: { completed?: boolean; limit?: number; offset?: number }
  ) {
    // Verify student exists
    const student = await this.prisma.student.findUnique({
      where: { id: studentId }
    })
  
    if (!student) {
      throw new Error('Student not found')
    }
  
    // Verify course case exists and has a simulation
    const courseCase = await this.prisma.courseCase.findUnique({
      where: { id: caseId },
      include: {
        simulation: true
      }
    })
  
    if (!courseCase) {
      throw new Error('Course case not found')
    }
  
    if (!courseCase.simulation) {
      throw new Error('No simulation exists for this case')
    }
  
    const where: any = { 
      studentId,
      simulationId: courseCase.simulation.id
    }
    
    if (query?.completed !== undefined) {
      where.isCompleted = query.completed
    }
  
    const attempts = await this.prisma.simulationAttempt.findMany({
      where,
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            creditBalance: true
          }
        },
        simulation: {
          include: {
            courseCase: {
              include: {
                course: {
                  select: {
                    id: true,
                    title: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: {
        startedAt: 'desc'
      },
      take: query?.limit || 50,
      skip: query?.offset || 0
    })
  
    // Add summary statistics
    const stats = {
      totalAttempts: await this.prisma.simulationAttempt.count({ where }),
      completedAttempts: await this.prisma.simulationAttempt.count({ 
        where: { ...where, isCompleted: true } 
      }),
      averageScore: await this.prisma.simulationAttempt.aggregate({
        where: { ...where, isCompleted: true, score: { not: null } },
        _avg: { score: true }
      }).then(result => result._avg.score ? Number(result._avg.score.toFixed(1)) : null)
    }
  
    return {
      attempts,
      stats,
      student: {
        id: student.id,
        name: `${student.firstName} ${student.lastName}`,
        creditBalance: student.creditBalance
      },
      case: {
        id: courseCase.id,
        title: courseCase.title,
        diagnosis: courseCase.diagnosis,
        patientName: courseCase.patientName
      }
    }
  }
}


================================================
File: src/entities/specialty/specialty.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { SpecialtyService } from './specialty.service'
import { 
  createSpecialtySchema, 
  updateSpecialtySchema, 
  specialtyParamsSchema 
} from './specialty.schema'

export default async function specialtyRoutes(fastify: FastifyInstance) {
  const specialtyService = new SpecialtyService(fastify.prisma)

  // GET /specialties - Get all specialties
  fastify.get('/specialties', async (request, reply) => {
    try {
      const specialties = await specialtyService.findAll()
      reply.send(specialties)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch specialties' })
    }
  })

  // GET /specialties/:id - Get specialty by ID
  fastify.get('/specialties/:id', async (request, reply) => {
    try {
      const { id } = specialtyParamsSchema.parse(request.params)
      const specialty = await specialtyService.findById(id)
      reply.send(specialty)
    } catch (error) {
      if (error instanceof Error && error.message === 'Specialty not found') {
        reply.status(404).send({ error: 'Specialty not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /specialties - Create new specialty
  fastify.post('/specialties', async (request, reply) => {
    try {
      const data = createSpecialtySchema.parse(request.body)
      const specialty = await specialtyService.create(data)
      reply.status(201).send(specialty)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid data or specialty already exists' })
    }
  })

  // PUT /specialties/:id - Update specialty
  fastify.put('/specialties/:id', async (request, reply) => {
    try {
      const { id } = specialtyParamsSchema.parse(request.params)
      const data = updateSpecialtySchema.parse(request.body)
      const specialty = await specialtyService.update(id, data)
      reply.send(specialty)
    } catch (error) {
      if (error instanceof Error && error.message === 'Specialty not found') {
        reply.status(404).send({ error: 'Specialty not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // DELETE /specialties/:id - Delete specialty
  fastify.delete('/specialties/:id', async (request, reply) => {
    try {
      const { id } = specialtyParamsSchema.parse(request.params)
      await specialtyService.delete(id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'Specialty not found') {
        reply.status(404).send({ error: 'Specialty not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })
}


================================================
File: src/entities/specialty/specialty.schema.ts
================================================
import { z } from 'zod'

// Create Specialty Schema
export const createSpecialtySchema = z.object({
  name: z.string()
    .min(1, 'Name is required')
    .max(100, 'Name must be less than 100 characters')
    .trim()
})

// Update Specialty Schema
export const updateSpecialtySchema = z.object({
  name: z.string()
    .min(1, 'Name is required')
    .max(100, 'Name must be less than 100 characters')
    .trim()
    .optional()
})

// URL Params Schema
export const specialtyParamsSchema = z.object({
  id: z.string().uuid('Invalid specialty ID')
})

// Response Schema (what we send back)
export const specialtyResponseSchema = z.object({
  id: z.string(),
  name: z.string(),
  createdAt: z.date()
})

// Type exports for TypeScript
export type CreateSpecialtyInput = z.infer<typeof createSpecialtySchema>
export type UpdateSpecialtyInput = z.infer<typeof updateSpecialtySchema>
export type SpecialtyParams = z.infer<typeof specialtyParamsSchema>
export type SpecialtyResponse = z.infer<typeof specialtyResponseSchema>


================================================
File: src/entities/specialty/specialty.service.ts
================================================
import { PrismaClient } from '@prisma/client'
import { CreateSpecialtyInput, UpdateSpecialtyInput } from './specialty.schema'

export class SpecialtyService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateSpecialtyInput) {
    return await this.prisma.specialty.create({
      data: {
        name: data.name
      }
    })
  }

  async findAll() {
    return await this.prisma.specialty.findMany({
      orderBy: {
        name: 'asc'
      }
    })
  }

  async findById(id: string) {
    const specialty = await this.prisma.specialty.findUnique({
      where: { id }
    })

    if (!specialty) {
      throw new Error('Specialty not found')
    }

    return specialty
  }

  async update(id: string, data: UpdateSpecialtyInput) {
    // Check if exists first
    await this.findById(id)

    return await this.prisma.specialty.update({
      where: { id },
      data
    })
  }

  async delete(id: string) {
    // Check if exists first
    await this.findById(id)

    return await this.prisma.specialty.delete({
      where: { id }
    })
  }
}


================================================
File: src/entities/student/student.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { z } from 'zod'
import { StudentService } from './student.service'
import { 
  createStudentSchema, 
  updateStudentSchema, 
  studentUserParamsSchema 
} from './student.schema'

// Credit operation schemas
const creditOperationSchema = z.object({
  amount: z.number().positive('Amount must be positive'),
  reason: z.string().optional()
})

export default async function studentRoutes(fastify: FastifyInstance) {
  const studentService = new StudentService(fastify.prisma)

  // GET /students - Get all students
  fastify.get('/students', async (request, reply) => {
    try {
      const students = await studentService.findAll()
      reply.send(students)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch students' })
    }
  })

  // GET /students/:userId - Get student by User ID
  fastify.get('/students/:userId', async (request, reply) => {
    try {
      const { userId } = studentUserParamsSchema.parse(request.params)
      const student = await studentService.findByUserId(userId)
      reply.send(student)
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /students - Create new student (creates User + Student)
  fastify.post('/students', async (request, reply) => {
    try {
      const data = createStudentSchema.parse(request.body)
      const student = await studentService.create(data)
      reply.status(201).send(student)
    } catch (error) {
      if (error instanceof Error && error.message.includes('Unique constraint failed')) {
        reply.status(400).send({ error: 'Email already exists' })
      } else {
        reply.status(400).send({ error: 'Invalid data' })
      }
    }
  })

  // PUT /students/:userId - Update student by User ID
  fastify.put('/students/:userId', async (request, reply) => {
    try {
      const { userId } = studentUserParamsSchema.parse(request.params)
      const data = updateStudentSchema.parse(request.body)
      
      // Get student by userId first to get the UUID for update
      const existingStudent = await studentService.findByUserId(userId)
      const student = await studentService.update(existingStudent.id, data)
      reply.send(student)
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // DELETE /students/:userId - Delete student by User ID
  fastify.delete('/students/:userId', async (request, reply) => {
    try {
      const { userId } = studentUserParamsSchema.parse(request.params)
      
      // Get student by userId first to get the UUID for deletion
      const existingStudent = await studentService.findByUserId(userId)
      await studentService.delete(existingStudent.id)
      reply.status(204).send()
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // CREDIT MANAGEMENT ENDPOINTS

  // GET /students/:userId/credits - Get credit balance
  fastify.get('/students/:userId/credits', async (request, reply) => {
    try {
      const { userId } = studentUserParamsSchema.parse(request.params)
      const balance = await studentService.getCreditBalance(userId)
      reply.send({ userId, creditBalance: balance })
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /students/:userId/credits/add - Add credits
  fastify.post('/students/:userId/credits/add', async (request, reply) => {
    try {
      const { userId } = studentUserParamsSchema.parse(request.params)
      const { amount, reason } = creditOperationSchema.parse(request.body)
      
      const student = await studentService.addCredits(userId, amount, reason)
      reply.send({
        message: 'Credits added successfully',
        student,
        operation: {
          type: 'credit',
          amount,
          reason: reason || 'Manual credit addition'
        }
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: error instanceof Error ? error.message : 'Invalid request' })
      }
    }
  })

  // POST /students/:userId/credits/deduct - Deduct credits
  fastify.post('/students/:userId/credits/deduct', async (request, reply) => {
    try {
      const { userId } = studentUserParamsSchema.parse(request.params)
      const { amount, reason } = creditOperationSchema.parse(request.body)
      
      const student = await studentService.deductCredits(userId, amount, reason)
      reply.send({
        message: 'Credits deducted successfully',
        student,
        operation: {
          type: 'debit',
          amount,
          reason: reason || 'Manual credit deduction'
        }
      })
    } catch (error) {
      if (error instanceof Error && (error.message === 'Student not found' || error.message === 'Insufficient credits')) {
        const status = error.message === 'Student not found' ? 404 : 400
        reply.status(status).send({ error: error.message })
      } else {
        reply.status(400).send({ error: error instanceof Error ? error.message : 'Invalid request' })
      }
    }
  })

  // GET /students/:userId/credits/check/:amount - Check if student has sufficient credits
  fastify.get('/students/:userId/credits/check/:amount', async (request, reply) => {
    try {
      const { userId } = studentUserParamsSchema.parse(request.params)
      const { amount } = request.params as { amount: string }
      const requiredAmount = parseInt(amount)
      
      if (isNaN(requiredAmount) || requiredAmount <= 0) {
        return reply.status(400).send({ error: 'Invalid amount' })
      }
      
      const hasSufficientCredits = await studentService.checkSufficientCredits(userId, requiredAmount)
      const currentBalance = await studentService.getCreditBalance(userId)
      
      reply.send({
        userId,
        requiredAmount,
        currentBalance,
        hasSufficientCredits,
        shortfall: hasSufficientCredits ? 0 : requiredAmount - currentBalance
      })
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })
}


================================================
File: src/entities/student/student.schema.ts
================================================
import { z } from 'zod'

// Create Student Schema (includes User data)
export const createStudentSchema = z.object({
  // User fields
  email: z.string().email('Invalid email format'),
  name: z.string().optional(),
  
  // Student fields
  firstName: z.string()
    .min(1, 'First name is required')
    .max(50, 'First name must be less than 50 characters')
    .trim(),
  lastName: z.string()
    .min(1, 'Last name is required')
    .max(50, 'Last name must be less than 50 characters')
    .trim(),
  dateOfBirth: z.string()
    .datetime('Invalid date format')
    .or(z.date())
    .transform((val) => new Date(val))
    .refine((date) => {
      const age = (new Date().getTime() - date.getTime()) / (1000 * 60 * 60 * 24 * 365.25)
      return age >= 18 && age <= 100
    }, 'Age must be between 18 and 100 years')
  // Note: creditBalance is NOT included - always starts at 0
})

// Update Student Schema
export const updateStudentSchema = z.object({
  firstName: z.string()
    .min(1, 'First name is required')
    .max(50, 'First name must be less than 50 characters')
    .trim()
    .optional(),
  lastName: z.string()
    .min(1, 'Last name is required')
    .max(50, 'Last name must be less than 50 characters')
    .trim()
    .optional(),
  dateOfBirth: z.string()
    .datetime('Invalid date format')
    .or(z.date())
    .transform((val) => new Date(val))
    .refine((date) => {
      const age = (new Date().getTime() - date.getTime()) / (1000 * 60 * 60 * 24 * 365.25)
      return age >= 18 && age <= 100
    }, 'Age must be between 18 and 100 years')
    .optional()
  // Note: creditBalance updates will be handled by separate business methods
})

// URL Params Schema
const studentUserParamsSchema = z.object({
  userId: z.string().transform(val => parseInt(val)).refine(val => !isNaN(val), 'Invalid user ID')
})

// Response Schema
export const studentResponseSchema = z.object({
  id: z.string(),
  userId: z.number(),
  firstName: z.string(),
  lastName: z.string(),
  dateOfBirth: z.date(),
  creditBalance: z.number(),
  createdAt: z.date(),
  updatedAt: z.date(),
  user: z.object({
    id: z.number(),
    email: z.string(),
    name: z.string().nullable()
  })
})

// Type exports
export type CreateStudentInput = z.infer<typeof createStudentSchema>
export type UpdateStudentInput = z.infer<typeof updateStudentSchema>
export type StudentUserParams = z.infer<typeof studentUserParamsSchema>
export type StudentResponse = z.infer<typeof studentResponseSchema>

// Export the params schema
export { studentUserParamsSchema }


================================================
File: src/entities/student/student.service.ts
================================================
import { PrismaClient, Prisma } from '@prisma/client'
import { CreateStudentInput, UpdateStudentInput } from './student.schema'

export class StudentService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateStudentInput) {
    // Create User and Student in a transaction
    return await this.prisma.$transaction(async (tx: Prisma.TransactionClient) => {
      // First, create the User
      const user = await tx.user.create({
        data: {
          email: data.email,
          name: data.name
        }
      })

      // Then, create the Student linked to the User
      const student = await tx.student.create({
        data: {
          userId: user.id,
          firstName: data.firstName,
          lastName: data.lastName,
          dateOfBirth: data.dateOfBirth,
          creditBalance: 0 // Always start with 0 credits
        },
        include: {
          user: true
        }
      })

      return student
    })
  }

  async findAll() {
    return await this.prisma.student.findMany({
      include: {
        user: true
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async findById(id: string) {
    const student = await this.prisma.student.findUnique({
      where: { id },
      include: {
        user: true
      }
    })

    if (!student) {
      throw new Error('Student not found')
    }

    return student
  }

  async findByUserId(userId: number) {
    const student = await this.prisma.student.findUnique({
      where: { userId },
      include: {
        user: true
      }
    })

    if (!student) {
      throw new Error('Student not found')
    }

    return student
  }

  async update(id: string, data: UpdateStudentInput) {
    // Check if exists first
    await this.findById(id)

    return await this.prisma.student.update({
      where: { id },
      data,
      include: {
        user: true
      }
    })
  }

  async delete(id: string) {
    // Check if exists first
    const student = await this.findById(id)

    // Delete in transaction (Student first, then User)
    return await this.prisma.$transaction(async (tx: Prisma.TransactionClient) => {
      await tx.student.delete({
        where: { id }
      })

      await tx.user.delete({
        where: { id: student.userId }
      })
    })
  }

  // CREDIT MANAGEMENT BUSINESS LOGIC

  async addCredits(userId: number, amount: number, reason?: string) {
    if (amount <= 0) {
      throw new Error('Credit amount must be positive')
    }

    const student = await this.findByUserId(userId)
    
    return await this.prisma.student.update({
      where: { userId },
      data: {
        creditBalance: student.creditBalance + amount
      },
      include: {
        user: true
      }
    })
  }

  async deductCredits(userId: number, amount: number, reason?: string) {
    if (amount <= 0) {
      throw new Error('Credit amount must be positive')
    }

    const student = await this.findByUserId(userId)
    
    if (student.creditBalance < amount) {
      throw new Error('Insufficient credits')
    }

    return await this.prisma.student.update({
      where: { userId },
      data: {
        creditBalance: student.creditBalance - amount
      },
      include: {
        user: true
      }
    })
  }

  async getCreditBalance(userId: number): Promise<number> {
    const student = await this.findByUserId(userId)
    return student.creditBalance
  }

  async checkSufficientCredits(userId: number, requiredAmount: number): Promise<boolean> {
    const balance = await this.getCreditBalance(userId)
    return balance >= requiredAmount
  }
}


================================================
File: src/entities/subscription/subscription.routes.ts
================================================
import { FastifyInstance } from 'fastify'
import { SubscriptionService } from './subscription.service'
import { 
  createSubscriptionSchema,
  subscriptionParamsSchema,
  subscriptionStudentParamsSchema,
  subscriptionCourseParamsSchema,
  subscriptionCheckParamsSchema,
  subscriptionQuerySchema
} from './subscription.schema'
import { requireAuth, getCurrentStudentId } from '../../middleware/auth.middleware'

export default async function subscriptionRoutes(fastify: FastifyInstance) {
  const subscriptionService = new SubscriptionService(fastify.prisma)

  // GET /subscriptions - Get all subscriptions (admin only - instructors)
  fastify.get('/subscriptions', {
    preHandler: requireAuth('instructor')
  }, async (request, reply) => {
    try {
      const query = subscriptionQuerySchema.parse(request.query)
      const subscriptions = await subscriptionService.findAll(query)
      reply.send(subscriptions)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch subscriptions' })
    }
  })

  // GET /subscriptions/my - Get current student's subscriptions
  fastify.get('/subscriptions/my', {
    preHandler: requireAuth('student')
  }, async (request, reply) => {
    try {
      const studentId = getCurrentStudentId(request)!
      const query = subscriptionQuerySchema.parse(request.query)
      const subscriptions = await subscriptionService.findByStudent(studentId, query)
      reply.send(subscriptions)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch your subscriptions' })
    }
  })

  // GET /subscriptions/student/:studentId - Get subscriptions by student (instructor only)
  fastify.get('/subscriptions/student/:studentId', {
    preHandler: requireAuth('instructor')
  }, async (request, reply) => {
    try {
      const { studentId } = subscriptionStudentParamsSchema.parse(request.params)
      const query = subscriptionQuerySchema.parse(request.query)
      const subscriptions = await subscriptionService.findByStudent(studentId, query)
      reply.send(subscriptions)
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /subscriptions/course/:courseId - Get subscriptions by course (instructor only)
  fastify.get('/subscriptions/course/:courseId', {
    preHandler: requireAuth('instructor')
  }, async (request, reply) => {
    try {
      const { courseId } = subscriptionCourseParamsSchema.parse(request.params)
      const query = subscriptionQuerySchema.parse(request.query)
      const subscriptions = await subscriptionService.findByCourse(courseId, query)
      reply.send(subscriptions)
    } catch (error) {
      if (error instanceof Error && error.message === 'Course not found') {
        reply.status(404).send({ error: 'Course not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /subscriptions/check/:studentId/:courseId - Check subscription status (instructor)
  fastify.get('/subscriptions/check/:studentId/:courseId', {
    preHandler: requireAuth('instructor')
  }, async (request, reply) => {
    try {
      const { studentId, courseId } = subscriptionCheckParamsSchema.parse(request.params)
      const status = await subscriptionService.checkSubscription(studentId, courseId)
      reply.send(status)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /subscriptions/my/:courseId/check - Check current student's subscription to a course
  fastify.get('/subscriptions/my/:courseId/check', {
    preHandler: requireAuth('student')
  }, async (request, reply) => {
    try {
      const studentId = getCurrentStudentId(request)!
      const { courseId } = subscriptionCourseParamsSchema.parse(request.params)
      const status = await subscriptionService.checkSubscription(studentId, courseId)
      reply.send(status)
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })

  // GET /subscriptions/my/stats - Get current student's subscription statistics
  fastify.get('/subscriptions/my/stats', {
    preHandler: requireAuth('student')
  }, async (request, reply) => {
    try {
      const studentId = getCurrentStudentId(request)!
      const stats = await subscriptionService.getStudentStats(studentId)
      reply.send(stats)
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch subscription statistics' })
    }
  })

  // GET /subscriptions/student/:studentId/stats - Get student subscription stats (instructor)
  fastify.get('/subscriptions/student/:studentId/stats', {
    preHandler: requireAuth('instructor')
  }, async (request, reply) => {
    try {
      const { studentId } = subscriptionStudentParamsSchema.parse(request.params)
      const stats = await subscriptionService.getStudentStats(studentId)
      reply.send(stats)
    } catch (error) {
      if (error instanceof Error && error.message === 'Student not found') {
        reply.status(404).send({ error: 'Student not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // GET /subscriptions/my/courses - Get all courses student has access to
  fastify.get('/subscriptions/my/courses', {
    preHandler: requireAuth('student')
  }, async (request, reply) => {
    try {
      const studentId = getCurrentStudentId(request)!
      const accessibleCourseIds = await subscriptionService.getAccessibleCourses(studentId)
      
      // Fetch full course details
      const courses = await fastify.prisma.course.findMany({
        where: {
          id: { in: accessibleCourseIds }
        },
        include: {
          exam: {
            select: {
              id: true,
              title: true,
              slug: true
            }
          }
        }
      })
      
      reply.send({
        totalAccessibleCourses: courses.length,
        courses
      })
    } catch (error) {
      reply.status(500).send({ error: 'Failed to fetch accessible courses' })
    }
  })

  // GET /subscriptions/:id - Get subscription by ID
  fastify.get('/subscriptions/:id', {
    preHandler: requireAuth()
  }, async (request, reply) => {
    try {
      const { id } = subscriptionParamsSchema.parse(request.params)
      const subscription = await subscriptionService.findById(id)
      
      // Check authorization - students can only see their own subscriptions
      const user = request.user as any;
      if (user?.role === 'student' && subscription.studentId !== getCurrentStudentId(request)) {
        reply.status(403).send({ error: 'Access denied' })
        return
      }
      
      reply.send(subscription)
    } catch (error) {
      if (error instanceof Error && error.message === 'Subscription not found') {
        reply.status(404).send({ error: 'Subscription not found' })
      } else {
        reply.status(400).send({ error: 'Invalid request' })
      }
    }
  })

  // POST /subscriptions - Create new subscription (mock payment)
  fastify.post('/subscriptions', {
    preHandler: requireAuth('student')
  }, async (request, reply) => {
    try {
      const studentId = getCurrentStudentId(request)!
      const data = createSubscriptionSchema.parse(request.body)
      
      // Ensure student is subscribing for themselves
      if (data.studentId !== studentId) {
        reply.status(403).send({ error: 'You can only create subscriptions for yourself' })
        return
      }
      
      const subscription = await subscriptionService.create(data)
      
      // Get updated student info for credit balance
      const student = await fastify.prisma.student.findUnique({
        where: { id: studentId }
      })
      
      reply.status(201).send({
        message: 'Subscription created successfully',
        subscription,
        creditsAdded: subscription.course.style === 'RANDOM' 
          ? (data.durationMonths === 3 ? subscription.course.credits3Months :
             data.durationMonths === 6 ? subscription.course.credits6Months :
             subscription.course.credits12Months)
          : 0,
        newCreditBalance: student?.creditBalance || 0
      })
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === 'Student not found') {
          reply.status(404).send({ error: 'Student not found' })
        } else if (error.message === 'Course not found') {
          reply.status(404).send({ error: 'Course not found' })
        } else if (error.message === 'Course is not published') {
          reply.status(400).send({ error: 'Course is not published' })
        } else if (error.message === 'Student already has an active subscription to this course') {
          reply.status(400).send({ error: 'You already have an active subscription to this course' })
        } else {
          reply.status(400).send({ error: 'Invalid subscription data' })
        }
      } else {
        reply.status(500).send({ error: 'Internal server error' })
      }
    }
  })

  // POST /subscriptions/update-status - Update subscription statuses (can be called periodically)
  fastify.post('/subscriptions/update-status', {
    preHandler: requireAuth('instructor')
  }, async (request, reply) => {
    try {
      await subscriptionService.updateSubscriptionStatus()
      reply.send({ message: 'Subscription statuses updated successfully' })
    } catch (error) {
      reply.status(500).send({ error: 'Failed to update subscription statuses' })
    }
  })

  // Helper endpoint to check content access
  fastify.get('/subscriptions/can-access/:courseId', {
    preHandler: requireAuth('student')
  }, async (request, reply) => {
    try {
      const studentId = getCurrentStudentId(request)!
      const { courseId } = subscriptionCourseParamsSchema.parse(request.params)
      const canAccess = await subscriptionService.canAccessCourseContent(studentId, courseId)
      
      reply.send({
        courseId,
        canAccess,
        reason: canAccess ? 'Active subscription or free content' : 'No active subscription'
      })
    } catch (error) {
      reply.status(400).send({ error: 'Invalid request' })
    }
  })
}


================================================
File: src/entities/subscription/subscription.schema.ts
================================================
import { z } from 'zod'

// Create Subscription Schema (mocking payment for now)
export const createSubscriptionSchema = z.object({
  studentId: z.string().uuid('Invalid student ID'),
  courseId: z.string().uuid('Invalid course ID'),
  durationMonths: z.enum(['3', '6', '12']).transform(val => parseInt(val)),
  // In production, paymentId would come from Stripe
  mockPaymentId: z.string().default('mock_payment_' + Date.now())
})

// Check Subscription Schema
export const checkSubscriptionSchema = z.object({
  studentId: z.string().uuid('Invalid student ID'),
  courseId: z.string().uuid('Invalid course ID')
})

// URL Params Schemas
export const subscriptionParamsSchema = z.object({
  id: z.string().uuid('Invalid subscription ID')
})

export const subscriptionStudentParamsSchema = z.object({
  studentId: z.string().uuid('Invalid student ID')
})

export const subscriptionCourseParamsSchema = z.object({
  courseId: z.string().uuid('Invalid course ID')
})

export const subscriptionCheckParamsSchema = z.object({
  studentId: z.string().uuid('Invalid student ID'),
  courseId: z.string().uuid('Invalid course ID')
})

// Query Params Schema
export const subscriptionQuerySchema = z.object({
  active: z.string().transform(val => val === 'true').optional(),
  includeExpired: z.string().transform(val => val === 'true').optional()
})

// Response Schemas
export const subscriptionResponseSchema = z.object({
  id: z.string(),
  studentId: z.string(),
  courseId: z.string(),
  paymentId: z.string(),
  durationMonths: z.number(),
  startDate: z.date(),
  endDate: z.date(),
  isActive: z.boolean(),
  createdAt: z.date(),
  student: z.object({
    id: z.string(),
    firstName: z.string(),
    lastName: z.string(),
    email: z.string().optional()
  }).optional(),
  course: z.object({
    id: z.string(),
    title: z.string(),
    style: z.string(),
    exam: z.object({
      id: z.string(),
      title: z.string(),
      slug: z.string()
    })
  }).optional()
})

export const subscriptionStatusResponseSchema = z.object({
  hasActiveSubscription: z.boolean(),
  subscription: subscriptionResponseSchema.optional(),
  daysRemaining: z.number().optional(),
  isExpired: z.boolean()
})

export const subscriptionStatsResponseSchema = z.object({
  studentId: z.string(),
  totalSubscriptions: z.number(),
  activeSubscriptions: z.number(),
  expiredSubscriptions: z.number(),
  totalCreditsReceived: z.number(),
  subscriptionsByDuration: z.object({
    threeMonth: z.number(),
    sixMonth: z.number(),
    twelveMonth: z.number()
  })
})

// Type exports
export type CreateSubscriptionInput = z.infer<typeof createSubscriptionSchema>
export type CheckSubscriptionInput = z.infer<typeof checkSubscriptionSchema>
export type SubscriptionParams = z.infer<typeof subscriptionParamsSchema>
export type SubscriptionStudentParams = z.infer<typeof subscriptionStudentParamsSchema>
export type SubscriptionCourseParams = z.infer<typeof subscriptionCourseParamsSchema>
export type SubscriptionCheckParams = z.infer<typeof subscriptionCheckParamsSchema>
export type SubscriptionQuery = z.infer<typeof subscriptionQuerySchema>
export type SubscriptionResponse = z.infer<typeof subscriptionResponseSchema>
export type SubscriptionStatusResponse = z.infer<typeof subscriptionStatusResponseSchema>
export type SubscriptionStatsResponse = z.infer<typeof subscriptionStatsResponseSchema>


================================================
File: src/entities/subscription/subscription.service.ts
================================================
import { PrismaClient, Prisma, PaymentStatus, CreditTransactionType, CreditTransactionSource } from '@prisma/client'
import { CreateSubscriptionInput } from './subscription.schema'

export class SubscriptionService {
  constructor(private prisma: PrismaClient) {}

  async create(data: CreateSubscriptionInput) {
    // Verify the student exists
    const student = await this.prisma.student.findUnique({
      where: { id: data.studentId }
    })

    if (!student) {
      throw new Error('Student not found')
    }

    // Verify the course exists and get pricing/credit info
    const course = await this.prisma.course.findUnique({
      where: { id: data.courseId },
      include: {
        exam: true
      }
    })

    if (!course) {
      throw new Error('Course not found')
    }

    if (!course.isPublished) {
      throw new Error('Course is not published')
    }

    // Check if student already has an active subscription to this course
    const existingActiveSubscription = await this.checkActiveSubscription(data.studentId, data.courseId)
    if (existingActiveSubscription) {
      throw new Error('Student already has an active subscription to this course')
    }

    // Get pricing and credits based on duration
    const pricing = this.getCoursePricing(course, data.durationMonths)
    
    // Calculate subscription dates
    const startDate = new Date()
    const endDate = new Date()
    endDate.setMonth(endDate.getMonth() + data.durationMonths)

    // Create subscription with payment and complimentary credits in a transaction
    return await this.prisma.$transaction(async (tx: Prisma.TransactionClient) => {
      // Create mock payment record
      const payment = await tx.payment.create({
        data: {
          studentId: data.studentId,
          stripePaymentId: data.mockPaymentId,
          amount: pricing.price,
          currency: 'USD',
          paymentType: 'SUBSCRIPTION',
          paymentStatus: PaymentStatus.COMPLETED,
          courseId: data.courseId,
          subscriptionDuration: data.durationMonths,
          creditsAmount: null // Credits are tracked separately
        }
      })

      // Create subscription
      const subscription = await tx.subscription.create({
        data: {
          studentId: data.studentId,
          courseId: data.courseId,
          paymentId: payment.id,
          durationMonths: data.durationMonths,
          startDate: startDate,
          endDate: endDate,
          isActive: true
        },
        include: {
          course: {
            include: {
              exam: {
                select: {
                  id: true,
                  title: true,
                  slug: true
                }
              }
            }
          },
          student: {
            select: {
              id: true,
              firstName: true,
              lastName: true
            }
          }
        }
      })

      // Add complimentary credits
      await tx.student.update({
        where: { id: data.studentId },
        data: {
          creditBalance: {
            increment: pricing.credits
          }
        }
      })

      // Create credit transaction record
      await tx.creditTransaction.create({
        data: {
          studentId: data.studentId,
          transactionType: CreditTransactionType.CREDIT,
          amount: pricing.credits,
          balanceAfter: student.creditBalance + pricing.credits,
          sourceType: CreditTransactionSource.SUBSCRIPTION,
          sourceId: subscription.id,
          description: `Complimentary credits for ${data.durationMonths}-month subscription to ${course.title}`,
          expiresAt: endDate // Credits expire with subscription
        }
      })

      return subscription
    })
  }

  async findAll(query?: { active?: boolean; includeExpired?: boolean }) {
    const where: any = {}
    
    if (query?.active !== undefined) {
      where.isActive = query.active
    }
    
    if (!query?.includeExpired) {
      where.endDate = { gte: new Date() }
    }

    return await this.prisma.subscription.findMany({
      where,
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true
          }
        },
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async findById(id: string) {
    const subscription = await this.prisma.subscription.findUnique({
      where: { id },
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true
          }
        },
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        }
      }
    })

    if (!subscription) {
      throw new Error('Subscription not found')
    }

    return subscription
  }

  async findByStudent(studentId: string, query?: { active?: boolean; includeExpired?: boolean }) {
    // Verify student exists
    const student = await this.prisma.student.findUnique({
      where: { id: studentId }
    })

    if (!student) {
      throw new Error('Student not found')
    }

    const where: any = { studentId }
    
    if (query?.active !== undefined) {
      where.isActive = query.active
    }
    
    if (!query?.includeExpired) {
      where.endDate = { gte: new Date() }
    }

    const subscriptions = await this.prisma.subscription.findMany({
      where,
      include: {
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        }
      },
      orderBy: {
        endDate: 'desc'
      }
    })

    // Update isActive status based on dates
    return subscriptions.map((sub:any) => ({
      ...sub,
      isActive: this.isSubscriptionActive(sub)
    }))
  }

  async findByCourse(courseId: string, query?: { active?: boolean }) {
    // Verify course exists
    const course = await this.prisma.course.findUnique({
      where: { id: courseId }
    })

    if (!course) {
      throw new Error('Course not found')
    }

    const where: any = { courseId }
    
    if (query?.active !== undefined) {
      where.isActive = query.active
    } else {
      // Default to only active subscriptions
      where.endDate = { gte: new Date() }
    }

    return await this.prisma.subscription.findMany({
      where,
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })
  }

  async checkSubscription(studentId: string, courseId: string) {
    const subscription = await this.prisma.subscription.findFirst({
      where: {
        studentId,
        courseId,
        endDate: { gte: new Date() }
      },
      include: {
        course: {
          include: {
            exam: {
              select: {
                id: true,
                title: true,
                slug: true
              }
            }
          }
        }
      }
    })

    if (!subscription) {
      return {
        hasActiveSubscription: false,
        subscription: undefined,
        daysRemaining: 0,
        isExpired: true
      }
    }

    const daysRemaining = Math.ceil((subscription.endDate.getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24))
    const isActive = this.isSubscriptionActive(subscription)

    return {
      hasActiveSubscription: isActive,
      subscription: {
        ...subscription,
        isActive
      },
      daysRemaining: daysRemaining > 0 ? daysRemaining : 0,
      isExpired: !isActive
    }
  }

  async checkActiveSubscription(studentId: string, courseId: string): Promise<boolean> {
    const result = await this.checkSubscription(studentId, courseId)
    return result.hasActiveSubscription
  }

  async getStudentStats(studentId: string) {
    // Verify student exists
    const student = await this.prisma.student.findUnique({
      where: { id: studentId }
    })

    if (!student) {
      throw new Error('Student not found')
    }

    const subscriptions = await this.prisma.subscription.findMany({
      where: { studentId }
    })

    const now = new Date()
    const activeSubscriptions = subscriptions.filter((sub:any) => 
      sub.endDate >= now && sub.startDate <= now
    )

    const expiredSubscriptions = subscriptions.filter((sub:any) => 
      sub.endDate < now
    )

    // Get total credits received from subscriptions
    const creditTransactions = await this.prisma.creditTransaction.findMany({
      where: {
        studentId,
        sourceType: CreditTransactionSource.SUBSCRIPTION,
        transactionType: CreditTransactionType.CREDIT
      }
    })

    const totalCreditsReceived = creditTransactions.reduce((sum:any, t:any) => sum + t.amount, 0)

    // Count by duration
    const subscriptionsByDuration = {
      threeMonth: subscriptions.filter((s:any) => s.durationMonths === 3).length,
      sixMonth: subscriptions.filter((s:any) => s.durationMonths === 6).length,
      twelveMonth: subscriptions.filter((s:any) => s.durationMonths === 12).length
    }

    return {
      studentId,
      totalSubscriptions: subscriptions.length,
      activeSubscriptions: activeSubscriptions.length,
      expiredSubscriptions: expiredSubscriptions.length,
      totalCreditsReceived,
      subscriptionsByDuration
    }
  }

  async updateSubscriptionStatus() {
    // This method can be called periodically to update isActive status
    const now = new Date()
    
    // Deactivate expired subscriptions
    await this.prisma.subscription.updateMany({
      where: {
        endDate: { lt: now },
        isActive: true
      },
      data: {
        isActive: false
      }
    })

    // Activate subscriptions that should be active
    await this.prisma.subscription.updateMany({
      where: {
        startDate: { lte: now },
        endDate: { gte: now },
        isActive: false
      },
      data: {
        isActive: true
      }
    })
  }

  // Helper methods

  private getCoursePricing(course: any, durationMonths: number) {
    switch (durationMonths) {
      case 3:
        return {
          price: course.price3Months,
          credits: course.credits3Months
        }
      case 6:
        return {
          price: course.price6Months,
          credits: course.credits6Months
        }
      case 12:
        return {
          price: course.price12Months,
          credits: course.credits12Months
        }
      default:
        throw new Error('Invalid subscription duration')
    }
  }

  private isSubscriptionActive(subscription: any): boolean {
    const now = new Date()
    return subscription.startDate <= now && subscription.endDate >= now
  }

  // Method to check if student can access course content
  async canAccessCourseContent(studentId: string, courseId: string): Promise<boolean> {
    // Check if the course case is free first
    const courseCase = await this.prisma.courseCase.findFirst({
      where: { courseId }
    })

    if (courseCase?.isFree) {
      return true // Free content is always accessible
    }

    // Check subscription
    return await this.checkActiveSubscription(studentId, courseId)
  }

  // Method to get all courses a student has access to
  async getAccessibleCourses(studentId: string) {
    const activeSubscriptions = await this.findByStudent(studentId, { active: true })
    
    const subscribedCourseIds = activeSubscriptions.map((sub:any) => sub.courseId)
    
    // Also get courses with free content
    const coursesWithFreeContent = await this.prisma.course.findMany({
      where: {
        courseCases: {
          some: {
            isFree: true
          }
        },
        isPublished: true
      },
      select: {
        id: true
      }
    })

    const freeCourseIds = coursesWithFreeContent.map((c:any) => c.id)
    
    // Combine and deduplicate
    const accessibleCourseIds = [...new Set([...subscribedCourseIds, ...freeCourseIds])]
    
    return accessibleCourseIds
  }
}


================================================
File: src/middleware/auth.middleware.ts
================================================
import { FastifyRequest, FastifyReply } from 'fastify'
import { JWTPayload } from '../entities/auth/auth.schema'

// Extend FastifyJWT interface
declare module '@fastify/jwt' {
  interface FastifyJWT {
    payload: JWTPayload
    user: JWTPayload
  }
}

// Add custom properties to FastifyRequest
declare module 'fastify' {
  interface FastifyRequest {
    role?: 'student' | 'instructor'
  }
}

// Auth middleware - verifies JWT and attaches user to request
export async function authenticate(request: FastifyRequest, reply: FastifyReply) {
  try {
    await request.jwtVerify()
    
    // The JWT payload is automatically attached to request.user by fastify-jwt
    const user = request.user as JWTPayload
    request.role = user.role // Changed from user.userType to user.role
  } catch (err) {
    reply.status(401).send({ error: 'Unauthorized' })
  }
}

// Role-based middleware - checks if user has required role
export function requireRole(role: 'student' | 'instructor') {
  return async function (request: FastifyRequest, reply: FastifyReply) {
    const user = request.user as JWTPayload | undefined
    
    if (!user) {
      reply.status(401).send({ error: 'Unauthorized' })
      return
    }

    if (request.role !== role) {
      reply.status(403).send({ error: `Access denied. ${role} role required.` })
      return
    }
  }
}

// Combined auth middleware that requires authentication and specific role
export function requireAuth(role?: 'student' | 'instructor') {
  return async function (request: FastifyRequest, reply: FastifyReply) {
    // First authenticate
    await authenticate(request, reply)
    
    // If authentication passed and role is specified, check role
    if (role && request.user) {
      await requireRole(role)(request, reply)
    }
  }
}

// Optional auth middleware - attaches user if token is valid, but doesn't fail if not
export async function optionalAuth(request: FastifyRequest, reply: FastifyReply) {
  try {
    await request.jwtVerify()
    const user = request.user as JWTPayload
    request.role = user.role // Changed from user.userType to user.role
  } catch (err) {
    // Don't fail, just continue without user
    request.role = undefined
  }
}

// Helper to get current user ID
export function getCurrentUserId(request: FastifyRequest): number | null {
  const user = request.user as JWTPayload | undefined
  return user?.userId || null
}

// Helper to get current student ID
export function getCurrentStudentId(request: FastifyRequest): string | null {
  const user = request.user as JWTPayload | undefined
  if (request.role === 'student' && user?.studentId) {
    return user.studentId
  }
  return null
}

// Helper to get current instructor ID
export function getCurrentInstructorId(request: FastifyRequest): string | null {
  const user = request.user as JWTPayload | undefined
  if (request.role === 'instructor' && user?.instructorId) {
    return user.instructorId
  }
  return null
}


================================================
File: src/services/voice-token.service.ts
================================================
import jwt from 'jsonwebtoken';

export class VoiceTokenService {
  private readonly secret: string;
  private readonly expiryMinutes: number = 15;

  constructor() {
    if (!process.env.VOICE_AGENT_SHARED_SECRET) {
      throw new Error('VOICE_AGENT_SHARED_SECRET not configured');
    }
    this.secret = process.env.VOICE_AGENT_SHARED_SECRET;
  }

  generateToken(payload: {
    attemptId: string;
    studentId: string;
    correlationToken: string;
  }): string {
    return jwt.sign(
      {
        ...payload,
        type: 'voice_session',
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + (this.expiryMinutes * 60)
      },
      this.secret,
      { algorithm: 'HS256' }
    );
  }

  verifyToken(token: string): any {
    return jwt.verify(token, this.secret, { algorithms: ['HS256'] });
  }
}

export const voiceTokenService = new VoiceTokenService();


================================================
File: src/shared/junction-tables.schema.ts
================================================
// junction-tables.schema.ts
import { z } from 'zod'
import { PatientGenderEnum } from '../entities/course-case/course-case.schema'

// ===== COURSE CASE JUNCTION SCHEMAS =====

// Assign Specialties Schema
export const assignSpecialtiesSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  specialtyIds: z.array(z.string().uuid('Invalid specialty ID'))
    .min(1, 'At least one specialty is required')
    .max(10, 'Cannot assign more than 10 specialties')
})

// Assign Curriculums Schema  
export const assignCurriculumsSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  curriculumIds: z.array(z.string().uuid('Invalid curriculum ID'))
    .min(1, 'At least one curriculum item is required')
    .max(15, 'Cannot assign more than 15 curriculum items')
})

// Filter Cases Schema
export const filterCasesSchema = z.object({
  courseId: z.string().uuid('Invalid course ID'),
  specialtyIds: z.array(z.string().uuid('Invalid specialty ID')).optional(),
  curriculumIds: z.array(z.string().uuid('Invalid curriculum ID')).optional(),
  isFree: z.boolean().optional(),
  patientGender: PatientGenderEnum.optional()
})

// Bulk Assignment Schema
export const bulkAssignFiltersSchema = z.object({
  assignments: z.array(z.object({
    courseCaseId: z.string().uuid('Invalid course case ID'),
    specialtyIds: z.array(z.string().uuid('Invalid specialty ID')).optional(),
    curriculumIds: z.array(z.string().uuid('Invalid curriculum ID')).optional()
  })).min(1, 'At least one assignment is required').max(50, 'Cannot process more than 50 assignments at once')
})

// Remove Assignment Schemas
export const removeSpecialtySchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  specialtyId: z.string().uuid('Invalid specialty ID')
})

export const removeCurriculumSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  curriculumId: z.string().uuid('Invalid curriculum ID')
})

// URL Params Schemas
export const courseCaseParamsSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID')
})

export const courseParamsSchema = z.object({
  courseId: z.string().uuid('Invalid course ID')
})

export const specialtyRemoveParamsSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  specialtyId: z.string().uuid('Invalid specialty ID')
})

export const curriculumRemoveParamsSchema = z.object({
  courseCaseId: z.string().uuid('Invalid course case ID'),
  curriculumId: z.string().uuid('Invalid curriculum ID')
})

// Query Params Schema (for filtering)
export const filterQuerySchema = z.object({
  specialtyIds: z.string().optional().transform((val) => 
    val ? val.split(',').filter(id => id.trim().length > 0) : undefined
  ),
  curriculumIds: z.string().optional().transform((val) => 
    val ? val.split(',').filter(id => id.trim().length > 0) : undefined
  ),
  isFree: z.string().optional().transform((val) => 
    val === 'true' ? true : val === 'false' ? false : undefined
  ),
  patientGender: z.string().optional().refine((val) => 
    !val || ['MALE', 'FEMALE', 'OTHER'].includes(val), 'Invalid patient gender'
  ).transform((val) => val as 'MALE' | 'FEMALE' | 'OTHER' | undefined)
})

// Response Schemas
export const caseWithFiltersResponseSchema = z.object({
  id: z.string(),
  courseId: z.string(),
  title: z.string(),
  diagnosis: z.string(),
  patientName: z.string(),
  patientAge: z.number(),
  patientGender: PatientGenderEnum,
  description: z.string(),
  isFree: z.boolean(),
  displayOrder: z.number(),
  createdAt: z.date(),
  updatedAt: z.date(),
  specialties: z.array(z.object({
    id: z.string(),
    name: z.string()
  })),
  curriculums: z.array(z.object({
    id: z.string(),
    name: z.string()
  })),
  course: z.object({
    id: z.string(),
    title: z.string(),
    exam: z.object({
      id: z.string(),
      title: z.string(),
      slug: z.string()
    })
  })
})

export const filteringStatsResponseSchema = z.object({
  courseId: z.string(),
  totalCases: z.number(),
  specialtyDistribution: z.array(z.object({
    specialtyId: z.string(),
    count: z.number(),
    specialty: z.object({
      id: z.string(),
      name: z.string()
    })
  })),
  curriculumDistribution: z.array(z.object({
    curriculumId: z.string(),
    count: z.number(),
    curriculum: z.object({
      id: z.string(),
      name: z.string()
    })
  }))
})

// ===== EXAM JUNCTION SCHEMAS =====

// Assign Specialties to Exam Schema
export const assignExamSpecialtiesSchema = z.object({
  examId: z.string().uuid('Invalid exam ID'),
  specialtyIds: z.array(z.string().uuid('Invalid specialty ID'))
    .min(1, 'At least one specialty is required')
    .max(20, 'Cannot assign more than 20 specialties')
})

// Assign Curriculums to Exam Schema  
export const assignExamCurriculumsSchema = z.object({
  examId: z.string().uuid('Invalid exam ID'),
  curriculumIds: z.array(z.string().uuid('Invalid curriculum ID'))
    .min(1, 'At least one curriculum item is required')
    .max(30, 'Cannot assign more than 30 curriculum items')
})

// Assign Marking Domains to Exam Schema
export const assignExamMarkingDomainsSchema = z.object({
  examId: z.string().uuid('Invalid exam ID'),
  markingDomainIds: z.array(z.string().uuid('Invalid marking domain ID'))
    .min(1, 'At least one marking domain is required')
    .max(15, 'Cannot assign more than 15 marking domains')
})

// Bulk Configuration Schema
export const bulkConfigureExamSchema = z.object({
  examId: z.string().uuid('Invalid exam ID'),
  specialtyIds: z.array(z.string().uuid('Invalid specialty ID')).optional(),
  curriculumIds: z.array(z.string().uuid('Invalid curriculum ID')).optional(),
  markingDomainIds: z.array(z.string().uuid('Invalid marking domain ID')).optional()
}).refine(
  (data) => data.specialtyIds || data.curriculumIds || data.markingDomainIds,
  { message: 'At least one assignment type must be provided' }
)

// URL Params Schemas for Exam Removal Operations
export const examRemoveSpecialtyParamsSchema = z.object({
  examId: z.string().uuid('Invalid exam ID'),
  specialtyId: z.string().uuid('Invalid specialty ID')
})

export const examRemoveCurriculumParamsSchema = z.object({
  examId: z.string().uuid('Invalid exam ID'),
  curriculumId: z.string().uuid('Invalid curriculum ID')
})

export const examRemoveMarkingDomainParamsSchema = z.object({
  examId: z.string().uuid('Invalid exam ID'),
  markingDomainId: z.string().uuid('Invalid marking domain ID')
})

// Exam Response Schemas
export const examConfigurationResponseSchema = z.object({
  exam: z.object({
    id: z.string(),
    title: z.string(),
    slug: z.string(),
    description: z.string().nullable(),
    isActive: z.boolean()
  }),
  configuration: z.object({
    specialties: z.array(z.object({
      id: z.string(),
      name: z.string(),
      description: z.string().optional()
    })),
    curriculums: z.array(z.object({
      id: z.string(),
      name: z.string(),
      description: z.string().optional()
    })),
    markingDomains: z.array(z.object({
      id: z.string(),
      name: z.string(),
      description: z.string().optional()
    }))
  }),
  summary: z.object({
    specialtiesCount: z.number(),
    curriculumsCount: z.number(),
    markingDomainsCount: z.number(),
    isFullyConfigured: z.boolean()
  })
})

export const examUsageStatsResponseSchema = z.object({
  examId: z.string(),
  examTitle: z.string(),
  usage: z.object({
    coursesCount: z.number(),
    casesCount: z.number(),
    simulationsCount: z.number()
  }),
  configuration: z.object({
    specialtiesCount: z.number(),
    curriculumsCount: z.number(),
    markingDomainsCount: z.number()
  })
})

// ===== TYPE EXPORTS =====

// Course Case Types
export type AssignSpecialtiesInput = z.infer<typeof assignSpecialtiesSchema>
export type AssignCurriculumsInput = z.infer<typeof assignCurriculumsSchema>
export type FilterCasesInput = z.infer<typeof filterCasesSchema>
export type BulkAssignFiltersInput = z.infer<typeof bulkAssignFiltersSchema>
export type RemoveSpecialtyInput = z.infer<typeof removeSpecialtySchema>
export type RemoveCurriculumInput = z.infer<typeof removeCurriculumSchema>
export type CourseCaseParams = z.infer<typeof courseCaseParamsSchema>
export type CourseParams = z.infer<typeof courseParamsSchema>
export type SpecialtyRemoveParams = z.infer<typeof specialtyRemoveParamsSchema>
export type CurriculumRemoveParams = z.infer<typeof curriculumRemoveParamsSchema>
export type FilterQuery = z.infer<typeof filterQuerySchema>
export type CaseWithFiltersResponse = z.infer<typeof caseWithFiltersResponseSchema>
export type FilteringStatsResponse = z.infer<typeof filteringStatsResponseSchema>

// Exam Types
export type AssignExamSpecialtiesInput = z.infer<typeof assignExamSpecialtiesSchema>
export type AssignExamCurriculumsInput = z.infer<typeof assignExamCurriculumsSchema>
export type AssignExamMarkingDomainsInput = z.infer<typeof assignExamMarkingDomainsSchema>
export type BulkConfigureExamInput = z.infer<typeof bulkConfigureExamSchema>
export type ExamRemoveSpecialtyParams = z.infer<typeof examRemoveSpecialtyParamsSchema>
export type ExamRemoveCurriculumParams = z.infer<typeof examRemoveCurriculumParamsSchema>
export type ExamRemoveMarkingDomainParams = z.infer<typeof examRemoveMarkingDomainParamsSchema>
export type ExamConfigurationResponse = z.infer<typeof examConfigurationResponseSchema>
export type ExamUsageStatsResponse = z.infer<typeof examUsageStatsResponseSchema>


================================================
File: src/shared/types.ts
================================================
import { PrismaClient } from '@prisma/client'

declare module 'fastify' {
  interface FastifyInstance {
    prisma: PrismaClient
  }
}

export interface TranscriptMessage {
  timestamp: string;
  speaker: 'student' | 'ai_patient' | 'doctor' | 'patient' | 'participant' | 'assistant';
  message: string;
}

export interface TranscriptClean {
  messages: TranscriptMessage[];
  duration: number;
  totalMessages: number;
}

// Use your existing VoiceAssistantTranscriptApi type
export interface VoiceAssistantTranscriptApi {
  correlation_token: string;
  session_id: string;
  conversation_id: string;
  started_at: string;                // ISO-8601 in UTC
  ended_at: string | null;
  duration_seconds: number | null;
  total_messages: number;
  messages: {
    timestamp: string;               // ISO-8601
    speaker: 'participant' | 'assistant';
    message: string;
    audio_duration: number | null;
  }[];
  metadata: {
    simulation_attempt_id: string;
    connected_at: string;
  };
}


